#property copyright "Trend EA Merlin"
#property version   "9.00"
#define CHART_ID 0
#define EA_WINDOW    "Merlin V1"
#define BTN_CLOSE_ALL "BTN_CLOSE_ALL"
#define BTN_CLOSE     "BTN_CLOSE"
#define BTN_CLOSE_PLUS "BTN_CLOSE_PLUS"
#define EDIT_START_BUY "EDIT_START_BUY"
#define EDIT_START_SELL "EDIT_START_SELL"
#define EDIT_STOP_L1 "EDIT_STOP_L1"


#include <Trade/Trade.mqh>
#include <Trade/DealInfo.mqh>
#include <AI_MarketRange.mqh>

//+------------------------------------------------------------------+
//| Nhóm cài ??t chung                                                |
//+------------------------------------------------------------------+
input group "===== CÀI ??T CHUNG ====="
input double defaultFixLength = 0.01;      // Kh?i l??ng ban ??u
input int MaxOrders = 15;                   // S? l?nh t?i ?a m?i chu k?
input double MaxSpread = 369;            // Spread t?i ?a cho phép
input string BuyComment = "Merlin Buy";      // Comment cho chu k? Buy
input string SellComment = "Merlin Sell";    // Comment cho chu k? Sell
input int MaxSimultaneousCycles = 9;     // T?i ?a chu kì 


//+------------------------------------------------------------------+
//| L?i nhu?n                                                         |
//+------------------------------------------------------------------+
input group "=====  RESET L?NH ====="
input double DailyProfitTarget = 1800;    // Target
input bool EnableDailyProfitLimit = true; // B?t/T?t


//+------------------------------------------------------------------+
//| Nhóm cài ??t tâm giá                                        |
//+------------------------------------------------------------------+
input group "===== CÀI ??T TÂM GIÁ ====="
input int Period1FirstEntryDistance = 3000;    // Chu k? 1 - Kho?ng cách m? l?nh ??u
input int Period2FirstEntryDistance = 9000;    // Chu k? 2 - Kho?ng cách m? l?nh ??u
input int Period3FirstEntryDistance = 6000;    // Chu k? 3 - Kho?ng cách m? l?nh ??u
input int OutsideHoursFirstEntryDistance = 900; // Ngoài chu k? - Kho?ng cách m? l?nh ??u
input double HedgingThreshold = 300;            // Kho?ng l? ?? m? l?nh Hedging


//+------------------------------------------------------------------+
//| Nhóm cài ??t th?i gian giao d?ch                                  |
//+------------------------------------------------------------------+
input group "===== CÀI ??T TH?I GIAN ====="
input int Period1StartHour = 0;            // Chu k? 1 - Gi? b?t ??u
input int Period1EndHour = 3;              // Chu k? 1 - Gi? k?t thúc 
input double Period1ExtraDistance = 300;    // Chu k? 1 - Kho?ng cách thêm 

input int Period2StartHour = 11;            // Chu k? 2 - Gi? b?t ??u
input int Period2EndHour = 17;             // Chu k? 2 - Gi? k?t thúc
input double Period2ExtraDistance = 900;   // Chu k? 2 - Kho?ng cách thêm 

input int Period3StartHour = 17;           // Chu k? 3 - Gi? b?t ??u
input int Period3EndHour = 21;             // Chu k? 3 - Gi? k?t thúc
input double Period3ExtraDistance = 600;   // Chu k? 3 - Kho?ng cách thêm
 
input double OutsideHoursExtraDistance = 100; // Kho?ng cách thêm ngoài chu k?


input group "===== GI?I H?N L?NH THEO TH?I GIAN ====="
input int Period1MaxOrders = 15;           // Chu k? 1 - S? l?nh t?i ?a
input int Period2MaxOrders = 9;           // Chu k? 2 - S? l?nh t?i ?a  
input int Period3MaxOrders = 15;          // Chu k? 3 - S? l?nh t?i ?a
input int OutsideHoursMaxOrders = 6;      // Ngoài chu k? - S? l?nh t?i ?a

input group "===== TH?I GIAN ?ÓNG L?NH THEO PHÚT ====="
input bool EnableTimeBasedClosing = false;    // B?t/t?t ?óng l?nh theo th?i gian
input int Period1OrderLifetime = 3880;        // Th?i gian t?n t?i l?nh Chu k? 1 
input int Period2OrderLifetime = 4880;        // Th?i gian t?n t?i l?nh Chu k? 2 
input int Period3OrderLifetime = 5880;        // Th?i gian t?n t?i l?nh Chu k? 3 
input int OutsideHoursLifetime = 2880;        // Th?i gian t?n t?i l?nh ngoài chu k? 


//+------------------------------------------------------------------+
//| Nhóm cài ??t Take Profit                                          |
//+------------------------------------------------------------------+
input group "===== CÀI ??T TP ??N GI?N ====="
input int DefaultTP = 2000;  // TP m?c ??nh cho l?nh cu?i (points)
input double g_TrendTP = 3000;              // TP lênh Trend
input int CombinedTPLevel = 6;             // S? l?nh ?? kích ho?t TP chung (legacy - not used)


//+------------------------------------------------------------------+
//| Nhóm cài ??t nhân kh?i l??ng                                      |
//+------------------------------------------------------------------+
input group "===== CÀI ??T NHÂN KH?I L??NG ====="
input int FirstMultiplyOrder = 1;          // C?p nhân 1 - S? l?nh
input double FirstMultiplier = 1.2;          // C?p nhân 1 - H? s?
input int SecondMultiplyOrder = 5;         // C?p nhân 2 - S? l?nh  
input double SecondMultiplier = 1.5;        // C?p nhân 2 - H? s?
input int ThirdMultiplyOrder = 8;          // C?p nhân 3 - S? l?nh
input double ThirdMultiplier = 1.7;        // C?p nhân 3 - H? s?
input int FourthMultiplyOrder = 11;         // C?p nhân 4 - S? l?nh
input double FourthMultiplier = 1.8;       // C?p nhân 4 - H? s?
input int FifthMultiplyOrder = 14;          // C?p nhân 5 - S? l?nh
input double FifthMultiplier = 2.0;        // C?p nhân 5 - H? s?
input int SixthMultiplyOrder = 16;          // C?p nhân 6 - S? l?nh
input double SixthMultiplier = 2.2;        // C?p nhân 6 - H? s?

input group "===== CÀI ??T H? S? NHÂN L?NH TREND ====="
input int TrendLotLevel1 = 3000;              // Kho?ng cách t?ng lot m?c 1
input double TrendLotMultiplier1 = 1.2;    //    H? s? t?ng lot m?c 1

input int TrendLotLevel2 = 6000;              // Kho?ng cách t?ng lot m?c 2
input double TrendLotMultiplier2 = 1.5;    // H? s? t?ng lot m?c 2

input int TrendLotLevel3 = 9000;              // Kho?ng cách t?ng lot m?c 3
input double TrendLotMultiplier3 = 2.0;    //H? s? t?ng lot m?c 3


//+------------------------------------------------------------------+
//| Nhóm cài ??t h??ng giao d?ch                                      |
//+------------------------------------------------------------------+
input group "===== CÀI ??T H??NG GIAO D?CH ====="
input bool EnableBuyOrders = true;         // Cho phép l?nh Buy
input bool EnableSellOrders = true;        // Cho phép l?nh Sell
input bool EnableHedging = true;         // B?t/T?t Hedging

input group "===== B?O V? PHIÊN M? ====="
input bool EnableNYSessionProtection = true;     // B?t/t?t b?o v? phiên M?
input int NYSessionStartHour = 13;               // Gi? b?t ??u phiên M? (gi? GMT)
input int NYSessionVolatilityPeriod = 60;        // Th?i gian b?o v? sau m? c?a (phút)
input double NYVolatilityThreshold = 300;        // Ng??ng bi?n ??ng cho phép (points)
input bool CloseOrdersOnNYOpen = false;          // ?óng l?nh khi vào phiên M?

input group "===== CÀI ??T ?I?U CH?NH KHO?NG CÁCH ====="
input int MarketRangeThreshold = 15000;     // Ng??ng biên ?? th? tr??ng 
input double MomentumEntryThreshold = 0.0020;  // Ng??ng ??ng l?c th? tr??ng
input double HighRangeMultiplier = 3;     // H? s? nhân khi biên ?? cao
input double NormalRangeMultiplier = 0;   // H? s? nhân khi biên ?? th??ng
input double HeSoNhanKhoangCachToiThieu = 2.0; // H? s? nhân - kho?ng cách t?i thi?u


//+------------------------------------------------------------------+
//| Nhóm cài ??t kho?ng cách DCA tùy ch?nh                           |
//+------------------------------------------------------------------+
input group "===== CÀI ??T KHO?NG CÁCH DCA TÙY CH?NH ====="
input int MinimumOrderDistance = 1500;    // Kho?ng cách t?i thi?u gi?a các l?nh 
input double FirstOrderGap = 3000;         // Kho?ng cách so v?i l?nh 1
input double SecondOrderGap = 2800;        // Kho?ng cách so v?i l?nh 2
input double ThirdOrderGap = 2600;         // Kho?ng cách so v?i l?nh 3
input double FourthOrderGap = 2400;        // Kho?ng cách so v?i l?nh 4
input double FifthOrderGap = 2200;         // Kho?ng cách so v?i l?nh 5
input double SixthOrderGap = 2100;         // Kho?ng cách so v?i l?nh 6
input double SeventhOrderGap = 2000;       // Kho?ng cách so v?i l?nh 7
input double EighthOrderGap = 1900;        // Kho?ng cách so v?i l?nh 8
input double NinthOrderGap = 1800;         // Kho?ng cách so v?i l?nh 9
input double TenthOrderGap = 1700;         // Kho?ng cách so v?i l?nh 10
input double EleventhOrderGap = 1600;      // Kho?ng cách so v?i l?nh 11
input double TwelfthOrderGap = 1500;       // Kho?ng cách so v?i l?nh 12
input double ThirteenthOrderGap = 1500;    // Kho?ng cách so v?i l?nh 13
input double FourteenthOrderGap = 1500;    // Kho?ng cách so v?i l?nh 14
input double FifteenthOrderGap = 2000;     // Kho?ng cách so v?i l?nh 15
input double SixteenthOrderGap = 2000;     // Kho?ng cách so v?i l?nh 16
input int DCADistance = 2000;              // Kho?ng cách m? l?nh DCA 17 tr? lên


input group "===== WEEKEND PROTECTION ====="
input bool EnableWeekendProtection = true;     // B?t/t?t b?o v? cu?i tu?n
input int FridayLastTradeHour = 20;           // Gi? cu?i cùng ???c giao d?ch th? 6 (GMT)
input int MondayFirstTradeHour = 2;           // Gi? ??u tiên ???c giao d?ch th? 2 (GMT)
input bool CloseTradesBeforeWeekend = true;   // ?óng l?nh tr??c cu?i tu?n
input double MinProfitToClose = 0;            // L?i nhu?n t?i thi?u ?? ?óng l?nh (?i?m)

input group "===== MONTH-END PROTECTION ====="
input bool EnableMonthEndProtection = true;    // B?t/t?t b?o v? cu?i tháng
input int MonthEndProtectionDays = 1;          // S? ngày b?o v? cu?i tháng
input int MonthStartProtectionDays = 1;        // S? ngày b?o v? ??u tháng
input int MonthEndLastTradeHour = 20;          // Gi? cu?i cùng giao d?ch cu?i tháng (GMT)
input int MonthStartFirstTradeHour = 2;        // Gi? ??u tiên giao d?ch ??u tháng (GMT)
input bool CloseTradesBeforeMonthEnd = true;   // ?óng l?nh tr??c cu?i tháng
input double MonthEndMinProfitToClose = 0;     // L?i nhu?n t?i thi?u ?? ?óng l?nh cu?i tháng

//+------------------------------------------------------------------+
//| AI Market Range Integration                                      |
//+------------------------------------------------------------------+
input group "===== AI MARKET RANGE ====="
input bool RequireAIConnection = false;        // Yêu c?u k?t n?i AI (true = không trading n?u AI offline)
input int AIThresholdUpdateInterval = 60;      // Th?i gian c?p nh?t AI Threshold (giây)

input group "===== AI-BASED STOP LOSS ====="
input bool EnableAIBasedSL = true;             // Bật/tắt SL dựa trên AI
input double AI_MarketRangeThreshold = 5000;   // Ngưỡng marketRange để kích hoạt SL (points)
input double AI_SL_Points = 500;               // Khoảng cách SL cố định (points) từ lệnh cuối cùng
input bool AI_BlockDCA_OnWrongDirection = true; // Ngăn DCA khi lệnh ngược hướng với imbalance


// Rest of the global variables remain the same
// AI Threshold - bi?n toàn c?c ???c c?p nh?t t? AI
double g_CurrentAIThreshold = 15000;  // Giá tr? m?c ??nh b?ng MarketRangeThreshold
datetime g_LastThresholdUpdate = 0;   // Th?i gian c?p nh?t threshold cu?i cùng

double g_WeeklyRangeAverage = 0;
bool g_startBuy = true;
bool g_startSell = true;
bool g_stopL1 = false;

int g_TotalOrders_Buy = 0;
int g_TotalOrders_Sell = 0;
double g_TotalVolume_Buy = 0;
double g_TotalVolume_Sell = 0;
double g_AveragePrice_Buy = 0;
double g_AveragePrice_Sell = 0;
double g_FirstOrderPrice_Buy = 0;
double g_FirstOrderPrice_Sell = 0;
double g_CommonStopLoss_Buy = 0;
double g_CommonStopLoss_Sell = 0;
bool canOpenNewTrade_Buy = true;
bool canOpenNewTrade_Sell = true;
int g_LastDayChecked = 0;
bool g_CycleComplete = false;
datetime g_LastAnchorTimeCheck = 0;  // Th?i gian check anchor price cu?i cùng
bool g_InHedgeMode = false;
int g_ActiveBuyCycles = 0;
int g_ActiveSellCycles = 0;
double g_LastBuyAnchor = 0;
double g_LastSellAnchor = 0;
string infoLabelName = "EA_Info_Label";  // Khai báo bi?n toàn c?c
datetime g_LastDailyOpenUpdate = 0;
double g_DailyOpenPrice = 0;
double g_PrevDayClose = 0;
bool g_isAfterHours = false;  // Declare at the top with other globals
int g_ConsecutiveLosses = 0;              // ??m s? l?n thua liên ti?p
datetime g_LastRangeReset = 0;
bool g_TrendFollowingMode = false;

// Arrays to track order history
double g_OrderLots[];
datetime g_OrderTimes[];
int g_OrderTypes[];

double g_DailyProfit = 0;
datetime g_LastProfitCheck = 0;
double g_AnchorPrice = 0;
double g_LastAnchorPrice = 0;
double g_DayOpenPrice = 0;
bool isNewDay = false;
datetime g_LastCheckTime = 0;
int g_Period1Orders = 0;
int g_Period2Orders = 0;
int g_Period3Orders = 0;
int g_OutsideHoursOrders = 0;
bool g_DailyTargetHit = false;

bool g_CycleInTrendMode = false;  // Track if current cycle started in trend mode
double g_TrendModeDistance = 0;   // Store the trend mode distance for consistency

bool g_HasActiveTrendOrder = false;
ulong g_CurrentTrendTicket = 0;
datetime g_LastTPTime = 0;
const int MIN_WAIT_AFTER_TP = 0; // 5 phút
ENUM_TIMEFRAMES g_CurrentTimeframe;
int g_ActiveHedgeBuys = 0;
int g_ActiveHedgeSells = 0;
bool g_HasActiveHedgeOrder = false;
datetime g_LastHedgeTime = 0;
const int MIN_WAIT_BETWEEN_HEDGES = 9; // 5 phút

datetime g_LastOrderModification = 0;
datetime g_LastTPUpdate = 0;
const int MIN_ORDER_MOD_INTERVAL = 5; // 5 seconds minimum between modifications

// AI Imbalance Order Cooldown (for scalping)
datetime g_LastAIOrderTime = 0;
bool g_AI_OrderPending = false; // Flag để ngăn mở trùng lặp trong cùng 1 tick
const int AI_ORDER_COOLDOWN = 1; // 60 seconds cooldown between AI imbalance orders
const double AI_MIN_IMBALANCE_THRESHOLD = 0.1; // Minimum imbalance strength (15% imbalance on -1 to +1 scale)

input group "===== CÀI ??T B?O V? TIN T?C ====="
input bool EnableNewsProtection = true;     // B?t/t?t b?o v? tin t?c
input int NewsProtectionMinutes = 30;       // Th?i gian b?o v? tr??c tin (phút)
input int NewsProtectionAfterMinutes = 30;  // Th?i gian b?o v? sau tin (phút)
datetime g_NewsTimes[];
bool g_IsNewsUpdated = false;
datetime g_LastNewsCheck = 0;
// Bi?n global ?? theo dõi tr?ng thái
datetime g_LastNYVolatilityCheck = 0;
bool g_IsNYOpenVolatile = false;


CTrade trade;
bool g_DailyRecoveryOrderOpened = false;
datetime g_LastRecoveryDay = 0;

// Add this new input parameter
input group "===== ADVANCED RECOVERY SETTINGS ====="
input bool EnableResumeTrading = true;          // Allow trading while in recovery
input double ResumeTradeAfterHours = 2;           // Hours to wait before resuming trades

// Add these global variables
bool g_HasResumedTrading = false;               // Flag to track if trading has resumed
datetime g_RecoveryResumeTime = 0;              // Time when trading should resume

// Bỏ input, dùng biến global
ENUM_TIMEFRAMES g_DynamicTimeframe = PERIOD_M15;

// Hàm xác định timeframe từ MFI
ENUM_TIMEFRAMES GetOptimalTimeframe() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M15, 0, 100, rates) < 100) return PERIOD_M15;
    
    double currentPrice = GetCleanPrice();
    
    // Range và volume
    double highest = rates[0].high, lowest = rates[0].low;
    for(int i = 1; i < 100; i++) {
        if(rates[i].high > highest) highest = rates[i].high;
        if(rates[i].low < lowest) lowest = rates[i].low;
    }
    
    double priceRange = (highest - lowest) / _Point;
    double volumeBins[10];
    ArrayInitialize(volumeBins, 0);
    
    for(int i = 0; i < 100; i++) {
        int bin = (int)(((rates[i].close - lowest) / (highest - lowest)) * 9);
        if(bin < 0) bin = 0;
        if(bin > 9) bin = 9;
        volumeBins[bin] += rates[i].tick_volume;
    }
    
    long maxVol = 0, totalVol = 0;
    for(int i = 0; i < 10; i++) {
        totalVol += (long)volumeBins[i];
        if(volumeBins[i] > maxVol) maxVol = (long)volumeBins[i];
    }
    
    double concentration = (double)maxVol / totalVol;
    
    // XAU/USD thresholds
    // Range hẹp <800 + volume tập trung >35% = H1 (consolidation)
    if(priceRange < 800 && concentration > 0.35) return PERIOD_H1;
    
    // Range rất rộng >2500 + volume phân tán <18% = M5 (strong trend)
    if(priceRange > 2500 && concentration < 0.18) return PERIOD_M5;
    
    // Range trung bình 1500-2500 + concentration 20-30% = M15 (normal)
    if(priceRange >= 1500 && priceRange <= 2500 && concentration >= 0.2 && concentration <= 0.3) {
        return PERIOD_M15;
    }
    
    // Default M30
    return PERIOD_M30;
}

// Modified CheckAndActivateRecoveryMode function to reset resume flag

// Update these global variables for faster direction analysis
int g_MarketDirectionUpdateInterval = 5;  // Update direction every 5 seconds
datetime g_LastMarketDirectionReset = 0;  // Track last full reset

// Modified AnalyzeMarketDirection function - faster implementation
int AnalyzeMarketDirection() {
    // Gi?i h?n t?n su?t c?p nh?t ?? gi?m t?i tính toán nh?ng v?n ??m b?o ?áp ?ng
    datetime currentTime = TimeCurrent();
    if(currentTime - g_LastDirectionUpdate < g_DirectionUpdateInterval) {
        return g_MarketDirectionBias; // Tr? v? giá tr? ?ã l?u trong b? nh? cache
    }
    
    // Reset h??ng th? tr??ng ??nh k? ho?c khi có thay ??i ?i?u ki?n th? tr??ng
    bool doFullAnalysis = false;
    
    if(currentTime - g_LastMarketDirectionReset > 3600) { // Phân tích ??y ?? m?i gi?
        doFullAnalysis = true;
        g_LastMarketDirectionReset = currentTime;
    }
    
    int directionBias = 0;
    
    if(doFullAnalysis) {
        // Ph??ng pháp phân tích ??y ?? (logic ban ??u)
        // 1. Phân tích hành ??ng giá trên nhi?u khung th?i gian
        MqlRates ratesM5[], ratesM15[], ratesH1[], ratesH4[], ratesD1[];
        ArraySetAsSeries(ratesM5, true);
        ArraySetAsSeries(ratesM15, true);
        ArraySetAsSeries(ratesH1, true);
        ArraySetAsSeries(ratesH4, true);
        ArraySetAsSeries(ratesD1, true);
        
        if(CopyRates(_Symbol, PERIOD_M5, 0, 10, ratesM5) < 10 ||
           CopyRates(_Symbol, PERIOD_M15, 0, 10, ratesM15) < 10 ||
           CopyRates(_Symbol, PERIOD_H1, 0, 10, ratesH1) < 10 ||
           CopyRates(_Symbol, PERIOD_H4, 0, 6, ratesH4) < 6 ||
           CopyRates(_Symbol, PERIOD_D1, 0, 3, ratesD1) < 3) {
            return g_MarketDirectionBias; // Tr? v? giá tr? ?ã l?u n?u l?y d? li?u th?t b?i
        }
        
        // 2. Tính giá trung tâm làm tham chi?u
        double centerPrice = CalculateCenterPrice();
        double currentPrice = GetCleanPrice();
        
        // 3. Tính momentum giá trên các khung th?i gian v?i m?c ?? quan tr?ng
        double momentumM5 = (ratesM5[0].close - ratesM5[9].close) / _Point;
        double momentumM15 = (ratesM15[0].close - ratesM15[9].close) / _Point;
        double momentumH1 = (ratesH1[0].close - ratesH1[9].close) / _Point;
        double momentumH4 = (ratesH4[0].close - ratesH4[5].close) / _Point;
        double momentumD1 = (ratesD1[0].close - ratesD1[2].close) / _Point;
        
        // Momentum có tr?ng s? (tr?ng s? cao h?n cho khung th?i gian dài h?n)
        double weightedMomentum = (momentumM5 * 0.1) + 
                               (momentumM15 * 0.15) + 
                               (momentumH1 * 0.25) + 
                               (momentumH4 * 0.25) + 
                               (momentumD1 * 0.25);
        
        // 4. Tính các thành ph?n ADX ?? xác ??nh ?? m?nh và h??ng c?a xu h??ng
        double adx = CalculateADX(PERIOD_H1, 14);
        double plusDI = CalculatePlusDI(PERIOD_H1, 14);
        double minusDI = CalculateMinusDI(PERIOD_H1, 14);
        
        // 5. L?y tình tr?ng th? tr??ng hi?n t?i
        MarketConditionType marketCondition = DetermineMarketCondition();
        
        // 6. Tính toán ?óng góp c?a t?ng y?u t? vào ?? l?ch h??ng
        
        // Y?u t? 1: V? trí giá so v?i trung tâm (t?i ?a ±25 ?i?m)
        int centerPriceBias = 0;
        if(currentPrice > centerPrice) {
            centerPriceBias = -25; // Tín hi?u bán ti?m n?ng khi trên trung tâm
        } else if(currentPrice < centerPrice) {
            centerPriceBias = 25;  // Tín hi?u mua ti?m n?ng khi d??i trung tâm
        }
        
        // Y?u t? 2: ?? l?ch d?a trên momentum (t?i ?a ±30 ?i?m)
        int momentumBias = 0;
        if(weightedMomentum > 0) {
            momentumBias = MathMin(30, (int)(weightedMomentum / 10));
        } else {
            momentumBias = MathMax(-30, (int)(weightedMomentum / 10));
        }
        
        // Y?u t? 3: H??ng xu h??ng ADX (t?i ?a ±25 ?i?m)
        int adxBias = 0;
        if(adx > 20) { // Ch? xem xét khi xu h??ng ?? m?nh
            if(plusDI > minusDI) {
                adxBias = (int)MathMin(25, (plusDI - minusDI) * 1.5);
            } else {
                adxBias = (int)MathMax(-25, (minusDI - plusDI) * -1.5);
            }
        }
        
        // Y?u t? 4: Mô hình giá g?n ?ây (t?i ?a ±20 ?i?m)
        int patternBias = 0;
        
        // Ki?m tra mô hình t?ng
        bool bullishEngulfing = ratesH1[1].close < ratesH1[1].open && // N?n gi?m tr??c ?ó
                               ratesH1[0].close > ratesH1[0].open &&  // N?n t?ng hi?n t?i
                               ratesH1[0].close > ratesH1[1].open &&  // ?óng c?a hi?n t?i trên m? c?a tr??c ?ó
                               ratesH1[0].open < ratesH1[1].close;    // M? c?a hi?n t?i d??i ?óng c?a tr??c ?ó
                               
        bool bullishThrust = ratesH1[2].close < ratesH1[2].open && 
                            ratesH1[1].close < ratesH1[1].open &&
                            ratesH1[0].close > ratesH1[0].open &&
                            ratesH1[0].close > ratesH1[1].high;
        
        // Ki?m tra mô hình gi?m
        bool bearishEngulfing = ratesH1[1].close > ratesH1[1].open && // N?n t?ng tr??c ?ó
                               ratesH1[0].close < ratesH1[0].open &&  // N?n gi?m hi?n t?i
                               ratesH1[0].close < ratesH1[1].open &&  // ?óng c?a hi?n t?i d??i m? c?a tr??c ?ó
                               ratesH1[0].open > ratesH1[1].close;    // M? c?a hi?n t?i trên ?óng c?a tr??c ?ó
                               
        bool bearishThrust = ratesH1[2].close > ratesH1[2].open && 
                            ratesH1[1].close > ratesH1[1].open &&
                            ratesH1[0].close < ratesH1[0].open &&
                            ratesH1[0].close < ratesH1[1].low;
        
        if(bullishEngulfing || bullishThrust) {
            patternBias += 20;
        }
        if(bearishEngulfing || bearishThrust) {
            patternBias -= 20;
        }
        
        // K?t h?p t?t c? các y?u t? v?i các ?i?u ch?nh d?a trên tình tr?ng th? tr??ng
        switch(marketCondition) {
            case MARKET_TRENDING:
                // Trong th? tr??ng xu h??ng, ?u tiên ADX và momentum
                directionBias = (int)(centerPriceBias * 0.5 + 
                                   momentumBias * 1.5 + 
                                   adxBias * 1.5 + 
                                   patternBias * 0.5);
                break;
                
            case MARKET_RANGING:
                // Trong th? tr??ng sideway, ?u tiên giá trung tâm và mô hình
                directionBias = (int)(centerPriceBias * 1.5 + 
                                   momentumBias * 0.5 + 
                                   adxBias * 0.5 + 
                                   patternBias * 1.5);
                break;
                
            case MARKET_VOLATILE:
                // Trong th? tr??ng bi?n ??ng, ?u tiên momentum và mô hình
                directionBias = (int)(centerPriceBias * 0.5 + 
                                   momentumBias * 1.5 + 
                                   adxBias * 0.5 + 
                                   patternBias * 1.5);
                break;
                
            default: // MARKET_NORMAL
                // Trong th? tr??ng bình th??ng, tr?ng s? cân b?ng
                directionBias = centerPriceBias + momentumBias + adxBias + patternBias;
                break;
        }
    }
    else {
        // Ph??ng pháp c?p nh?t nhanh (logic m?i cho c?p nh?t nhanh gi?a các phân tích ??y ??)
        // 1. Ki?m tra ??ng l??ng nhanh ch? s? d?ng M5 và M15
        MqlRates ratesM5[], ratesM15[];
        ArraySetAsSeries(ratesM5, true);
        ArraySetAsSeries(ratesM15, true);
        
        if(CopyRates(_Symbol, PERIOD_M5, 0, 5, ratesM5) < 5 ||
           CopyRates(_Symbol, PERIOD_M15, 0, 3, ratesM15) < 3) {
            return g_MarketDirectionBias; // Tr? v? giá tr? ?ã l?u n?u l?y d? li?u th?t b?i
        }
        
        // 2. Tính toán momentum giá g?n ?ây
        double momentumM5 = (ratesM5[0].close - ratesM5[4].close) / _Point;
        double momentumM15 = (ratesM15[0].close - ratesM15[2].close) / _Point;
        
        // 3. L?y giá hi?n t?i so v?i giá trung tâm
        double currentPrice = GetCleanPrice();
        double centerPrice = CalculateCenterPrice();
        int centerFactor = (currentPrice > centerPrice) ? -10 : 10; // ?? l?ch trung tâm ??n gi?n
        
        // 4. Tính toán ?? l?ch h??ng nhanh (công th?c ??n gi?n hóa)
        directionBias = (int)(
            centerFactor +                 // Y?u t? giá trung tâm (±10)
            momentumM5 * 0.1 +             // Momentum M5 v?i tr?ng s? th?p h?n
            momentumM15 * 0.2              // Momentum M15 v?i tr?ng s? cao h?n
        );
        
        // 5. Thêm tr?ng s? t? phép tính tr??c ?ó (làm m?n)
        directionBias = (directionBias + g_MarketDirectionBias * 2) / 3;
    }
    
    // ??m b?o ?? l?ch n?m trong ph?m vi -100 ??n +100
    directionBias = MathMax(-100, MathMin(100, directionBias));
    
    // Ch? ghi log khi có thay ??i ?áng k? - ?ÂY LÀ PH?N QUAN TR?NG C?N S?A
    if(MathAbs(directionBias - g_MarketDirectionBias) > 20 || doFullAnalysis) {
 
    }
    
    // C?p nh?t bi?n toàn c?c
    g_MarketDirectionBias = directionBias;
    g_LastDirectionUpdate = currentTime;
    
    return directionBias;
}

// Helper function to check if trade type is aligned with market direction
bool IsTradeTypeAlignedWithMarket(ENUM_ORDER_TYPE requestedType) {
    int bias = AnalyzeMarketDirection();
    
    if(requestedType == ORDER_TYPE_BUY && bias >= 0) return true;  // Buy with bullish/neutral bias
    if(requestedType == ORDER_TYPE_SELL && bias <= 0) return true; // Sell with bearish/neutral bias
    
    return false; // Not aligned
}

// Modified GetOptimalTradeDirection function
ENUM_ORDER_TYPE GetOptimalTradeDirection(int minConfidenceThreshold = 20) {
    int bias = AnalyzeMarketDirection();
    
    // Return buy/sell only if confidence exceeds threshold
    if(bias >= minConfidenceThreshold) {
        return ORDER_TYPE_BUY;
    } 
    else if(bias <= -minConfidenceThreshold) {
        return ORDER_TYPE_SELL;
    }
    
    // Default to null operation when confidence is low
    return -1; // Invalid order type - signals to take no action
}




// Modified OpenHedgeOrder function to use stop orders
// Add these global variables at the top of your file
datetime g_HedgeStopOrderPlacementTime = 0;
const int HEDGE_STOP_MAX_LIFETIME = 3600; // Maximum lifetime for hedge stop orders (1 hour)

// Modified OpenHedgeOrder function with stop order tracking
bool OpenHedgeOrder(ENUM_ORDER_TYPE orderType, double volume, double currentPrice) {
    // Add recovery mode check and cooldown check
    // Add this at the start of every order opening function:
if(!EnforcePeriodOrderLimits()) {
    return false;
}
g_InHedgeCycle = true;

    datetime currentTime = TimeCurrent();
    if(!EnableHedging || 
       HasExistingHedge() || 
       currentTime - g_LastHedgeOrderTime < HEDGE_COOLDOWN_SECONDS) {
        
        // Log cooldown if that's the reason
        if(currentTime - g_LastHedgeOrderTime < HEDGE_COOLDOWN_SECONDS) {
     
        }
        return false;
    }
    
          // Direct period limit check first
    if(!EnforcePeriodOrderLimits()) {
        return false;
    }

    string comment = StringFormat("Hedge %s Single", orderType == ORDER_TYPE_BUY ? "Buy" : "Sell");
    ENUM_POSITION_TYPE posType = (orderType == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
    
    // Calculate stop price based on order type
    double stopPrice;
    if(orderType == ORDER_TYPE_BUY) {
        // For buy stop orders, set the stop price above current price
        stopPrice = currentPrice + (900 * _Point); // 5 pips above current price
    } else {
        // For sell stop orders, set the stop price below current price
        stopPrice = currentPrice - (900 * _Point); // 5 pips below current price
    }


    // Convert order type to stop order type
    ENUM_ORDER_TYPE stopOrderType = (orderType == ORDER_TYPE_BUY) ? ORDER_TYPE_BUY_STOP : ORDER_TYPE_SELL_STOP;

    // Place stop order instead of market order
    trade.SetExpertMagicNumber(10051990); // Use a special magic number for hedges
    bool result = trade.OrderOpen(
        _Symbol,
        stopOrderType,
        volume,
        0, // Price is filled automatically for market orders
        stopPrice, // Stop price
        0, // No stop loss
        0, // No take profit
        0, // No expiration
        0, // No expiration time
        comment
    );
    
    // Reset magic number
    trade.SetExpertMagicNumber(10051988);
    
    if(result) {
        g_HasActiveHedgeOrder = true;
        g_LastHedgeTime = currentTime;
        g_LastHedgeOrderTime = currentTime; // Set cooldown timer
        g_HedgeStopOrderPlacementTime = currentTime; // Track when the stop order was placed
           g_InHedgeCycle = true;
        g_HasActiveHedgeOrder = true;
        
        if(orderType == ORDER_TYPE_BUY) g_ActiveHedgeBuys++;
        else g_ActiveHedgeSells++;
        
    


    }
    
    return result;
}

// Add new function to check and delete unfilled hedge stop orders
void CheckAndDeleteUnfilledHedgeStops() {
    datetime currentTime = TimeCurrent();
    
    // Only check every 5 minutes to avoid excessive processing
    static datetime lastHedgeStopCheck = 0;
    if(currentTime - lastHedgeStopCheck < 300) return;
    lastHedgeStopCheck = currentTime;
    
    // Skip if no hedge orders were recently placed
    if(g_HedgeStopOrderPlacementTime == 0) return;
    
    // Check if it's been long enough since we placed a hedge stop order
    if(currentTime - g_HedgeStopOrderPlacementTime > HEDGE_STOP_MAX_LIFETIME) {
        bool foundHedgeStop = false;
        
        // Look for pending hedge stop orders
        for(int i = OrdersTotal() - 1; i >= 0; i--) {
            ulong ticket = OrderGetTicket(i);
            if(!OrderSelect(ticket)) continue;
            if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
            
            string comment = OrderGetString(ORDER_COMMENT);
            if(StringFind(comment, "Hedge") >= 0) {
                ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
                
                // Make sure it's a stop order
                if(orderType == ORDER_TYPE_BUY_STOP || orderType == ORDER_TYPE_SELL_STOP) {
               
                    if(trade.OrderDelete(ticket)) {
                    } else {
                    }
                    
                    foundHedgeStop = true;
                }
            }
        }
        
        // Reset tracking if we found and processed hedge stops
        if(foundHedgeStop) {
            g_HedgeStopOrderPlacementTime = 0;
            g_HasActiveHedgeOrder = false; // Reset this flag since we deleted the order
            
            // Reset counters as well
            g_ActiveHedgeBuys = CountActiveHedgePositions(POSITION_TYPE_BUY);
            g_ActiveHedgeSells = CountActiveHedgePositions(POSITION_TYPE_SELL);
            
        } else {
            // If no hedge stops found but the flag is set, it means they've been filled or manually deleted
            // In either case, we should reset the tracker
            g_HedgeStopOrderPlacementTime = 0;
        }
    } else {
    }
}

// Add function to count active hedge positions of a specific type
int CountActiveHedgePositions(ENUM_POSITION_TYPE posType) {
    int count = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) {
            count++;
        }
    }
    
    return count;
}

// Add function to check if market conditions have changed significantly
bool HaveMarketConditionsChangedForHedge() {
    static int lastMarketDirection = 0;
    static double lastMarketVolatility = 0;
    int currentMarketDirection = AnalyzeMarketDirection();
    double currentMarketVolatility = CalculateMarketRange();
    
    // Check for significant changes
    bool directionChanged = (lastMarketDirection * currentMarketDirection < 0) && // Changed sign
                            (MathAbs(currentMarketDirection) > 40); // And is significant
                            
    bool volatilityChanged = (currentMarketVolatility > lastMarketVolatility * 1.5) || // 50% increase
                             (currentMarketVolatility < lastMarketVolatility * 0.5);  // 50% decrease
    
    // Update stored values
    lastMarketDirection = currentMarketDirection;
    lastMarketVolatility = currentMarketVolatility;
    
    return directionChanged || volatilityChanged;
}

// Add another condition to delete hedge stops based on market condition changes
void CheckAndDeleteHedgeStopsOnMarketChange() {
    // Only proceed if we have an active hedge stop order
    if(g_HedgeStopOrderPlacementTime == 0) return;
    
    // Check if market conditions have changed significantly
    if(HaveMarketConditionsChangedForHedge()) {
        
        bool foundHedgeStop = false;
        
        // Look for pending hedge stop orders
        for(int i = OrdersTotal() - 1; i >= 0; i--) {
            ulong ticket = OrderGetTicket(i);
            if(!OrderSelect(ticket)) continue;
            if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
            
            string comment = OrderGetString(ORDER_COMMENT);
            if(StringFind(comment, "Hedge") >= 0) {
                ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
                
                // Make sure it's a stop order
                if(orderType == ORDER_TYPE_BUY_STOP || orderType == ORDER_TYPE_SELL_STOP) {
                    
                    if(trade.OrderDelete(ticket)) {
                    } else {
                    }
                    
                    foundHedgeStop = true;
                }
            }
        }
        
        // Reset tracking if we found and processed hedge stops
        if(foundHedgeStop) {
            g_HedgeStopOrderPlacementTime = 0;
            g_HasActiveHedgeOrder = false; // Reset this flag since we deleted the order
            
            // Reset counters as well
            g_ActiveHedgeBuys = CountActiveHedgePositions(POSITION_TYPE_BUY);
            g_ActiveHedgeSells = CountActiveHedgePositions(POSITION_TYPE_SELL);
            
        }
    }
}

void HandleHedgeDCA(double currentPrice) {
    // Skip if no hedge orders exist
    if(!HasExistingHedge()) return;
    
    // Get information about existing hedge orders
    ENUM_POSITION_TYPE hedgeType;
    double hedgePrice;
    if(!GetLatestHedgeInfo(hedgeType, hedgePrice)) return;
    
    // Determine order type for DCA
    ENUM_ORDER_TYPE orderType = (hedgeType == POSITION_TYPE_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
    
    // Count existing hedge orders
    int hedgeCount = CountHedgeOrders(hedgeType);
    
    // Skip if maximum hedge orders reached
    if(hedgeCount >= MaxOrders) return;
    
    // Calculate required distance
    double lastPrice = GetLatestHedgeOrderPrice(hedgeType);
    if(lastPrice == 0) return;
    
    double requiredDistance = GetSafeHedgeDCADistance();
    double currentDistance = MathAbs(currentPrice - lastPrice) / _Point;
    
    // Direction check
    bool validDirection = false;
    if(hedgeType == POSITION_TYPE_BUY && currentPrice < lastPrice) validDirection = true;
    if(hedgeType == POSITION_TYPE_SELL && currentPrice > lastPrice) validDirection = true;
    

    
    // Open DCA hedge if conditions are met
    if(currentDistance >= requiredDistance && validDirection) {
        // CHANGE HERE: Use GetNextLotSize instead of CalculateTrendLotSize
        double volume = GetNextLotSize(hedgeType);
        OpenHedgeDCAOrder(orderType, volume, currentPrice);

    }
}

// Improved HasExistingHedge function to check both positions and pending orders
bool HasExistingHedge() {
    // First check active positions
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) {
            return true;
        }
    }
    
    // Then check pending orders
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) {
            return true;
        }
    }
    
    return false;
}
// Fixed ManageRecoveryDCA to use exact input distances
void ApplyWeekendProtectionToRecovery() {
    if(!g_InRecoveryMode || !IsWeekendProtectionForRecovery()) return;
    
    static datetime lastProtectCheck = 0;
    datetime currentTime = TimeCurrent();
    if(currentTime - lastProtectCheck < 300) return;
    lastProtectCheck = currentTime;
    
    // Ki?m tra n?u có l?nh recovery
    int recoveryCount = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
            recoveryCount++;
        }
    }
    
    if(recoveryCount > 0) {
     // Tùy ch?n: ?i?u ch?nh TP v? m?c an toàn h?n cho cu?i tu?n
        // AdjustRecoveryTPForWeekend();
    }
    
    g_RecoveryDCAEnabled = false; // T?t t?m th?i DCA cho recovery
    lastProtectCheck = currentTime;
}
void ManageRecoveryDCA() {
    if(!g_InRecoveryMode || !g_RecoveryDCAEnabled) return;
    
    // Ki?m tra gi?i h?n chu k?
    if(!EnforcePeriodOrderLimits()) {
        return;
    }
    
    static datetime lastCheck = 0;
    datetime currentTime = TimeCurrent();
    if(currentTime - lastCheck < 300) return;
    lastCheck = currentTime;
    
    // ??M CHÍNH XÁC S? L?NH TRONG CHU K? RECOVERY HI?N T?I
    int currentCycleOrderCount = 0;
    double latestPrice = 0;
    ENUM_POSITION_TYPE posType = POSITION_TYPE_BUY;  // M?c ??nh
    datetime latestTime = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        // Ki?m tra c? th? l?nh thu?c chu k? hi?n t?i
        if(StringFind(comment, "Recovery") >= 0 && 
           StringFind(comment, "Cycle " + IntegerToString(g_CurrentRecoveryCycleId)) >= 0) {
            
            currentCycleOrderCount++;
            
            // Theo dõi l?nh recovery m?i nh?t
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            if(openTime > latestTime) {
                latestTime = openTime;
                latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            }
        }
    }
    
    // KI?M TRA QUAN TR?NG: Gi?i h?n s? l?nh DCA recovery
    if(currentCycleOrderCount >= MaxRecoveryDCAOrders) {
     
        return;
    }
    
    // N?u không tìm th?y l?nh recovery ho?c không có giá m?i nh?t
    if(currentCycleOrderCount == 0 || latestPrice == 0) return;
    
    double currentPrice = GetCleanPrice();
    
    // Tính toán kho?ng cách d?a trên s? th? t? l?nh trong chu k? HI?N T?I
    double requiredDistance = GetExactDCADistance(currentCycleOrderCount + 1);
    double currentDistance = MathAbs(currentPrice - latestPrice) / _Point;
    

    
    bool validDirection = false;
    if(posType == POSITION_TYPE_BUY && currentPrice < latestPrice) validDirection = true;
    if(posType == POSITION_TYPE_SELL && currentPrice > latestPrice) validDirection = true;
    
    if(currentDistance >= requiredDistance && validDirection) {
        if(CheckMinimumDistanceBetweenOrders(currentPrice, posType)) {
            ENUM_ORDER_TYPE orderType = (posType == POSITION_TYPE_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
            double volume = CalculateRecoveryDCAVolume(currentCycleOrderCount);
            
            OpenRecoveryDCAOrder(orderType, volume, currentPrice);
        }
    }
}
// Modified HandleHedging to use market range
void HandleHedging(double currentPrice) {
    if(!EnableHedging || HasExistingHedge()) return;
    
    // Calculate total positions and drawdown for each direction
    double buyTotalValue = 0, sellTotalValue = 0;
    double buyTotalDrawdown = 0, sellTotalDrawdown = 0;
    int buyCount = 0, sellCount = 0;
    
    // Analyze existing positions (skip hedges)
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) continue; // Skip hedge positions
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double volume = PositionGetDouble(POSITION_VOLUME);
        double profit = PositionGetDouble(POSITION_PROFIT);
        
        if(posType == POSITION_TYPE_BUY) {
            buyCount++;
            buyTotalValue += openPrice * volume;
            buyTotalDrawdown -= profit; // Convert profit to drawdown (negative profit = positive drawdown)
        } else {
            sellCount++;
            sellTotalValue += openPrice * volume;
            sellTotalDrawdown -= profit; // Convert profit to drawdown
        }
    }
    
    // Get current market range
    double marketRange = CalculateMarketRange();
    double rangeFactor = marketRange / g_CurrentAIThreshold;
    
    // Adjust threshold based on market range
    double adjustedBuyThreshold = HedgingThreshold * (rangeFactor >= 1.0 ? rangeFactor : 1.0);
    double adjustedSellThreshold = HedgingThreshold * (rangeFactor >= 1.0 ? rangeFactor : 1.0);

    
    // Open hedge orders when drawdown exceeds adjusted threshold
    if(buyTotalDrawdown >= adjustedBuyThreshold && sellCount < 3) {
        // Buy drawdown exceeds threshold - open sell hedge
        OpenHedgeOrder(ORDER_TYPE_SELL, defaultFixLength, currentPrice);
        g_InHedgeCycle = true;
    }
    else if(sellTotalDrawdown >= adjustedSellThreshold && buyCount <3) {
        // Sell drawdown exceeds threshold - open buy hedge
        OpenHedgeOrder(ORDER_TYPE_BUY, defaultFixLength, currentPrice);
        g_InHedgeCycle = true;
    }
}// Hàm c?p nh?t TP g?p cho t?t c? lo?i l?nh khi ?? s? l??ng
// Hàm ki?m tra l?i nhu?n ??t m?c tiêu hàng ngày và ?óng t?t c? các l?nh
bool CheckAndCloseOnDailyProfitTarget() {
    // B? qua n?u không b?t tính n?ng ho?c ?ã ??t m?c tiêu
    if(!EnableDailyProfitLimit || g_DailyTargetHit) return false;
    
    // Tính toán l?i nhu?n hi?n t?i
    g_DailyProfit = CalculateDailyProfit();
    
    // Ki?m tra xem ?ã ??t m?c tiêu ch?a
    if(g_DailyProfit >= DailyProfitTarget) {
   
        
        // ?óng T?T C? các l?nh, bao g?m c? l?nh Zone
        int closedCount = 0;
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            
            // Ghi log ??c bi?t cho l?nh Zone ?? d? theo dõi
            if(StringFind(comment, "Zone") >= 0) {
            }
            
            if(trade.PositionClose(ticket)) {
                closedCount++;
            } else {
            }
        }
        
        
        // C?p nh?t c? ?? ng?n m? l?nh m?i
        g_DailyTargetHit = true;
        
        // H?y t?t c? các l?nh ch?
        for(int i = OrdersTotal() - 1; i >= 0; i--) {
            ulong ticket = OrderGetTicket(i);
            if(!OrderSelect(ticket)) continue;
            if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
            
            trade.OrderDelete(ticket);
        }
        
    }
    
    return false; // Ch?a ??t m?c tiêu
}
// Add this helper function to check if any zone orders exist
bool HasAnyZoneOrders() {
    // Check for active zone positions
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            return true;
        }
    }
    
    // Check for pending zone orders
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            return true;
        }
    }
    
    return false;
}
// Modified HandleHedging function with strict entry conditions
// Recovery DCA variables
bool g_RecoveryDCAEnabled = false;        // Whether recovery DCA is enabled
int g_RecoveryOrderCount = 0;             // Count of recovery orders placed
double g_RecoveryTotalVolume = 0;         // Total volume of recovery orders
double g_RecoveryAveragePrice = 0;        // Average price of recovery orders
double g_LastMarketVolatility = 0;        // Last measured market volatility
datetime g_LastVolatilityCheck = 0;       // Time of last volatility check
bool g_VolatilityDecreasing = false;      // Flag for decreasing volatility
// Modified to handle and close hedge stop orders properly




// Modified section in OnTick function to remove hedge DCA
// Replace this section in your OnTick function:

// Modified HandleBuyDCA function with market direction logic
// =============================================================================
// FIX CÁC LỖI TRONG EA
// =============================================================================

// LỖI 1: GetStandardDCADistance trả về 0 cho zone DCA
// FIX: Thay đổi logic để đảm bảo luôn có khoảng cách tối thiểu


// LỖI 2: HandleZoneBuyDCA thiếu kiểm tra khoảng cách thực tế
double GetStandardDCADistance(int orderNumber, bool isBreakout = false) {
    double baseDistance;
    
    switch(orderNumber) {
        case 1: baseDistance = FirstOrderGap; break;
        case 2: baseDistance = SecondOrderGap; break;
        case 3: baseDistance = ThirdOrderGap; break;
        case 4: baseDistance = FourthOrderGap; break;
        case 5: baseDistance = FifthOrderGap; break;
        case 6: baseDistance = SixthOrderGap; break;
        case 7: baseDistance = SeventhOrderGap; break;
        case 8: baseDistance = EighthOrderGap; break;
        case 9: baseDistance = NinthOrderGap; break;
        case 10: baseDistance = TenthOrderGap; break;
        case 11: baseDistance = EleventhOrderGap; break;
        case 12: baseDistance = TwelfthOrderGap; break;
        case 13: baseDistance = ThirteenthOrderGap; break;
        case 14: baseDistance = FourteenthOrderGap; break;
        case 15: baseDistance = FifteenthOrderGap; break;
        case 16: baseDistance = SixteenthOrderGap; break;
        default: baseDistance = DCADistance; break;
    }
    
    if(baseDistance <= 0) {
        baseDistance = DCADistance > 0 ? DCADistance : 20;
    }
    
    // BREAKOUT MODE - Scale theo box range
    if(isBreakout && g_BoxHigh > 0 && g_BoxLow > 0) {
        double boxRange = (g_BoxHigh - g_BoxLow) / _Point;
        double multiplier = 1.0;
        
        if(boxRange >= 50000) {
            multiplier = 3.0;  // Box rất lớn
        } else if(boxRange >= 90000) {
            multiplier = 2.5;  // Box lớn
        } else if(boxRange >= 70000) {
            multiplier = 2.0;  // Box trung bình
        } else if(boxRange >= 40000) {
            multiplier = 1.5;  // Box nhỏ
        }
        
        baseDistance *= multiplier;
     
    }
    
    return baseDistance;
}
// FIX: THIẾU CẬP NHẬT TP GỘP KTRONG ZONE DCA

// Thêm hàm phân tích volume profile
bool IsHighVolumeZone(double price, ENUM_POSITION_TYPE posType) {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    
    if(CopyRates(_Symbol, PERIOD_M15, 0, 50, rates) < 50) return false;
    
    // Tính average volume
    long totalVolume = 0;
    for(int i = 0; i < 50; i++) {
        totalVolume += rates[i].tick_volume;
    }
    double avgVolume = (double)totalVolume / 50;
    
    // Check volume gần price hiện tại
    int highVolumeCount = 0;
    for(int i = 0; i < 20; i++) {
        double priceRange = MathAbs(price - rates[i].close) / _Point;
        
        if(priceRange < 100) { // Trong vùng 100 points
            if(rates[i].tick_volume > avgVolume * 1.5) {
                highVolumeCount++;
            }
        }
    }
    
    return (highVolumeCount >= 3); // 3+ bars volume cao = vùng biến động mạnh
}

void HandleZoneBuyDCA(double currentPrice) {
    // AI-Based DCA Block Check for BUY
    if(g_AI_BlockDCA_Buy) {

        return;
    }

    int zoneBuyCount = 0;
    double lastZoneBuyPrice = 0;
    datetime lastZoneBuyTime = 0;

    // Count zone buy orders
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_BUY) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            zoneBuyCount++;
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            
            if(openTime > lastZoneBuyTime) {
                lastZoneBuyTime = openTime;
                lastZoneBuyPrice = openPrice;
            }
        }
    }
    
    
    if(zoneBuyCount == 0 || zoneBuyCount >= MaxZoneDCAOrders) return;
    
    // Chỉ check distance - đơn giản
    if(lastZoneBuyPrice > 0 && currentPrice < lastZoneBuyPrice) {
        double distance = (lastZoneBuyPrice - currentPrice) / _Point;
        double requiredDistance = GetStandardDCADistance(zoneBuyCount + 1, false); // false = không scale theo box
        
        
        if(distance >= requiredDistance) {
            double lotSize = CalculateZoneDCALotSize(zoneBuyCount + 1);
            string comment = StringFormat("Zone Buy DCA #%d", zoneBuyCount + 1);

            if(trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, currentPrice, 0, 0, comment)) {
                UpdatePeriodOrderCount();
                
                int newZoneBuyCount = zoneBuyCount + 1;
                if(newZoneBuyCount >= CombinedTPLevel) {
                    // UpdateCombinedTP(POSITION_TYPE_BUY, false);
                }
            }
        }
    }
}

void HandleZoneSellDCA(double currentPrice) {
    // AI-Based DCA Block Check for SELL
    if(g_AI_BlockDCA_Sell) {

        return;
    }

    int zoneSellCount = 0;
    double lastZoneSellPrice = 0;
    datetime lastZoneSellTime = 0;

    // Count zone sell orders
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_SELL) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            zoneSellCount++;
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            
            if(openTime > lastZoneSellTime) {
                lastZoneSellTime = openTime;
                lastZoneSellPrice = openPrice;
            }
        }
    }
    
    
    if(zoneSellCount == 0 || zoneSellCount >= MaxZoneDCAOrders) return;
    
    // Chỉ check distance - đơn giản
    if(lastZoneSellPrice > 0 && currentPrice > lastZoneSellPrice) {
        double distance = (currentPrice - lastZoneSellPrice) / _Point;
        double requiredDistance = GetStandardDCADistance(zoneSellCount + 1, false);
        
        
        if(distance >= requiredDistance) { // FIX: >= thay vì 
            double lotSize = CalculateZoneDCALotSize(zoneSellCount + 1);
            string comment = StringFormat("Zone Sell DCA #%d", zoneSellCount + 1);

            if(trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, currentPrice, 0, 0, comment)) {
                UpdatePeriodOrderCount();
                
                int newZoneSellCount = zoneSellCount + 1;
                if(newZoneSellCount >= CombinedTPLevel) {
                    // UpdateCombinedTP(POSITION_TYPE_SELL, false);
                }
            }
        }
    }
}

// Thêm globals
enum AllowedDirection {
    DIR_BOTH,
    DIR_BUY_ONLY,
    DIR_SELL_ONLY
};
AllowedDirection g_AllowedDirection = DIR_BOTH;

// Hàm xác định direction từ MFI
AllowedDirection GetMFIDirection() {
    if(CopyBuffer(g_MFI_Handle, 0, 0, 3, g_MFI_Buffer) < 3) return DIR_BOTH;
    
    double mfi = g_MFI_Buffer[0];
    double mfi_prev = g_MFI_Buffer[1];
    double mfi_prev2 = g_MFI_Buffer[2];
    
    // Trend confirmation: 2 bars liên tiếp
    bool mfiRising = (mfi > mfi_prev && mfi_prev > mfi_prev2);
    bool mfiFalling = (mfi < mfi_prev && mfi_prev < mfi_prev2);
    
    if(mfi < 40 && mfiRising) return DIR_BUY_ONLY;
    if(mfi > 60 && mfiFalling) return DIR_SELL_ONLY;
    
    // Neutral zone 40-60
    return DIR_BOTH;
}
// Sửa hàm CalculateOrderTP để sử dụng đúng input TP parameters


// LỖI 5: CheckMinimumDistanceBetweenOrders có thể cho phép mở lệnh quá gần
// FIX: Tăng cường kiểm tra khoảng cách
bool CheckMinimumDistanceBetweenOrders(double currentPrice, ENUM_POSITION_TYPE posType, double customMinDistance = 0) {
    double minDistance = (customMinDistance > 0) ? customMinDistance : MinimumOrderDistance;
    
    // FIX: Đảm bảo khoảng cách tối thiểu
    if(minDistance <= 0) {
        minDistance = 5.0; // Tối thiểu 5 points
    }
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        double orderPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double distance = MathAbs(currentPrice - orderPrice) / _Point;
        
        if(distance < minDistance) {
            return false;
        }
    }
    
    return true;
}


void UpdateAnchorPrice() {
    static datetime lastUpdate = 0;
    datetime currentTime = TimeCurrent();
    
    if(currentTime - lastUpdate < 300) return;
    
    double currentPrice = GetCleanPrice();
    
    if(g_AnchorPrice <= 0) {
        g_AnchorPrice = currentPrice;
        g_LastAnchorPrice = currentPrice;
        lastUpdate = currentTime;
        return;
    }
    
    double priceChange = MathAbs(currentPrice - g_AnchorPrice) / _Point;
    double threshold = GetPeriodFirstEntryDistance() * 3;
    
    if(priceChange >= threshold) {
        // Check MFI confirmation
        if(CopyBuffer(g_MFI_Handle, 0, 0, 3, g_MFI_Buffer) >= 3) {
            double mfi = g_MFI_Buffer[0];
            double mfi_prev = g_MFI_Buffer[1];
            
            bool shouldUpdate = false;
            
            if(currentPrice > g_AnchorPrice) {
                // Giá tăng - yêu cầu MFI > 50 và rising
                shouldUpdate = (mfi > 50 && mfi > mfi_prev);
            } else {
                // Giá giảm - yêu cầu MFI < 50 và falling
                shouldUpdate = (mfi < 50 && mfi < mfi_prev);
            }
            
            if(shouldUpdate) {
                double oldAnchor = g_AnchorPrice;
                
                if(currentPrice > g_AnchorPrice) {
                    g_AnchorPrice = currentPrice - (GetPeriodFirstEntryDistance() * _Point);
                } else {
                    g_AnchorPrice = currentPrice + (GetPeriodFirstEntryDistance() * _Point);
                }
                
                g_LastAnchorPrice = oldAnchor;
            }
        }
    }
    
    lastUpdate = currentTime;
}
//+------------------------------------------------------------------+
//| S?A LOGIC S? D?NG ?ÚNG INPUT TÂM GIÁ                            |
//+------------------------------------------------------------------+

// 1. HÀM GetPeriodFirstEntryDistance() - S? D?NG ?ÚNG INPUT
double GetPeriodFirstEntryDistance() {
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    int currentHour = time_struct.hour;
    
    double distance;
    string periodName;
    
    if(currentHour >= Period1StartHour && currentHour < Period1EndHour) {
        distance = Period1FirstEntryDistance;
        periodName = "Period 1";
    }
    else if(currentHour >= Period2StartHour && currentHour < Period2EndHour) {
        distance = Period2FirstEntryDistance;
        periodName = "Period 2";
    }
    else if(currentHour >= Period3StartHour && currentHour < Period3EndHour) {
        distance = Period3FirstEntryDistance;
        periodName = "Period 3";
    }
    else {
        distance = OutsideHoursFirstEntryDistance;
        periodName = "Outside Hours";
    }
    
    return distance;
}

// 2. HÀM CalculateCenterPrice() - S? D?NG ANCHOR PRICE





// 8. HÀM DEBUG INPUT SETTINGS
void DebugInputSettings() {
    double currentPrice = GetCleanPrice();
    double centerPrice = CalculateCenterPrice();
    double entryDistance = GetPeriodFirstEntryDistance();
    double actualDistance = MathAbs(currentPrice - centerPrice) / _Point;
    
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
   
}

// THÊM VÀO OnTick() ?? DEBUG:
// if(TimeCurrent() % 30 == 0) DebugInputSettings();
// 7. HÀM DEBUG TOÀN DI?N
void DebugCenterPriceSystem() {
    double currentPrice = GetCleanPrice();
    double centerPrice = CalculateCenterPrice();
    double periodDistance = GetPeriodFirstEntryDistance();
    double priceFromCenter = MathAbs(currentPrice - centerPrice) / _Point;

}

// HÀM DEBUG TÂM GIÁ
void DebugCenterPriceLogic() {
    double currentPrice = GetCleanPrice();
    double centerPrice = CalculateCenterPrice();
    double anchorPrice = g_AnchorPrice;
    double periodDistance = GetPeriodFirstEntryDistance();
 
}
// Add new global variables for cycle type tracking
bool g_HasActiveBuyCycle = false;
bool g_HasActiveSellCycle = false;

// Add these global variables at the top with other globals
bool g_HasPositionsFromPreviousDay = false;
datetime g_LastDayCheck = 0;

// New function to check if we have positions from previous day
void CheckForOvernightPositions() {
    datetime currentTime = TimeCurrent();
    MqlDateTime current_struct;
    TimeToStruct(currentTime, current_struct);
    
    // Check if we've entered a new day
    if(g_LastDayCheck != 0) {
        MqlDateTime prev_struct;
        TimeToStruct(g_LastDayCheck, prev_struct);
        
        if(current_struct.day != prev_struct.day) {
            // New day has started - check for existing positions from previous day
            g_HasPositionsFromPreviousDay = false;
            for(int i = PositionsTotal() - 1; i >= 0; i--) {
                ulong ticket = PositionGetTicket(i);
                if(!PositionSelectByTicket(ticket)) continue;
                if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                
                // Position exists at the start of the new day, so it's from previous day
                g_HasPositionsFromPreviousDay = true;
                break;
            }
            
            // Update day open price
            MqlRates rates[];
            ArraySetAsSeries(rates, true);
            if(CopyRates(_Symbol, PERIOD_D1, 0, 1, rates) == 1) {
                g_DayOpenPrice = rates[0].open;
            }
            
            if(g_HasPositionsFromPreviousDay) {
            }
        }
    }
    
    g_LastDayCheck = currentTime;
}

// Modified CanStartNewCycle function with overnight position check
bool CanStartNewCycle(double currentPrice, ENUM_ORDER_TYPE orderType) {
    if(!g_WaitingForNewEntry) return true;
 if(!CheckAndUpdateDrawdownStatus()) {
        return false;
    }
    // Check if trying to start same type as existing cycle
    if(orderType == ORDER_TYPE_BUY && g_HasActiveSellCycle) return true;
    if(orderType == ORDER_TYPE_SELL && g_HasActiveBuyCycle) return true;
    
    // Don't allow same type cycles
    if(orderType == ORDER_TYPE_BUY && g_HasActiveBuyCycle) {
        return false;
    }
    if(orderType == ORDER_TYPE_SELL && g_HasActiveSellCycle) {
        return false;
    }
    
    // Check for active Zone cycles
    if(g_ActivatedBuyCount > 0 || g_ActivatedSellCount > 0) {
     
        return false;
    }
    
    // NEW ADDITION: Check for overnight positions rule
    if(g_HasPositionsFromPreviousDay && g_DayOpenPrice > 0) {
        double distanceFromDayOpen = MathAbs(currentPrice - g_DayOpenPrice) / _Point;
        if(distanceFromDayOpen < 300) {
           
            return false;
        }
    }
    
    datetime currentTime = TimeCurrent();
    
    // Standard time and distance checks
    if(currentTime - g_LastCycleCompleteTime < g_MinWaitAfterCycle) {
        return false;
    }
    
    double marketRange = CalculateMarketRange();
    double requiredDistance = GetPeriodFirstEntryDistance();
    double priceMovement = MathAbs(currentPrice - g_LastCycleCompletePrice) / _Point;
    
    bool timeOK = (currentTime - g_LastCycleCompleteTime >= g_MinWaitAfterCycle);
    bool distanceOK = (priceMovement >= requiredDistance);

    if(timeOK && distanceOK) {
        g_WaitingForNewEntry = false;
      
        return true;
    }
    
    return false;
}



// Helper function to get current DCA gap based on order number
double GetBaseDCADistance(int orderNumber) {
    switch(orderNumber) {
        case 1: return g_CurrentFirstOrderGap;
        case 2: return g_CurrentSecondOrderGap;
        case 3: return g_CurrentThirdOrderGap;
        case 4: return g_CurrentFourthOrderGap;
        case 5: return g_CurrentFifthOrderGap;
        case 6: return SixthOrderGap;
        case 7: return SeventhOrderGap;
        case 8: return EighthOrderGap;
        case 9: return NinthOrderGap;
        case 10: return TenthOrderGap;
        case 11: return EleventhOrderGap;
        case 12: return TwelfthOrderGap;
        case 13: return ThirteenthOrderGap;
        case 14: return FourteenthOrderGap;
        case 15: return FifteenthOrderGap;
        case 16: return SixteenthOrderGap;
        default: return DCADistance;
    }
}

// Add initialization for cycle tracking
void InitializeDynamicGaps() {
    g_CurrentFirstOrderGap = FirstOrderGap;
    g_CurrentSecondOrderGap = SecondOrderGap;
    g_CurrentThirdOrderGap = ThirdOrderGap;
    g_CurrentFourthOrderGap = FourthOrderGap;
    g_CurrentFifthOrderGap = FifthOrderGap;
    g_CompletedCycles = 0;
    g_LastCycleCompletionTime = 0;
    

}

// Add this function to check if a cycle is complete
// Add these global variables at the top
double g_LastCycleCompletePrice = 0;
datetime g_LastCycleCompleteTime = 0;
bool g_WaitingForNewEntry = false;
int g_MinWaitAfterCycle = 9; // 5 minutes minimum wait after cycle completion

// Modified IsCycleComplete function
bool IsCycleComplete(double totalProfit) {
    if(totalProfit > 0) {
        g_LastCycleCompletePrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        g_LastCycleCompleteTime = TimeCurrent();
        g_WaitingForNewEntry = true;
        

              
        return true;
    }
    return false;
}


// Add new global variables for cycle tracking
struct CycleStatus {
    int cycleId;
    bool hadTPHit;
    datetime lastTPTime;
    double averagePrice;
    int orderCount;
    double totalVolume;
};

CycleStatus g_BuyCycleStatus[];  // Global arrays
CycleStatus g_SellCycleStatus[];

int GetPriorityCycle(ENUM_POSITION_TYPE posType) {
    int arraySize = (posType == POSITION_TYPE_BUY) ? 
                   ArraySize(g_BuyCycleStatus) : ArraySize(g_SellCycleStatus);
    
    if(arraySize == 0) return -1;
    if(arraySize == 1) {
        if(posType == POSITION_TYPE_BUY) {
            return g_BuyCycleStatus[0].cycleId;
        } else {
            return g_SellCycleStatus[0].cycleId;
        }
    }
    
    // Find cycle without TP hit
    for(int i = 0; i < arraySize; i++) {
        if(posType == POSITION_TYPE_BUY) {
            if(!g_BuyCycleStatus[i].hadTPHit) {
                return g_BuyCycleStatus[i].cycleId;
            }
        } else {
            if(!g_SellCycleStatus[i].hadTPHit) {
                return g_SellCycleStatus[i].cycleId;
            }
        }
    }
    
    // If all cycles had TP hits, return most recent cycle
    int mostRecentCycle;
    datetime mostRecentTime;
    
    if(posType == POSITION_TYPE_BUY) {
        mostRecentCycle = g_BuyCycleStatus[0].cycleId;
        mostRecentTime = g_BuyCycleStatus[0].lastTPTime;
        
        for(int i = 1; i < arraySize; i++) {
            if(g_BuyCycleStatus[i].lastTPTime > mostRecentTime) {
                mostRecentTime = g_BuyCycleStatus[i].lastTPTime;
                mostRecentCycle = g_BuyCycleStatus[i].cycleId;
            }
        }
    } else {
        mostRecentCycle = g_SellCycleStatus[0].cycleId;
        mostRecentTime = g_SellCycleStatus[0].lastTPTime;
        
        for(int i = 1; i < arraySize; i++) {
            if(g_SellCycleStatus[i].lastTPTime > mostRecentTime) {
                mostRecentTime = g_SellCycleStatus[i].lastTPTime;
                mostRecentCycle = g_SellCycleStatus[i].cycleId;
            }
        }
    }
    
    return mostRecentCycle;
}


// Helper function to find cycle index in array
int FindCycleIndex(int cycleId, ENUM_POSITION_TYPE posType) {
    if(posType == POSITION_TYPE_BUY) {
        for(int i = 0; i < ArraySize(g_BuyCycleStatus); i++) {
            if(g_BuyCycleStatus[i].cycleId == cycleId) return i;
        }
    } else {
        for(int i = 0; i < ArraySize(g_SellCycleStatus); i++) {
            if(g_SellCycleStatus[i].cycleId == cycleId) return i;
        }
    }
    return -1;
}
bool CheckAnyTPReached(double currentPrice, ENUM_POSITION_TYPE posType) {
    bool anyTPReached = false;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        
        // Skip hedge positions - they're handled by ManageHedgeCycles
        if(StringFind(comment, "Hedge") >= 0) continue;
        
        double tp = PositionGetDouble(POSITION_TP);
        if((posType == POSITION_TYPE_BUY && currentPrice >= tp) ||
           (posType == POSITION_TYPE_SELL && currentPrice <= tp)) {
            anyTPReached = true;
        }
    }
    
    return anyTPReached;
}
// Helper function to initialize cycle status
void InitializeCycleStatus(int cycleId, ENUM_POSITION_TYPE posType, int index) {
    if(posType == POSITION_TYPE_BUY) {
        g_BuyCycleStatus[index].cycleId = cycleId;
        g_BuyCycleStatus[index].hadTPHit = false;
        g_BuyCycleStatus[index].lastTPTime = 0;
        g_BuyCycleStatus[index].averagePrice = 0;
        g_BuyCycleStatus[index].orderCount = 0;
        g_BuyCycleStatus[index].totalVolume = 0;
    } else {
        g_SellCycleStatus[index].cycleId = cycleId;
        g_SellCycleStatus[index].hadTPHit = false;
        g_SellCycleStatus[index].lastTPTime = 0;
        g_SellCycleStatus[index].averagePrice = 0;
        g_SellCycleStatus[index].orderCount = 0;
        g_SellCycleStatus[index].totalVolume = 0;
    }
}

// Helper function to update cycle statistics
void UpdateCycleStats(ulong ticket, ENUM_POSITION_TYPE posType, int cycleIndex) {
    if(!PositionSelectByTicket(ticket)) return;
    
    double volume = PositionGetDouble(POSITION_VOLUME);
    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    
    if(posType == POSITION_TYPE_BUY) {
        g_BuyCycleStatus[cycleIndex].orderCount++;
        g_BuyCycleStatus[cycleIndex].totalVolume += volume;
        g_BuyCycleStatus[cycleIndex].averagePrice = 
            (g_BuyCycleStatus[cycleIndex].averagePrice * 
             (g_BuyCycleStatus[cycleIndex].totalVolume - volume) + 
             openPrice * volume) / g_BuyCycleStatus[cycleIndex].totalVolume;
    } else {
        g_SellCycleStatus[cycleIndex].orderCount++;
        g_SellCycleStatus[cycleIndex].totalVolume += volume;
        g_SellCycleStatus[cycleIndex].averagePrice = 
            (g_SellCycleStatus[cycleIndex].averagePrice * 
             (g_SellCycleStatus[cycleIndex].totalVolume - volume) + 
             openPrice * volume) / g_SellCycleStatus[cycleIndex].totalVolume;
    }
}

void UpdateCycleStatus(ENUM_POSITION_TYPE posType) {
    // Clear existing arrays
    if(posType == POSITION_TYPE_BUY) {
        ArrayResize(g_BuyCycleStatus, 0);
    } else {
        ArrayResize(g_SellCycleStatus, 0);
    }
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        int cycleId = ExtractCycleId(comment);
        
        // Find or create cycle status
        int cycleIndex = FindCycleIndex(cycleId, posType);
        if(cycleIndex < 0) {
            if(posType == POSITION_TYPE_BUY) {
                cycleIndex = ArraySize(g_BuyCycleStatus);
                ArrayResize(g_BuyCycleStatus, cycleIndex + 1);
            } else {
                cycleIndex = ArraySize(g_SellCycleStatus);
                ArrayResize(g_SellCycleStatus, cycleIndex + 1);
            }
            InitializeCycleStatus(cycleId, posType, cycleIndex);
        }
        UpdateCycleStats(ticket, posType, cycleIndex);
    }
}


int ExtractCycleId(string comment) {
    int startPos = StringFind(comment, " ") + 1;
    int endPos = StringFind(comment, " ", startPos);
    if(startPos < 0 || endPos < 0) return 1;
    
    string cycleStr = StringSubstr(comment, startPos, endPos - startPos);
    return (int)StringToInteger(cycleStr);
}

int GetCycleOrderCount(ENUM_POSITION_TYPE posType, int cycleId) {
    int count = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(ExtractCycleId(comment) == cycleId) count++;
    }
    
    return count;
}

// Add this with other global variables
datetime g_LastM1CandleTime = 0;  // Track last M1 candle time
void CreateControlPanel() {
   int left = 20;
   int top = 20;
   int width = 150;
   int height = 200;
   
   // Create main window with border
   ObjectCreate(CHART_ID, EA_WINDOW, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(CHART_ID, EA_WINDOW, OBJPROP_XDISTANCE, left);
   ObjectSetInteger(CHART_ID, EA_WINDOW, OBJPROP_YDISTANCE, top);
   ObjectSetInteger(CHART_ID, EA_WINDOW, OBJPROP_XSIZE, width);
   ObjectSetInteger(CHART_ID, EA_WINDOW, OBJPROP_YSIZE, height);
   ObjectSetInteger(CHART_ID, EA_WINDOW, OBJPROP_BGCOLOR, C'240,240,240');
   ObjectSetInteger(CHART_ID, EA_WINDOW, OBJPROP_BORDER_TYPE, BORDER_RAISED);
   ObjectSetInteger(CHART_ID, EA_WINDOW, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   
   // Add title
   CreateLabel("TITLE", "Merlin V1", left + 45, top + 5);
   
   // Create checkboxes with better spacing
   CreateEditBox(EDIT_START_BUY, " K? lu?t", left + 10, top + 30, width - 20);
   CreateEditBox(EDIT_START_SELL, " Bi?t ??", left + 10, top + 55, width - 20);
   CreateEditBox(EDIT_STOP_L1, " H?c t?p", left + 10, top + 80, width - 20);
   
   // Create buttons with better styling and spacing
   CreateButton(BTN_CLOSE_ALL, "CLOSE ALL", left + 10, top + 110, width - 20, 25, clrRed, clrWhite);
   CreateButton(BTN_CLOSE, "CLOSE SELL", left + 10, top + 140, width - 20, 25, C'255,192,192', clrBlack);
   CreateButton(BTN_CLOSE_PLUS, "CLOSE BUY", left + 10, top + 170, width - 20, 25, C'192,255,255', clrBlack);
}

void CreateLabel(string name, string text, int x, int y) {
   ObjectCreate(CHART_ID, name, OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(CHART_ID, name, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(CHART_ID, name, OBJPROP_YDISTANCE, y);
   ObjectSetString(CHART_ID, name, OBJPROP_TEXT, text);
   ObjectSetInteger(CHART_ID, name, OBJPROP_COLOR, clrNavy);
   ObjectSetInteger(CHART_ID, name, OBJPROP_FONTSIZE, 10);
   ObjectSetString(CHART_ID, name, OBJPROP_FONT, "Arial Bold");
}

void CreateEditBox(string name, string text, int x, int y, int width) {
   ObjectCreate(CHART_ID, name, OBJ_EDIT, 0, 0, 0);
   ObjectSetInteger(CHART_ID, name, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(CHART_ID, name, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(CHART_ID, name, OBJPROP_XSIZE, width);
   ObjectSetInteger(CHART_ID, name, OBJPROP_YSIZE, 20);
   ObjectSetString(CHART_ID, name, OBJPROP_TEXT, text);
   ObjectSetInteger(CHART_ID, name, OBJPROP_READONLY, true);
   ObjectSetInteger(CHART_ID, name, OBJPROP_COLOR, clrNavy);
   ObjectSetInteger(CHART_ID, name, OBJPROP_BGCOLOR, C'240,240,240');
   ObjectSetInteger(CHART_ID, name, OBJPROP_BORDER_COLOR, C'240,240,240');
   ObjectSetString(CHART_ID, name, OBJPROP_FONT, "Arial");
   ObjectSetInteger(CHART_ID, name, OBJPROP_FONTSIZE, 9);
}

void CreateButton(string name, string text, int x, int y, int width, int height, color bgColor, color textColor) {
   ObjectCreate(CHART_ID, name, OBJ_BUTTON, 0, 0, 0);
   ObjectSetInteger(CHART_ID, name, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(CHART_ID, name, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(CHART_ID, name, OBJPROP_XSIZE, width);
   ObjectSetInteger(CHART_ID, name, OBJPROP_YSIZE, height);
   ObjectSetString(CHART_ID, name, OBJPROP_TEXT, text);
   ObjectSetInteger(CHART_ID, name, OBJPROP_COLOR, textColor);
   ObjectSetInteger(CHART_ID, name, OBJPROP_BGCOLOR, bgColor);
   ObjectSetInteger(CHART_ID, name, OBJPROP_BORDER_COLOR, C'160,160,160');
   ObjectSetString(CHART_ID, name, OBJPROP_FONT, "Arial Bold");
   ObjectSetInteger(CHART_ID, name, OBJPROP_FONTSIZE, 9);
   ObjectSetInteger(CHART_ID, name, OBJPROP_STATE, false);
}


void ToggleCheckBox(string name, bool &state) {
   string currentText = ObjectGetString(CHART_ID, name, OBJPROP_TEXT);
   state = !state;
   string newText = (state ? "?" : "?") + StringSubstr(currentText, 1);
   ObjectSetString(CHART_ID, name, OBJPROP_TEXT, newText);
}

void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam) {
   if(id == CHARTEVENT_OBJECT_CLICK) {
      if(sparam == EDIT_START_BUY) {
         ToggleCheckBox(EDIT_START_BUY, g_startBuy);
      }
      else if(sparam == EDIT_START_SELL) {
         ToggleCheckBox(EDIT_START_SELL, g_startSell);
      }
      else if(sparam == EDIT_STOP_L1) {
         ToggleCheckBox(EDIT_STOP_L1, g_stopL1);
      }
      else if(sparam == BTN_CLOSE_ALL) {
         CloseAllPositions();
      }
      else if(sparam == BTN_CLOSE) {
      }
      else if(sparam == BTN_CLOSE_PLUS) {
         CloseWithExtra();
      }
   }
}

void OnDeinit(const int reason) {
    if(g_MFI_Handle != INVALID_HANDLE) 
        IndicatorRelease(g_MFI_Handle);
        if(g_ADX_Handle != INVALID_HANDLE) IndicatorRelease(g_ADX_Handle);
            if(g_AD_Handle != INVALID_HANDLE) IndicatorRelease(g_AD_Handle);
    if(g_EMA_Handle != INVALID_HANDLE) IndicatorRelease(g_EMA_Handle);

    if(g_Force_Handle != INVALID_HANDLE) IndicatorRelease(g_Force_Handle);
}



void CloseWithExtra() {
}
bool CheckMFISignal(ENUM_POSITION_TYPE posType) {
    if(CopyBuffer(g_MFI_Handle, 0, 0, 3, g_MFI_Buffer) < 3) return false;
    
    double mfi = g_MFI_Buffer[0];
    double mfi_prev = g_MFI_Buffer[1];
    
    if(posType == POSITION_TYPE_BUY) {
        // Buy: MFI oversold + turning up
        return (mfi < 40 && mfi > mfi_prev);
    } else {
        // Sell: MFI overbought + turning down
        return (mfi > 50 && mfi < mfi_prev);
    }
}
double g_PriceHistory[5];
int g_PriceHistoryIndex = 0;

double GetCleanPrice() {
    double rawPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Lưu vào history buffer
    g_PriceHistory[g_PriceHistoryIndex] = rawPrice;
    g_PriceHistoryIndex = (g_PriceHistoryIndex + 1) % 5;
    
    // Median filter (loại bỏ spike, giữ biến động thực)
    double sorted[5];
    ArrayCopy(sorted, g_PriceHistory);
    ArraySort(sorted);
    
    double cleanPrice = sorted[2]; // Median
    
    // Verify với spread
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double spread = (ask - cleanPrice) / _Point;
    
    if(spread < 0 || spread > 100) {
        // Spread bất thường = dùng raw
        return rawPrice;
    }
    
    // Round về tick size
    double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    cleanPrice = MathRound(cleanPrice / tickSize) * tickSize;
    
    g_LastCleanPrice = cleanPrice;
    return cleanPrice;
}
bool HasStrongMoneyFlow(ENUM_POSITION_TYPE posType) {
    if(CopyBuffer(g_MFI_Handle, 0, 0, 2, g_MFI_Buffer) < 2) return true; // fallback
    
    double mfi = g_MFI_Buffer[0];
    
    if(posType == POSITION_TYPE_BUY) {
        return (mfi > 40); // Buying pressure exists
    } else {
        return (mfi < 60); // Selling pressure exists
    }
}

// Add function to check if new orders should be allowed based on remaining time in period
bool HasEnoughTimeForNewOrder() {
    if(!EnableTimeBasedClosing) return true;
    
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    int currentHour = time_struct.hour;
    int currentMinute = time_struct.min;
    int minutesRemaining;
    
    // Calculate minutes remaining in current period
    if(currentHour >= Period1StartHour && currentHour < Period1EndHour) {
        minutesRemaining = (Period1EndHour - currentHour) * 60 - currentMinute;
        return minutesRemaining >= Period1OrderLifetime;
    }
    else if(currentHour >= Period2StartHour && currentHour < Period2EndHour) {
        minutesRemaining = (Period2EndHour - currentHour) * 60 - currentMinute;
        return minutesRemaining >= Period2OrderLifetime;
    }
    else if(currentHour >= Period3StartHour && currentHour < Period3EndHour) {
        minutesRemaining = (Period3EndHour - currentHour) * 60 - currentMinute;
        return minutesRemaining >= Period3OrderLifetime;
    }
    else {
        // For outside hours, check until next trading period starts
        int nextPeriodStart;
        if(currentHour < Period1StartHour) nextPeriodStart = Period1StartHour;
        else if(currentHour < Period2StartHour) nextPeriodStart = Period2StartHour;
        else if(currentHour < Period3StartHour) nextPeriodStart = Period3StartHour;
        else nextPeriodStart = 24 + Period1StartHour; // Next day's first period
        
        minutesRemaining = (nextPeriodStart - currentHour) * 60 - currentMinute;
        return minutesRemaining >= OutsideHoursLifetime;
    }
}


double CalculateTraditionalMarketRange() {
    static datetime lastCalculation = 0;
    static double lastRange = 0;

    // Ch? tính toán l?i sau m?i 5 phút thay vì nhi?u l?n m?i tick
    if(TimeCurrent() - lastCalculation < 300 && lastRange > 0) {
        return lastRange;
    }

    MqlRates ratesH1[], ratesH4[], ratesD1[];
    ArraySetAsSeries(ratesH1, true);
    ArraySetAsSeries(ratesH4, true);
    ArraySetAsSeries(ratesD1, true);
    
    // L?y d? li?u t? nhi?u timeframe
    if(CopyRates(_Symbol, PERIOD_H1, 0, 10, ratesH1) < 10 ||
       CopyRates(_Symbol, PERIOD_H4, 0, 5, ratesH4) < 5 ||
       CopyRates(_Symbol, PERIOD_D1, 0, 3, ratesD1) < 3) {
        // N?u không l?y ???c d? li?u, tr? v? giá tr? ?ã tính toán tr??c ?ó
        return lastRange;
    }
    
    // Tính range cho t?ng timeframe
    double h1Range = 0, h4Range = 0, d1Range = 0;
    
    // H1 Range - Bi?n ??ng ng?n h?n
    double h1High = ratesH1[0].high;
    double h1Low = ratesH1[0].low;
    for(int i = 0; i < 10; i++) {
        if(ratesH1[i].high > h1High) h1High = ratesH1[i].high;
        if(ratesH1[i].low < h1Low) h1Low = ratesH1[i].low;
    }
    h1Range = MathAbs(h1High - h1Low) / _Point;

    // H4 Range - Bi?n ??ng trung h?n
    double h4High = ratesH4[0].high;
    double h4Low = ratesH4[0].low;
    for(int i = 0; i < 5; i++) {
        if(ratesH4[i].high > h4High) h4High = ratesH4[i].high;
        if(ratesH4[i].low < h4Low) h4Low = ratesH4[i].low;
    }
    h4Range = MathAbs(h4High - h4Low) / _Point;

    // D1 Range - Bi?n ??ng dài h?n
    double d1High = ratesD1[0].high;
    double d1Low = ratesD1[0].low;
    for(int i = 0; i < 3; i++) {
        if(ratesD1[i].high > d1High) d1High = ratesD1[i].high;
        if(ratesD1[i].low < d1Low) d1Low = ratesD1[i].low;
    }
    d1Range = MathAbs(d1High - d1Low) / _Point;

    // Tính tr?ng s? cho t?ng range
    double weightedRange;
    
    // Tính ATR c?a D1 ?? xác ??nh th? tr??ng ?ang trong giai ?o?n nào
    double d1ATR = 0;
    for(int i = 1; i < 3; i++) {
        d1ATR += MathAbs(ratesD1[i].high - ratesD1[i].low) / _Point;
    }
    d1ATR /= 2;

    // ?i?u ch?nh tr?ng s? d?a trên ATR
    if(d1ATR > g_CurrentAIThreshold * 1.5) {
        // Th? tr??ng bi?n ??ng m?nh - ?u tiên range ng?n h?n
        weightedRange = (h1Range * 0.5 + h4Range * 0.3 + d1Range * 0.2);
    }
    else if(d1ATR > g_CurrentAIThreshold) {
        // Th? tr??ng bi?n ??ng v?a - cân b?ng các range
        weightedRange = (h1Range * 0.4 + h4Range * 0.4 + d1Range * 0.2);
    }
    else {
        // Th? tr??ng ít bi?n ??ng - ?u tiên range dài h?n
        weightedRange = (h1Range * 0.2 + h4Range * 0.3 + d1Range * 0.5);
    }

    // Gi?m l??ng ghi log - ch? in khi th?c s? c?n thi?t
    static datetime lastLogTime = 0;
    static double lastLoggedRange = 0;

    // Ch? log m?i 30 phút ho?c khi giá tr? thay ??i l?n
    if(TimeCurrent() - lastLogTime > 1800 || MathAbs(lastLoggedRange - weightedRange) > g_CurrentAIThreshold * 0.2) {
           
        lastLogTime = TimeCurrent();
        lastLoggedRange = weightedRange;
    }

    lastCalculation = TimeCurrent();
    lastRange = weightedRange;

    return weightedRange;
}

//+------------------------------------------------------------------+
//| NEW: AI-enabled wrapper function for CalculateMarketRange       |
//+------------------------------------------------------------------+
double CalculateMarketRange() {
    return CalculateMarketRangeWithAI();
}

//+------------------------------------------------------------------+
//| Update AI Threshold - C?p nh?t ng??ng AI ??ng                    |
//+------------------------------------------------------------------+
void UpdateAIThreshold() {
    // Ki?m tra th?i gian c?p nh?t
    if(TimeCurrent() - g_LastThresholdUpdate < AIThresholdUpdateInterval) {
        return; // Ch?a ??n th?i gian c?p nh?t
    }

    // L?y giá tr? market range hi?n t?i t? AI
    double currentRange = CalculateMarketRange();

    // N?u l?y ???c giá tr? h?p l?, c?p nh?t threshold
    if(currentRange > 0) {
        g_CurrentAIThreshold = currentRange;
        g_LastThresholdUpdate = TimeCurrent();


    }
    else {
        // N?u không l?y ???c t? AI, gi? nguyên giá tr? c? ho?c dùng m?c ??nh
        if(g_CurrentAIThreshold == 0) {
            g_CurrentAIThreshold = MarketRangeThreshold;
        }

    }
}

// Function to check if current time is within news protection period
bool IsWithinNewsTime() {
    if(!EnableNewsProtection) return false;
    
    datetime currentTime = TimeCurrent();
    
    // Update news times array if needed (check every hour)
    if(!g_IsNewsUpdated || currentTime - g_LastNewsCheck > 3600) {
        UpdateNewsTimes();
    }
    
    // Check each news event
    for(int i = 0; i < ArraySize(g_NewsTimes); i++) {
        // Calculate protection window
        datetime newsStartProtection = g_NewsTimes[i] - NewsProtectionMinutes * 60;
        datetime newsEndProtection = g_NewsTimes[i] + NewsProtectionAfterMinutes * 60;
        
        // Check if current time is within protection window
        if(currentTime >= newsStartProtection && currentTime <= newsEndProtection) {
        
            return true;
        }
    }
    
    return false;
}

// Function to update news times array
void UpdateNewsTimes() {
    // Clear existing array
    ArrayResize(g_NewsTimes, 0);
    
    // Add high impact news times for the current day
    datetime currentTime = TimeCurrent();
    MqlDateTime time_struct;
    TimeToStruct(currentTime, time_struct);
    
    // Example: Major news times (customize based on your broker's schedule)
    int highImpactNewsTimes[] = {
        830,  // 8:30 AM - Major US news
        1000, // 10:00 AM - Key economic data
        1400, // 2:00 PM - FOMC
        1430, // 2:30 PM - Fed speak
        1500  // 3:00 PM - Important EU news
    };
    
    // Convert times to datetime and add to array
    for(int i = 0; i < ArraySize(highImpactNewsTimes); i++) {
        MqlDateTime news_time;
        news_time.year = time_struct.year;
        news_time.mon = time_struct.mon;
        news_time.day = time_struct.day;
        news_time.hour = highImpactNewsTimes[i] / 100;
        news_time.min = highImpactNewsTimes[i] % 100;
        news_time.sec = 0;
        
        datetime newsTime = StructToTime(news_time);
        
        // Only add future news times
        if(newsTime > currentTime) {
            ArrayResize(g_NewsTimes, ArraySize(g_NewsTimes) + 1);
            g_NewsTimes[ArraySize(g_NewsTimes) - 1] = newsTime;
        }
    }
    
    g_IsNewsUpdated = true;
    g_LastNewsCheck = currentTime;
    
    // Log updated news times
    for(int i = 0; i < ArraySize(g_NewsTimes); i++) {
    }
}

void ResetMarketRangeCalculations() {
    g_TrendFollowingMode = false;
    g_LastRangeReset = TimeCurrent();
    
}



//+------------------------------------------------------------------+
//| Ki?m tra ?i?u ki?n bi?n ??ng ??u phiên M?                         |
//+------------------------------------------------------------------+
bool IsNYOpenVolatile() {
    if(!EnableNYSessionProtection) return false;
    
    datetime currentTime = TimeCurrent();
    MqlDateTime current_struct;
    TimeToStruct(currentTime, current_struct);
    
    // Ch? ki?m tra m?t l?n m?i phút
    if(currentTime - g_LastNYVolatilityCheck < 60) {
        return g_IsNYOpenVolatile;
    }
    
    // Ki?m tra xem có ph?i trong kho?ng th?i gian b?o v? không
    bool isNYOpeningPeriod = false;
    int minutesSinceNYOpen = 0;
    
    if(current_struct.hour == NYSessionStartHour) {
        minutesSinceNYOpen = current_struct.min;
        isNYOpeningPeriod = (minutesSinceNYOpen <= NYSessionVolatilityPeriod);
    }
    
    if(!isNYOpeningPeriod) {
        g_IsNYOpenVolatile = false;
        g_LastNYVolatilityCheck = currentTime;
        return false;
    }
    
    // L?y d? li?u giá c?a 5 phút g?n nh?t
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    int copied = CopyRates(_Symbol, PERIOD_M1, 0, 5, rates);
    
    if(copied < 5) return false;
    
    // Tính toán bi?n ??ng
    double highestHigh = -DBL_MAX;
    double lowestLow = DBL_MAX;
    
    // Tìm high và low th? công thay vì dùng ArrayMaximum/ArrayMinimum
    for(int i = 0; i < 5; i++) {
        if(rates[i].high > highestHigh) highestHigh = rates[i].high;
        if(rates[i].low < lowestLow) lowestLow = rates[i].low;
    }
    
    double volatility = MathAbs(highestHigh - lowestLow) / _Point;
    
    // Tính volume trung bình
    double avgVolume = 0;
    for(int i = 0; i < 5; i++) {
        avgVolume += (double)rates[i].tick_volume;
    }
    avgVolume /= 5;
    
    // Tính momentum
    double momentum = MathAbs(rates[0].close - rates[4].close) / _Point;
    
 
    
    // C?p nh?t tr?ng thái
    g_IsNYOpenVolatile = (volatility > NYVolatilityThreshold || 
                         momentum > NYVolatilityThreshold * 0.8);
    g_LastNYVolatilityCheck = currentTime;
    
    // ?óng l?nh n?u ???c c?u hình và bi?n ??ng cao
    if(CloseOrdersOnNYOpen && g_IsNYOpenVolatile) {
        if(PositionsTotal() > 0) {
            CloseAllPositions();
        }
    }
    
    return g_IsNYOpenVolatile;
}


//+------------------------------------------------------------------+
//| C?p nh?t hàm IsNewTradingAllowed                                  |
//+------------------------------------------------------------------+



// Add this new function to check weekend trading conditions

bool IsWeekendTrading() {
    // N?u không b?t b?o v? cu?i tu?n, luôn tr? v? false mà không in log
    if(!EnableWeekendProtection) return false;
    
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    

    // Friday check - more precise hour comparison
    if(time_struct.day_of_week == FRIDAY && time_struct.hour >= FridayLastTradeHour) {
        return true;
    }
    
    // Saturday check
    if(time_struct.day_of_week == SATURDAY) {
        return true;
    }
    
    // Sunday check
    if(time_struct.day_of_week == SUNDAY) {
        return true;
    }
    
    // Monday before start hour
    if(time_struct.day_of_week == MONDAY && time_struct.hour < MondayFirstTradeHour) {
        return true;
    }
    
    return false;
}


bool IsTrendModeValid() {
    static int highVolCount = 0;
    static int lowVolCount = 0;
    
    double marketRange = CalculateMarketRange();
    double momentum = MathAbs(CalculateMarketMomentum());

    // Ki?m tra c? bi?n ??ng và momentum
    if(marketRange > g_CurrentAIThreshold && momentum > MomentumEntryThreshold) {
        highVolCount++;
        lowVolCount = 0;
    } else {
        lowVolCount++;
        highVolCount = 0;
    }
    
    // Yêu c?u ít nh?t 3 chu k? liên ti?p ?? xác nh?n trend
    if(highVolCount >= 1) return true;
    if(lowVolCount >= 1) return false;
    
    return g_TrendFollowingMode;
}

void HandleWeekendClosing() {
    if(!EnableWeekendProtection || !CloseTradesBeforeWeekend) return;
    
    // Get current time
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
    // Only process on Friday
    if(time_struct.day_of_week != FRIDAY) return;
    
    // Check if past or at cutoff hour
    if(time_struct.hour >= FridayLastTradeHour) {
        EmergencyCloseAllPositions("Weekend protection - After cutoff hour");
        return;
    }
    
    // Check if approaching cutoff (2 hours before)
    if(time_struct.hour >= (FridayLastTradeHour - 2)) {
        // Check every minute in the last 2 hours
        static datetime lastMinuteCheck = 0;
        datetime currentTime = TimeCurrent();
        
        // Only run once per minute
        if(currentTime - lastMinuteCheck < 60) return;
        lastMinuteCheck = currentTime;
        
        // Check recovery and profit conditions
        bool hasRecoveryOrders = false;
        double totalProfit = 0;
        int totalPositions = 0;
        
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            totalPositions++;
            totalProfit += PositionGetDouble(POSITION_PROFIT);
            
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Recovery") >= 0) {
                hasRecoveryOrders = true;
            }
        }
        
        // Print status every minute
        int minutesUntilCutoff = (FridayLastTradeHour - time_struct.hour) * 60 - time_struct.min;
       
        // Decision logic
        bool shouldClose = false;
        string closeReason = "";
        
        // Force close in last 30 minutes
        if(minutesUntilCutoff <= 30) {
            shouldClose = true;
            closeReason = "Final 30 minutes before weekend";
        }
        // Earlier close for recovery orders
        else if(hasRecoveryOrders && minutesUntilCutoff <= 60) {
            shouldClose = true;
            closeReason = "Recovery orders present - last hour";
        }
        // Close on profit whenever possible
        else if(totalProfit >= MinProfitToClose) {
            shouldClose = true;
            closeReason = "Profit target reached before weekend";
        }
        
        if(shouldClose && totalPositions > 0) {
            EmergencyCloseAllPositions(closeReason);
        }
    }
}
// New helper function to forcefully close all positions

int GetDaysInMonth(int year, int month) {
    int daysInMonth;
    
    switch(month) {
        case 2: {  // February
            bool isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
            daysInMonth = isLeapYear ? 29 : 28;
            break;
        }
        case 4:  // April
        case 6:  // June
        case 9:  // September
        case 11: // November
            daysInMonth = 30;
            break;
        default:
            daysInMonth = 31;
    }
    
    return daysInMonth;
}

// Thêm bi?n global ?? theo dõi tr?ng thái ?óng l?nh cu?i tháng
datetime g_LastMonthEndCloseTime = 0;
const int MIN_WAIT_BETWEEN_MONTH_END_CLOSE = 3600; // 1 gi?

bool IsMonthEndTrading() {
    if(!EnableMonthEndProtection) return false;
    
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
    int daysInMonth = GetDaysInMonth(time_struct.year, time_struct.mon);
    
    // Calculate protection days
    int protectionStartDay = daysInMonth - MonthEndProtectionDays + 1;
    
    // Month-end protection check
    bool isMonthEndProtection = (time_struct.day >= protectionStartDay);
    
    // Month-start protection check - check for first MonthStartProtectionDays days
    bool isMonthStartProtection = (time_struct.day <= MonthStartProtectionDays && 
                                  time_struct.hour < MonthStartFirstTradeHour);
    
    // Check if in protection period
    if(isMonthEndProtection || isMonthStartProtection) {
    
        return true;
    }
    
    return false;
}
void HandleMonthEndClosing() {
    if(!EnableMonthEndProtection || !CloseTradesBeforeMonthEnd) return;
    
    // Ki?m tra th?i gian gi?a các l?n ?óng l?nh
    datetime currentTime = TimeCurrent();
    if(currentTime - g_LastMonthEndCloseTime < MIN_WAIT_BETWEEN_MONTH_END_CLOSE) {
        return;
    }
    
    MqlDateTime time_struct;
    TimeToStruct(currentTime, time_struct);
    
    int daysInMonth = GetDaysInMonth(time_struct.year, time_struct.mon);
    int protectionStartDay = daysInMonth - MonthEndProtectionDays;
    
    // Ki?m tra ?i?u ki?n ?óng l?nh
    bool shouldClose = false;
    string closeReason = "";
    
    // Ki?m tra n?u ?ang ? nh?ng ngày cu?i tháng
    if(time_struct.day >= protectionStartDay) {
        double totalProfit = 0;
        int totalPositions = 0;
        
        // Tính t?ng l?i nhu?n và s? l?nh
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            totalProfit += PositionGetDouble(POSITION_PROFIT);
            totalPositions++;
        }
        
        // ?i?u ki?n ?óng l?nh
        bool profitCondition = (totalProfit >= MonthEndMinProfitToClose);
        bool nearCutoffTime = 
            (time_struct.day == daysInMonth && time_struct.hour >= MonthEndLastTradeHour) ||
            (time_struct.day == daysInMonth && (MonthEndLastTradeHour - time_struct.hour) <= 2);
        
        shouldClose = (profitCondition || nearCutoffTime) && totalPositions > 0;
        
        if(shouldClose) {
            closeReason = profitCondition ? "Profit target reached" : "Near month-end cutoff";
        
            // ?óng t?t c? các l?nh
            for(int i = PositionsTotal() - 1; i >= 0; i--) {
                ulong ticket = PositionGetTicket(i);
                if(!PositionSelectByTicket(ticket)) continue;
                if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                
                if(trade.PositionClose(ticket)) {
            
                } else {
                }
            }
            
            // C?p nh?t th?i gian ?óng l?nh cu?i cùng
            g_LastMonthEndCloseTime = currentTime;
        }
    }
}

// Function to ensure fixed DCA distances from input parameters
bool ValidateDCADistance(ENUM_ORDER_TYPE orderType, double price, int cycleId) {
    ENUM_POSITION_TYPE posType = (orderType == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
    
    // Get all orders for this specific cycle
    int orderCount = 0;
    double latestPrice = 0;
    datetime latestTime = 0;
    
    // Find the latest order in this cycle
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(ExtractCycleId(comment) != cycleId) continue;
        
        orderCount++;
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        if(openTime > latestTime) {
            latestTime = openTime;
            latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        }
    }
    
    // If no orders found for this cycle, validation passes
    if(orderCount == 0) return true;
    
    // Get exact fixed distance from input parameters based on order number
    double fixedDistance = GetExactDCADistance(orderCount + 1);
    
    // Calculate actual distance
    double actualDistance = MathAbs(price - latestPrice) / _Point;
    
    // Check if the actual distance meets the required fixed distance
    bool isValid = (posType == POSITION_TYPE_BUY) ? 
                   (price < latestPrice && actualDistance >= fixedDistance) : 
                   (price > latestPrice && actualDistance >= fixedDistance);
    
 
    return isValid;
}

// 3. Update the GetExactDCADistance function to ensure distances are reasonable
double GetExactDCADistance(int orderNumber) {
    double distance;
    
    // Use the specific gap values for each order number
    switch(orderNumber) {
        case 2: distance = SecondOrderGap; break;
        case 3: distance = ThirdOrderGap; break;
        case 4: distance = FourthOrderGap; break;
        case 5: distance = FifthOrderGap; break;
        case 6: distance = SixthOrderGap; break;
        case 7: distance = SeventhOrderGap; break;
        case 8: distance = EighthOrderGap; break;
        case 9: distance = NinthOrderGap; break;
        case 10: distance = TenthOrderGap; break;
        case 11: distance = EleventhOrderGap; break;
        case 12: distance = TwelfthOrderGap; break;
        case 13: distance = ThirteenthOrderGap; break;
        case 14: distance = FourteenthOrderGap; break;
        case 15: distance = FifteenthOrderGap; break;
        case 16: distance = SixteenthOrderGap; break;
        default: distance = DCADistance; break;
    }
    
    // Ensure minimum safe distance
    distance = MathMax(distance, MinimumOrderDistance);
    
    
    return distance;
}


// Structure to track order groups
struct OrderGroup {
    bool hasRegularOrders;
    bool hasHedgeOrders;
    double lastRegularPrice;
    double lastHedgePrice;
    int regularCount;
    int hedgeCount;
    datetime lastRegularTime;
    datetime lastHedgeTime;
    
    // Initialize function instead of constructor
    void Initialize() {
        hasRegularOrders = false;
        hasHedgeOrders = false;
        lastRegularPrice = 0;
        lastHedgePrice = 0;
        regularCount = 0;
        hedgeCount = 0;
        lastRegularTime = 0;
        lastHedgeTime = 0;
    }
};

// Helper function to analyze order groups
void AnalyzeOrderGroups(OrderGroup &buyGroup, OrderGroup &sellGroup) {
    // Initialize groups using the Initialize method
    buyGroup.Initialize();
    sellGroup.Initialize();
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        string comment = PositionGetString(POSITION_COMMENT);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        bool isHedge = (StringFind(comment, "Hedge") >= 0);
        
        // Update appropriate group
        if(posType == POSITION_TYPE_BUY) {
            if(isHedge) {
                buyGroup.hasHedgeOrders = true;
                buyGroup.hedgeCount++;
                if(openTime > buyGroup.lastHedgeTime) {
                    buyGroup.lastHedgeTime = openTime;
                    buyGroup.lastHedgePrice = openPrice;
                }
            } else {
                buyGroup.hasRegularOrders = true;
                buyGroup.regularCount++;
                if(openTime > buyGroup.lastRegularTime) {
                    buyGroup.lastRegularTime = openTime;
                    buyGroup.lastRegularPrice = openPrice;
                }
            }
        } else {
            if(isHedge) {
                sellGroup.hasHedgeOrders = true;
                sellGroup.hedgeCount++;
                if(openTime > sellGroup.lastHedgeTime) {
                    sellGroup.lastHedgeTime = openTime;
                    sellGroup.lastHedgePrice = openPrice;
                }
            } else {
                sellGroup.hasRegularOrders = true;
                sellGroup.regularCount++;
                if(openTime > sellGroup.lastRegularTime) {
                    sellGroup.lastRegularTime = openTime;
                    sellGroup.lastRegularPrice = openPrice;
                }
            }
        }
    }
}

// Modified TP calculation for parallel DCA

// Helper function to update TP for specific order group
void UpdateGroupTP(ENUM_POSITION_TYPE posType, bool isHedge, double newTP) {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        bool orderIsHedge = (StringFind(comment, "Hedge") >= 0);

        if(orderIsHedge == isHedge) {
            if(IsValidTPLevel(SymbolInfoDouble(_Symbol, SYMBOL_BID), newTP, posType)) {
                // Ch? c?p nh?t n?u TP khác giá tr? hi?n t?i
                double currentTP = PositionGetDouble(POSITION_TP);
                if(MathAbs(currentTP - newTP) > _Point) {
                    double currentSL = PositionGetDouble(POSITION_SL);
                    trade.PositionModify(ticket, currentSL, newTP);
                }
            }
        }
    }
}
//+------------------------------------------------------------------+
//| Recovery Logic for Merlin EA                                      |
//+------------------------------------------------------------------+

// Add these new input parameters
input group "===== RECOVERY MODE SETTINGS ====="
input bool EnableRecoveryMode = true;          // B?t/t?t ch? ?? Recovery
input double RecoveryLossThreshold = -500;     // Ng??ng l? kích ho?t Recovery (?i?m)
input double RecoveryVolumeMultiplier = 3.0;   // H? s? nhân volume Recovery
input double RecoveryProfitTarget = 0.0;       // M?c tiêu l?i nhu?n Recovery (0 = hòa v?n)
input int MaxRecoveryAttempts = 3;             // S? l?n Recovery t?i ?a

// Add these global variables
bool g_InRecoveryMode = false;
int g_RecoveryAttempts = 0;
ulong g_RecoveryOrderTicket = 0;
double g_RecoveryStartLoss = 0;
datetime g_RecoveryStartTime = 0;

// Function to check and activate recovery mode

// Add these global variables at the top of your file alongside other globals
datetime g_LastHedgeOrderTime = 0;            // Tracks the last time a hedge order was placed
const int HEDGE_COOLDOWN_SECONDS = 300;       // Cooldown period between hedge orders (5 minutes)
// Helper function to retry recovery order with adjusted parameters

// Additional helper function to calculate total volume
double CalculateTotalVolume(ENUM_POSITION_TYPE posType) {
    double totalVolume = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) == posType) {
            totalVolume += PositionGetDouble(POSITION_VOLUME);
        }
    }
    
    // Ensure minimum volume
    if(totalVolume < defaultFixLength) {
        totalVolume = defaultFixLength;
    }
    
    return totalVolume;
}

// Helper function to get error description


// Function to update TP for all positions
void UpdateAllPositionsTP() {
    // Only do this if we have a valid recovery order
    if(!PositionSelectByTicket(g_RecoveryOrderTicket)) return;
    
    double recoveryTP = PositionGetDouble(POSITION_TP);
    ENUM_POSITION_TYPE recoveryType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    
    // We don't need to update the TP of other positions for now
    // This can be implemented if needed
}

// Function to calculate average volume of positions
double CalculateAvgVolume(ENUM_POSITION_TYPE posType) {
    double totalVolume = 0;
    int count = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) == posType) {
            totalVolume += PositionGetDouble(POSITION_VOLUME);
            count++;
        }
    }
    
    if(count > 0) {
        return totalVolume / count;
    }
    
    return defaultFixLength; // Return default lot size if no positions found
}

// Function to calculate recovery TP - optimized for faster recovery

            // S? l?n Recovery t?i ?a
input int RecoveryMaxLifetimeHours = 3;        // Th?i gian t?n t?i t?i ?a c?a l?nh Recovery (gi?)

// Update your global variables section - add this line
datetime g_RecoveryOrderOpenTime = 0;          // Th?i gian m? l?nh Recovery

// Modify the OpenRecoveryOrder function to track opening time
// Function to calculate optimal recovery volume

// Function to calculate optimal recovery TP


// Global variables to track recovery DCA
int g_RecoveryDCACount = 0;
datetime g_LastRecoveryDCATime = 0;


double CalculateRecoveryVolume() {
    double totalPositionVolume = 0;
    double totalPositionLoss = 0;
    double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);
    
    // Calculate total volume and loss of existing positions
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        double volume = PositionGetDouble(POSITION_VOLUME);
        double profit = PositionGetDouble(POSITION_PROFIT);
        
        totalPositionVolume += volume;
        
        // Only count losses for the calculation
        if(profit < 0) {
            totalPositionLoss += MathAbs(profit);
        }
    }
    
    // Calculate base recovery volume
    double baseVolume = totalPositionVolume * RecoveryVolumeMultiplier;
    
    // Calculate loss-adjusted volume
    double lossRatio = totalPositionLoss / MathAbs(RecoveryLossThreshold);
    double lossAdjustment = MathMin(1.5, MathMax(0.8, lossRatio)); // 0.8 to 1.5 range
    
    // Apply risk control based on account equity
    double equityRatio = totalPositionLoss / accountEquity;
    double maxAllowedVolume = totalPositionVolume * 2.0; // Cap at 2x total volume
    
    // Final recovery volume calculation
    double recoveryVolume = baseVolume * lossAdjustment;
    
    // Risk controls
    if(equityRatio > 0.1) { // If loss exceeds 10% of equity, reduce volume
        recoveryVolume *= 0.8;
    }
    
    // Ensure minimum and maximum constraints
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    recoveryVolume = MathMax(recoveryVolume, minLot);
    recoveryVolume = MathMin(recoveryVolume, maxAllowedVolume);
    
    // Normalize to valid lot size
    recoveryVolume = NormalizeDouble(recoveryVolume, 2);
    
   
    
    return recoveryVolume;
}
// Reset recovery DCA count at the start of a new day
void ResetRecoveryDCACount() {
    datetime currentTime = TimeCurrent();
    MqlDateTime time_struct;
    TimeToStruct(currentTime, time_struct);
    
    // Check if we've moved to a new day
    static datetime lastResetDay = 0;
    if(lastResetDay == 0 || time_struct.day != TimeToStruct(lastResetDay, time_struct)) {
        g_RecoveryDCACount = 0;
        lastResetDay = currentTime;
        
   
    }
}

// Function to calculate precise recovery DCA volume


// Update the CalculateRecoveryTP function to use the trend TP value
double CalculateRecoveryTP(ENUM_ORDER_TYPE orderType, double entryPrice) {
    // Use g_TrendTP value instead of period TP
    double takeProfit = 0;
    if(orderType == ORDER_TYPE_BUY) {
        takeProfit = NormalizeDouble(entryPrice + g_TrendTP * _Point, _Digits);
    } else {
        takeProfit = NormalizeDouble(entryPrice - g_TrendTP * _Point, _Digits);
    }
    
    // Ensure minimum TP distance
    double currentPrice = GetCleanPrice();
    double minTPDistance = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point * 2;
    
    if((orderType == ORDER_TYPE_BUY && (takeProfit - currentPrice) < minTPDistance) ||
       (orderType == ORDER_TYPE_SELL && (currentPrice - takeProfit) < minTPDistance)) {
        
        takeProfit = (orderType == ORDER_TYPE_BUY) ?
                    NormalizeDouble(currentPrice + minTPDistance, _Digits) :
                    NormalizeDouble(currentPrice - minTPDistance, _Digits);
    }
    

    
    return takeProfit;
}

// Update the UpdateRecoveryCombinedTP function to only activate after a threshold
void UpdateRecoveryCombinedTP() {
    // DISABLED: Using virtual TP/SL system instead
    return;

    // Limit update frequency (every 5 seconds)
    static datetime lastTPUpdate = 0;
    datetime currentTime = TimeCurrent();
    if(currentTime - lastTPUpdate < 5) return;
    lastTPUpdate = currentTime;
    
    // Calculate weighted average price and total volume
    double totalVolume = 0;
    double weightedSum = 0;
    int recoveryOrderCount = 0;
    ENUM_POSITION_TYPE mainPositionType = POSITION_TYPE_BUY; // Default
    
    // First, identify all recovery orders
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
            double volume = PositionGetDouble(POSITION_VOLUME);
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            // Save the type of the first recovery position
            if(recoveryOrderCount == 0) mainPositionType = posType;
            
            weightedSum += openPrice * volume;
            totalVolume += volume;
            recoveryOrderCount++;
        }
    }
    
    // Verify we found orders
    if(recoveryOrderCount == 0 || totalVolume == 0) {
        return;
    }
    
    // Only switch to combined TP if we have enough orders (use CombinedTPLevel)
    if(recoveryOrderCount < CombinedTPLevel) {
        // Not enough orders for combined TP yet
      
        return;
    }
    
    // Calculate weighted average price
    double avgPrice = NormalizeDouble(weightedSum / totalVolume, _Digits);
    
    // Get current period TP based on current hour
    // int tpPoints = GetPeriodTP(); // DISABLED: Using virtual TP/SL
    
    // Calculate TP level
 

    

    
    // Update TP for all recovery orders
    int updatedCount = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
            // Only update if current TP is different
            double currentTP = PositionGetDouble(POSITION_TP);
            if(MathAbs(currentTP ) > _Point) {
                double currentSL = PositionGetDouble(POSITION_SL);
           
            }
        }
    }
    
    // Log the update
    if(updatedCount > 0) {
   
    }
}

// Also update how we handle Recovery DCA TPs


// Add this new helper function to standardize the volume calculations for recovery DCA
double CalculateNextRecoveryLotSize() {
    int currentOrderNumber = g_RecoveryOrderCount + 1;
    double exactLot = defaultFixLength;
    
    // Apply the same multiplier logic as regular DCA
    for(int i = 1; i < currentOrderNumber; i++) {
        exactLot *= GetExactMultiplier(i);
    }
    
    // Ensure the calculated lot size is within broker limits
    return NormalizeLotSize(exactLot * RecoveryVolumeMultiplier);
}

// Finally, update the CalculateRecoveryDCAVolume function to be more consistent with regular DCA
bool OpenRecoveryDCAOrder(ENUM_ORDER_TYPE orderType, double volume, double currentPrice) {
    // Use the same distance checking logic as regular DCA orders
    ENUM_POSITION_TYPE posType = (orderType == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
    
    // Add this at the start of every order opening function:
    if(!EnforcePeriodOrderLimits()) {
        return false;
    }
    
    // Double check minimum distance between orders
    if(!CheckMinimumDistanceBetweenOrders(currentPrice, posType)) {
        return false;
    }
    
    // Get current cycle order count
    int currentCycleOrderCount = GetCurrentRecoveryOrderCount();
    
    // Check if we've reached max DCA orders for this recovery cycle
    if(currentCycleOrderCount >= MaxRecoveryDCAOrders) {
        return false;
    }
    
    // Determine the appropriate TP method based on total recovery order count
    double takeProfit;
    
    // If order count has reached combined threshold, use weighted average
    if(currentCycleOrderCount + 1 >= CombinedTPLevel) {
        // Calculate weighted average for all existing recovery orders
        double weightedSum = currentPrice * volume; // Include this new order
        double totalVolume = volume;
        
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Recovery") >= 0 && 
               StringFind(comment, "Cycle " + IntegerToString(g_CurrentRecoveryCycleId)) >= 0) {
                double posVolume = PositionGetDouble(POSITION_VOLUME);
                double posPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                weightedSum += posPrice * posVolume;
                totalVolume += posVolume;
            }
        }
        
        double avgPrice = NormalizeDouble(weightedSum / totalVolume, _Digits);
        // int tpPoints = GetPeriodTP(); // DISABLED: Using virtual TP/SL
          
    }
    else {
        // For initial orders, use trend TP for individual TP
        takeProfit = (orderType == ORDER_TYPE_BUY) ?
                    NormalizeDouble(currentPrice + g_TrendTP * _Point, _Digits) :
                    NormalizeDouble(currentPrice - g_TrendTP * _Point, _Digits);
                    
    }
    
    // Prepare comment for the recovery DCA order - INCLUDE CYCLE ID
    string comment = StringFormat("Recovery DCA %s #%d Cycle %d",
                                EnumToString(orderType),
                                currentCycleOrderCount + 1,
                                g_CurrentRecoveryCycleId);

    // Open the order without TP and SL
    if(trade.PositionOpen(_Symbol, orderType, volume, currentPrice, 0, 0, comment)) {
        g_RecoveryOrderCount++;
        g_RecoveryTotalVolume += volume;
        
        // Update average price calculation
        g_RecoveryAveragePrice = ((g_RecoveryAveragePrice * (g_RecoveryTotalVolume - volume)) +
                                (currentPrice * volume)) / g_RecoveryTotalVolume;
        
     
        
        // If we just reached the combined TP threshold, update all TPs
        if(currentCycleOrderCount + 1 == CombinedTPLevel) {
        }
        
        return true;
    }
    
    return false;
}// Helper function to count orders belonging to current recovery cycle
int GetCurrentRecoveryOrderCount() {
    int count = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        
        // Check if this is a recovery order from current cycle
        if(StringFind(comment, "Recovery") >= 0) {
            // Check for cycle ID in comment
            if(StringFind(comment, "Cycle " + IntegerToString(g_CurrentRecoveryCycleId)) >= 0) {
                count++;
            } 
            // For backward compatibility with older recovery orders without cycle ID
            else if(g_CurrentRecoveryCycleId == 1 && StringFind(comment, "Cycle") < 0) {
                count++;
            }
        }
    }
    
    return count;
}
// Function to calculate recovery order distance
double CalculateRecoveryOrderDistance(int dcaAttempt) {
    // Predefined distances for different DCA attempts
    double distances[] = {3000, 6000, 9000}; // points
    
    // Ensure dcaAttempt is within array bounds
    int index = MathMin(dcaAttempt, ArraySize(distances) - 1);
    
    return distances[index];
}
// Modify the ManageRecoveryDCAOrders function to fix syntax and logic
// Función para gestionar DCA en órdenes de recuperación


// Calcular distancia para órdenes DCA de recuperación



// Cerrar todas las posiciones de recuperación
void CloseAllRecoveryPositions() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
        }
    }
    
    // Resetear variables de recuperación
    g_RecoveryOrderCount = 0;
    g_RecoveryTotalVolume = 0;
    g_RecoveryAveragePrice = 0;
    g_LastMarketVolatility = 0;
    g_VolatilityDecreasing = false;
}

// Update the RetryRecoveryOrder function to also track open time
void RetryRecoveryOrder(ENUM_ORDER_TYPE orderType, double volume, string comment) {
    double entryPrice = (orderType == ORDER_TYPE_BUY) ? 
                      SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
                      SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Calculate simplified TP
    double tp = (orderType == ORDER_TYPE_BUY) ?
               entryPrice + 300 * _Point :
               entryPrice - 300 * _Point;

    // Open order without TP/SL
    if(trade.PositionOpen(_Symbol, orderType, volume, entryPrice, 0, 0, comment)) {
        g_RecoveryOrderTicket = trade.ResultOrder();
        g_RecoveryAttempts++;
        g_RecoveryOrderOpenTime = TimeCurrent(); // Record open time for retry as well
    } else {
        g_InRecoveryMode = false;
    }
}


// New helper function to check and start new recovery if needed
bool CheckAndStartNewRecovery() {
    // Only try new recovery if we haven't exceeded maximum attempts
    if(g_RecoveryAttempts >= MaxRecoveryAttempts) {
        return false;
    }
    
    // Calculate current profit
    double currentProfit = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        currentProfit += PositionGetDouble(POSITION_PROFIT);
    }
    
    // Check if we still need recovery
    if(currentProfit <= RecoveryLossThreshold) {
        g_RecoveryStartLoss = currentProfit;
        OpenRecoveryOrder();
        return true;
    }
    
    return false;
}

int g_DailyRecoveryAttempts = 0;
datetime g_LastRecoveryResetDay = 0;

// Modified function to reset daily recovery attempts
void ResetDailyRecoveryAttempts() {
    datetime currentTime = TimeCurrent();
    MqlDateTime time_struct;
    TimeToStruct(currentTime, time_struct);
    
    // Check if we've moved to a new day
    if(g_LastRecoveryResetDay == 0 || time_struct.day != TimeToStruct(g_LastRecoveryResetDay, time_struct)) {
        g_DailyRecoveryAttempts = 0;
        g_LastRecoveryResetDay = currentTime;
   
    }
}


// Add this debug function to check current profit vs threshold
void LogRecoveryState() {
    if(!EnableRecoveryMode) {
        return;
    }
    
    double currentProfit = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        currentProfit += PositionGetDouble(POSITION_PROFIT);
    }
    


}
// Add these debug functions to help diagnose recovery issues

bool EmergencyCloseAllPositions(string reason) {
    double currentPrice = GetCleanPrice();



    // Count initial positions
    int initialCount = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        initialCount++;
    }
    
    if(initialCount == 0) {
        return true;
    }
    
    
 
    
    // Create a new CTrade object with maximum allowed deviations
    CTrade emergencyTrade;
    emergencyTrade.SetDeviationInPoints(10000); // Very high deviation
    emergencyTrade.SetExpertMagicNumber(10051988); // Same magic number
    
    // First attempt - try to close each position individually
    for(int attempt = 1; attempt <= 3; attempt++) {
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            double volume = PositionGetDouble(POSITION_VOLUME);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            string posDesc = EnumToString(posType) + " #" + IntegerToString(ticket) + " " + DoubleToString(volume, 2);
            
            
            if(emergencyTrade.PositionClose(ticket)) {
            } else {
                int error = GetLastError();
            }
            
            // Brief pause between operations
            Sleep(10);
        }
        
        // Check if any positions remain
        int remainingCount = 0;
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            remainingCount++;
        }
        
        if(remainingCount == 0) {
            return true;
        }
        
    }
    
    // Check final status
    int finalCount = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        finalCount++;
    }
    
    if(finalCount == 0) {
        return true;
    } else {
        return false;
    }
}
// Modify OnTick to include recovery logic
// Global variables to track weekend closure attempts
datetime g_LastWeekendClosureAttempt = 0;
int g_WeekendClosureAttempts = 0;
bool g_FridayClosureActivated = false;
// Enhanced high-precision anchor price calculation with multiple indicators

// Market condition enum for adaptive calculations
enum MarketConditionType {
    MARKET_NORMAL,
    MARKET_TRENDING,
    MARKET_RANGING,
    MARKET_VOLATILE
};

// Helper function to get market condition name as string
string GetMarketConditionName(MarketConditionType condition) {
    switch(condition) {
        case MARKET_TRENDING: return "Trending";
        case MARKET_RANGING: return "Ranging";
        case MARKET_VOLATILE: return "Volatile";
        default: return "Normal";
    }
}

// Determine current market condition using multiple indicators
MarketConditionType DetermineMarketCondition() {
    // ATR to measure volatility
    double atr = CalculateATR(PERIOD_H1, 14);
    double averageATR = CalculateAverageATR(PERIOD_H1, 14, 10); // Average of last 10 ATR values
    
    // ADX to measure trend strength
    double adx = CalculateADX(PERIOD_H1, 14);
    
    // Price in relation to Bollinger Bands
    double bbWidth = CalculateBBWidth(PERIOD_H1, 20, 2.0);
    double bbAvgWidth = CalculateAverageBBWidth(PERIOD_H1, 20, 2.0, 10);
    
    // Significant Volatility
    if(atr > averageATR * 1.5) {
        return MARKET_VOLATILE;
    }
    
    // Strong Trend
    if(adx > 25) {
        return MARKET_TRENDING;
    }
    
    // Ranging Market
    if(adx < 20 && bbWidth < bbAvgWidth * 0.9) {
        return MARKET_RANGING;
    }
    
    // Default
    return MARKET_NORMAL;
}

// Calculate MA-based component of anchor price
double CalculateMAComponent() {
    // Use both timeframes and different MA types for greater accuracy
    ENUM_TIMEFRAMES timeframes[] = {PERIOD_M15, PERIOD_M30, PERIOD_H1, PERIOD_H4, PERIOD_D1};
    int maPeriods[] = {20, 50, 100, 150, 200}; // Different MA periods
    
    // Different MA types for different market characteristics
    ENUM_MA_METHOD maTypes[] = {MODE_SMA, MODE_EMA, MODE_SMMA, MODE_LWMA};
    double maTypeWeights[] = {0.25, 0.35, 0.25, 0.15}; // EMA prioritized for responsiveness
    
    double timeframeWeights[] = {0.10, 0.15, 0.20, 0.25, 0.30}; // Priority to longer timeframes
    
    double combinedMA = 0;
    double totalWeight = 0;
    
    // For each timeframe
    for(int tf = 0; tf < ArraySize(timeframes); tf++) {
        double timeframeMA = 0;
        double timeframeTotalWeight = 0;
        
        // For each MA type
        for(int mt = 0; mt < ArraySize(maTypes); mt++) {
            // Use different price types for more complete view
            ENUM_APPLIED_PRICE priceTypes[] = {PRICE_CLOSE, PRICE_MEDIAN, PRICE_TYPICAL, PRICE_WEIGHTED};
            double priceTypeWeights[] = {0.4, 0.2, 0.2, 0.2}; // Priority to close price
            
            double maTypeValue = 0;
            double maTypeTotalWeight = 0;
            
            // For each price type
            for(int pt = 0; pt < ArraySize(priceTypes); pt++) {
                int maHandle = iMA(_Symbol, timeframes[tf], maPeriods[tf], 0, maTypes[mt], priceTypes[pt]);
                if(maHandle == INVALID_HANDLE) continue;
                
                double maValues[];
                ArraySetAsSeries(maValues, true);
                if(CopyBuffer(maHandle, 0, 0, 1, maValues) <= 0) {
                    IndicatorRelease(maHandle);
                    continue;
                }
                
                maTypeValue += maValues[0] * priceTypeWeights[pt];
                maTypeTotalWeight += priceTypeWeights[pt];
                
                IndicatorRelease(maHandle);
            }
            
            if(maTypeTotalWeight > 0) {
                timeframeMA += (maTypeValue / maTypeTotalWeight) * maTypeWeights[mt];
                timeframeTotalWeight += maTypeWeights[mt];
            }
        }
        
        if(timeframeTotalWeight > 0) {
            combinedMA += (timeframeMA / timeframeTotalWeight) * timeframeWeights[tf];
            totalWeight += timeframeWeights[tf];
        }
    }
    
    // If we couldn't calculate MA, return current price
    if(totalWeight == 0) {
        return SymbolInfoDouble(_Symbol, SYMBOL_BID);
    }
    
    return combinedMA / totalWeight;
}

// Calculate support/resistance component
double CalculateSupportResistanceComponent() {
    // Get historical data
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_H4, 0, 100, rates) < 100) {
        return SymbolInfoDouble(_Symbol, SYMBOL_BID);
    }
    
    // Find significant highs and lows (swing points)
    double significantLevels[20]; // Store up to 20 significant levels
    int levelCount = 0;
    
    // Identify swing highs and lows with confirmation
    for(int i = 5; i < 95; i++) {
        // Swing high with 5 candle confirmation
        if(rates[i].high > rates[i+1].high && rates[i].high > rates[i+2].high && 
           rates[i].high > rates[i+3].high && rates[i].high > rates[i+4].high &&
           rates[i].high > rates[i-1].high && rates[i].high > rates[i-2].high && 
           rates[i].high > rates[i-3].high && rates[i].high > rates[i-4].high) {
            if(levelCount < 20) {
                significantLevels[levelCount++] = rates[i].high;
            }
        }
        
        // Swing low with 5 candle confirmation
        if(rates[i].low < rates[i+1].low && rates[i].low < rates[i+2].low && 
           rates[i].low < rates[i+3].low && rates[i].low < rates[i+4].low &&
           rates[i].low < rates[i-1].low && rates[i].low < rates[i-2].low && 
           rates[i].low < rates[i-3].low && rates[i].low < rates[i-4].low) {
            if(levelCount < 20) {
                significantLevels[levelCount++] = rates[i].low;
            }
        }
    }
    
    // No levels found
    if(levelCount == 0) {
        return SymbolInfoDouble(_Symbol, SYMBOL_BID);
    }
    
    // Current price
    double currentPrice = GetCleanPrice();
    
    // Find the two closest levels (one above, one below)
    double closestAbove = DBL_MAX;
    double closestBelow = 0;
    
    for(int i = 0; i < levelCount; i++) {
        if(significantLevels[i] > currentPrice && significantLevels[i] < closestAbove) {
            closestAbove = significantLevels[i];
        }
        
        if(significantLevels[i] < currentPrice && significantLevels[i] > closestBelow) {
            closestBelow = significantLevels[i];
        }
    }
    
    // If we couldn't find levels on both sides
    if(closestAbove == DBL_MAX) closestAbove = currentPrice * 1.02;
    if(closestBelow == 0) closestBelow = currentPrice * 0.98;
    
    // Price position within the range (0.0 - 1.0)
    double rangePosition = (currentPrice - closestBelow) / (closestAbove - closestBelow);
    
    // Weighted average based on position in range
    return closestBelow * (1 - rangePosition) + closestAbove * rangePosition;
}

// Calculate Bollinger Bands component
double CalculateBollingerComponent() {
    ENUM_TIMEFRAMES timeframes[] = {PERIOD_M15, PERIOD_H1, PERIOD_H4, PERIOD_D1};
    double timeframeWeights[] = {0.1, 0.3, 0.3, 0.3};
    
    double currentPrice = GetCleanPrice();
    double bbComponent = 0;
    double totalWeight = 0;
    
    for(int tf = 0; tf < ArraySize(timeframes); tf++) {
        int bbHandle = iBands(_Symbol, timeframes[tf], 20, 0, 2.0, PRICE_CLOSE);
        if(bbHandle == INVALID_HANDLE) continue;
        
        double upperBand[], middleBand[], lowerBand[];
        ArraySetAsSeries(upperBand, true);
        ArraySetAsSeries(middleBand, true);
        ArraySetAsSeries(lowerBand, true);
        
        if(CopyBuffer(bbHandle, 1, 0, 1, upperBand) <= 0 ||
           CopyBuffer(bbHandle, 0, 0, 1, middleBand) <= 0 ||
           CopyBuffer(bbHandle, 2, 0, 1, lowerBand) <= 0) {
            IndicatorRelease(bbHandle);
            continue;
        }
        
        // Calculate where the price is relative to the bands (0 = lower band, 1 = upper band)
        double bandRange = upperBand[0] - lowerBand[0];
        double position = bandRange > 0 ? (currentPrice - lowerBand[0]) / bandRange : 0.5;
        
        // Adjust the position to get a better center price
        // When price is in middle of bands, use the middle band
        // When price is near edges, adjust toward the center
        double adjustedPosition = position;
        if(position < 0.3) adjustedPosition = 0.3 + (position * 0.66);
        else if(position > 0.7) adjustedPosition = 0.7 - ((1-position) * 0.66);
        
        // Calculate the adjusted price
        double adjustedPrice = lowerBand[0] + (bandRange * adjustedPosition);
        
        bbComponent += adjustedPrice * timeframeWeights[tf];
        totalWeight += timeframeWeights[tf];
        
        IndicatorRelease(bbHandle);
    }
    
    return totalWeight > 0 ? bbComponent / totalWeight : currentPrice;
}

// Calculate VWAP component 
double CalculateVWAPComponent() {
    // Use multi-timeframe approach to get a robust VWAP estimate
    ENUM_TIMEFRAMES timeframes[] = {PERIOD_M15, PERIOD_H1, PERIOD_H4};
    double weights[] = {0.3, 0.4, 0.3};
    
    MqlRates ratesM15[], ratesH1[], ratesH4[];
    ArraySetAsSeries(ratesM15, true);
    ArraySetAsSeries(ratesH1, true);
    ArraySetAsSeries(ratesH4, true);
    
    int copyM15 = CopyRates(_Symbol, PERIOD_M15, 0, 96, ratesM15);    // Last 24 hours
    int copyH1 = CopyRates(_Symbol, PERIOD_H1, 0, 24, ratesH1);       // Last 24 hours
    int copyH4 = CopyRates(_Symbol, PERIOD_H4, 0, 30, ratesH4);       // Last 5 days
    
    if(copyM15 <= 0 && copyH1 <= 0 && copyH4 <= 0) {
        return SymbolInfoDouble(_Symbol, SYMBOL_BID);
    }
    
    double vwap = 0;
    double totalWeight = 0;
    
    // Calculate VWAP for M15
    if(copyM15 > 0) {
        double cumulativeTP = 0;
        double cumulativeVol = 0;
        
        for(int i = 0; i < copyM15; i++) {
            double typicalPrice = (ratesM15[i].high + ratesM15[i].low + ratesM15[i].close) / 3;
            double volume = ratesM15[i].tick_volume;
            
            cumulativeTP += typicalPrice * volume;
            cumulativeVol += volume;
        }
        
        if(cumulativeVol > 0) {
            vwap += (cumulativeTP / cumulativeVol) * weights[0];
            totalWeight += weights[0];
        }
    }
    
    // Calculate VWAP for H1
    if(copyH1 > 0) {
        double cumulativeTP = 0;
        double cumulativeVol = 0;
        
        for(int i = 0; i < copyH1; i++) {
            double typicalPrice = (ratesH1[i].high + ratesH1[i].low + ratesH1[i].close) / 3;
            double volume = ratesH1[i].tick_volume;
            
            cumulativeTP += typicalPrice * volume;
            cumulativeVol += volume;
        }
        
        if(cumulativeVol > 0) {
            vwap += (cumulativeTP / cumulativeVol) * weights[1];
            totalWeight += weights[1];
        }
    }
    
    // Calculate VWAP for H4
    if(copyH4 > 0) {
        double cumulativeTP = 0;
        double cumulativeVol = 0;
        
        for(int i = 0; i < copyH4; i++) {
            double typicalPrice = (ratesH4[i].high + ratesH4[i].low + ratesH4[i].close) / 3;
            double volume = ratesH4[i].tick_volume;
            
            cumulativeTP += typicalPrice * volume;
            cumulativeVol += volume;
        }
        
        if(cumulativeVol > 0) {
            vwap += (cumulativeTP / cumulativeVol) * weights[2];
            totalWeight += weights[2];
        }
    }
    
    return totalWeight > 0 ? vwap / totalWeight : SymbolInfoDouble(_Symbol, SYMBOL_BID);
}

// Calculate ATR for volatility estimation
double CalculateATR(ENUM_TIMEFRAMES timeframe, int period) {
    int atrHandle = iATR(_Symbol, timeframe, period);
    if(atrHandle == INVALID_HANDLE) return 0;
    
    double atrValues[];
    ArraySetAsSeries(atrValues, true);
    if(CopyBuffer(atrHandle, 0, 0, 1, atrValues) <= 0) {
        IndicatorRelease(atrHandle);
        return 0;
    }
    
    double atrValue = atrValues[0];
    IndicatorRelease(atrHandle);
    
    return atrValue;
}

// Calculate average ATR over multiple periods
double CalculateAverageATR(ENUM_TIMEFRAMES timeframe, int period, int averagePeriods) {
    int atrHandle = iATR(_Symbol, timeframe, period);
    if(atrHandle == INVALID_HANDLE) return 0;
    
    double atrValues[];
    ArraySetAsSeries(atrValues, true);
    if(CopyBuffer(atrHandle, 0, 0, averagePeriods, atrValues) <= 0) {
        IndicatorRelease(atrHandle);
        return 0;
    }
    
    double avgATR = 0;
    for(int i = 0; i < averagePeriods; i++) {
        avgATR += atrValues[i];
    }
    
    IndicatorRelease(atrHandle);
    
    return avgATR / averagePeriods;
}

// Calculate ADX for trend strength
double CalculateADX(ENUM_TIMEFRAMES timeframe, int period) {
    int adxHandle = iADX(_Symbol, timeframe, period);
    if(adxHandle == INVALID_HANDLE) return 0;
    
    double adxValues[];
    ArraySetAsSeries(adxValues, true);
    if(CopyBuffer(adxHandle, 0, 0, 1, adxValues) <= 0) {
        IndicatorRelease(adxHandle);
        return 0;
    }
    
    double adxValue = adxValues[0];
    IndicatorRelease(adxHandle);
    
    return adxValue;
}

// Calculate Bollinger Band width
double CalculateBBWidth(ENUM_TIMEFRAMES timeframe, int period, double deviation) {
    int bbHandle = iBands(_Symbol, timeframe, period, 0, deviation, PRICE_CLOSE);
    if(bbHandle == INVALID_HANDLE) return 0;
    
    double upperBand[], lowerBand[];
    ArraySetAsSeries(upperBand, true);
    ArraySetAsSeries(lowerBand, true);
    
    if(CopyBuffer(bbHandle, 1, 0, 1, upperBand) <= 0 || 
       CopyBuffer(bbHandle, 2, 0, 1, lowerBand) <= 0) {
        IndicatorRelease(bbHandle);
        return 0;
    }
    
    double bbWidth = (upperBand[0] - lowerBand[0]) / lowerBand[0] * 100; // Width as percentage
    IndicatorRelease(bbHandle);
    
    return bbWidth;
}

// Calculate average Bollinger Band width
double CalculateAverageBBWidth(ENUM_TIMEFRAMES timeframe, int period, double deviation, int averagePeriods) {
    int bbHandle = iBands(_Symbol, timeframe, period, 0, deviation, PRICE_CLOSE);
    if(bbHandle == INVALID_HANDLE) return 0;
    
    double upperBand[], lowerBand[];
    ArraySetAsSeries(upperBand, true);
    ArraySetAsSeries(lowerBand, true);
    
    if(CopyBuffer(bbHandle, 1, 0, averagePeriods, upperBand) <= 0 || 
       CopyBuffer(bbHandle, 2, 0, averagePeriods, lowerBand) <= 0) {
        IndicatorRelease(bbHandle);
        return 0;
    }
    
    double avgWidth = 0;
    for(int i = 0; i < averagePeriods; i++) {
        avgWidth += (upperBand[i] - lowerBand[i]) / lowerBand[i] * 100;
    }
    
    IndicatorRelease(bbHandle);
    
    return avgWidth / averagePeriods;
}



void OnTimer() {
    // Ch? g?i hàm ?óng l?nh cu?i tu?n khi tính n?ng ???c b?t
    if(EnableWeekendProtection) {
        ForceCloseRecoveryForWeekend();
    }
}
// Add at the top with other global variables
int g_TimerHandle = 0;

void ForceCloseRecoveryForWeekend() {
    // Thêm ki?m tra tính n?ng b?o v? cu?i tu?n ? ?ây
    if(!EnableWeekendProtection) return;
    
    // Check if it's Friday
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
    if(time_struct.day_of_week != FRIDAY) {
        g_FridayClosureActivated = false; // Reset flag on non-Friday
        return;
    }
    
    // Limit check frequency to once per minute and track attempts
    datetime currentTime = TimeCurrent();
    if(currentTime - g_LastWeekendClosureAttempt < 60) return;
    g_LastWeekendClosureAttempt = currentTime;
    g_WeekendClosureAttempts++;
    
    int hoursUntilCutoff = FridayLastTradeHour - time_struct.hour;
    
 
    
    // First check if we have any recovery orders
    bool hasRecoveryOrders = false;
    int recoveryOrderCount = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
            hasRecoveryOrders = true;
            recoveryOrderCount++;
        }
    }
    
    
    // If no recovery orders or not within time window, exit
    if(!hasRecoveryOrders) return;
    
    // Once we enter the cutoff window, set the flag to ensure we keep trying
    if(hoursUntilCutoff <= 2) {
        g_FridayClosureActivated = true;
    }
    
    // If not activated or not in time window, exit
    if(!g_FridayClosureActivated) return;
    
 
    // Force close recovery orders with maximum priority
    CTrade closeOperation;
    closeOperation.SetDeviationInPoints(9999); // Maximum allowed slippage
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
            
            if(closeOperation.PositionClose(ticket)) {
            } else {
                int errorCode = GetLastError();
             
            }
        }
    }
    
    // Disable recovery mode regardless of success
    if(g_InRecoveryMode) {
        g_InRecoveryMode = false;
        g_RecoveryOrderTicket = 0;
        g_RecoveryOrderOpenTime = 0;
        g_RecoveryAttempts = 0;
    }
    
    // Check if any recovery orders remain
    int remainingRecoveryOrders = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
            remainingRecoveryOrders++;
        }
    }
    
    
    // Now close ALL positions if we're very close to cutoff
    if(hoursUntilCutoff <= 1) {
        
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            if(closeOperation.PositionClose(ticket)) {
            } else {
                int errorCode = GetLastError();
     
            }
        }
    }
}





// Simplified NY Session Protection Check
bool IsNYSessionProtectionActive() {
    if(!EnableNYSessionProtection) return false;
    
    MqlDateTime current_struct;
    TimeToStruct(TimeCurrent(), current_struct);
    
    // Check if current hour is NY session start hour
    if(current_struct.hour == NYSessionStartHour) {
        // Check if we're within the protection period
        if(current_struct.min < NYSessionVolatilityPeriod) {
            return true;
        }
    }
    
    return false;
}
// Enhanced version of IsNewTradingAllowed to include month-end protection
bool IsNewTradingAllowed() {
    // Check month-end trading first
   
    if(IsNYSessionProtectionActive()) {
        return false;
    }
    if(IsMonthEndTrading()) {
        return false;
    }
    
 
    
    // Check NY session volatility
    if(IsNYOpenVolatile()) {
        return false;
    }
    
    // Check news protection
    if(IsWithinNewsTime()) {
        return false;
    }
    
    // Check spread
    if(!IsSpreadOK()) {
        return false;
    }
    
    // Check order limits
    if(!CanOpenMoreOrdersInPeriod()) {
        return false;
    }
    
    // Check time remaining in period
    if(!HasEnoughTimeForNewOrder()) {
        return false;
    }
    
    return true;
}


// Add function to get detailed time information (useful for debugging)
string GetDetailedTimeInfo() {
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
    int daysInMonth = GetDaysInMonth(time_struct.year, time_struct.mon);
    
    string info = StringFormat(
        "Time Analysis:\n"
        "Date: %d/%d/%d\n"
        "Time: %02d:%02d\n"
        "Day of Month: %d/%d\n"
        "Days until month end: %d\n"
        "Trading Protection Status:\n"
        "Month-End Protection: %s\n"
        "Weekend Protection: %s",
        time_struct.day, time_struct.mon, time_struct.year,
        time_struct.hour, time_struct.min,
        time_struct.day, daysInMonth,
        daysInMonth - time_struct.day,
        IsMonthEndTrading() ? "Active" : "Inactive",
        IsWeekendTrading() ? "Active" : "Inactive"
    );
    
    return info;
}


double CalculateWeeklyRangeAverage() {
   MqlRates rates[];
   ArraySetAsSeries(rates, true);
   
   if(CopyRates(_Symbol, PERIOD_D1, 0, 5, rates) < 5) {
       return 0;
   }
   
   double totalRange = 0;
   for(int i = 0; i < 5; i++) {
       totalRange += (rates[i].high + rates[i].low) / 2;
   }
   
   return NormalizeDouble(totalRange / 5, _Digits);
}

bool HasInitialDCAOrders() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket)) {
            string comment = PositionGetString(POSITION_COMMENT);
            // If order is not a trend order and has "L1" in comment (indicating first order)
            if(StringFind(comment, "Trend Follow") < 0 && StringFind(comment, "L1") >= 0) {
         
                return true;
            }
        }
    }
    return false;
}



// Function to check for active trend orders


// Updated trend prediction structure without RSI
struct TrendPrediction {
    bool strongTrend;
    bool isUptrend;
    string reason;
};

TrendPrediction PredictTrend() {
    TrendPrediction prediction;
    prediction.strongTrend = false;
    prediction.isUptrend = false;
    
    // Get price data from multiple timeframes
    MqlRates ratesD1[], ratesH4[], ratesH1[], ratesM15[];
    ArraySetAsSeries(ratesD1, true);
    ArraySetAsSeries(ratesH4, true);
    ArraySetAsSeries(ratesH1, true);
    ArraySetAsSeries(ratesM15, true);
    
    if(CopyRates(_Symbol, PERIOD_D1, 0, 3, ratesD1) < 3) return prediction;
    if(CopyRates(_Symbol, PERIOD_H4, 0, 4, ratesH4) < 4) return prediction;
    if(CopyRates(_Symbol, PERIOD_H1, 0, 6, ratesH1) < 6) return prediction;
    if(CopyRates(_Symbol, PERIOD_M15, 0, 8, ratesM15) < 8) return prediction;

    double currentPrice = GetCleanPrice();
    
    // 1. Analyze price movement patterns
    bool h4Bullish = ratesH4[0].close > ratesH4[1].close && 
                     ratesH4[1].close > ratesH4[2].close &&
                     ratesH4[2].close > ratesH4[3].close;
                     
    bool h4Bearish = ratesH4[0].close < ratesH4[1].close && 
                     ratesH4[1].close < ratesH4[2].close &&
                     ratesH4[2].close < ratesH4[3].close;
    
    // 2. Calculate momentum across timeframes
    double h4Momentum = (ratesH4[0].close - ratesH4[3].close) / _Point;
    double h1Momentum = (ratesH1[0].close - ratesH1[5].close) / _Point;
    double m15Momentum = (ratesM15[0].close - ratesM15[7].close) / _Point;
    
    // 3. Calculate average volatility
    double h4Volatility = 0;
    double h1Volatility = 0;
    
    for(int i = 0; i < 3; i++) {
        h4Volatility += MathAbs(ratesH4[i].high - ratesH4[i].low);
        h1Volatility += MathAbs(ratesH1[i].high - ratesH1[i].low);
    }
    h4Volatility = h4Volatility / (3 * _Point);
    h1Volatility = h1Volatility / (3 * _Point);
    
    // 4. Check for strong movement with volume confirmation
    bool strongH4Movement = MathAbs(h4Momentum) > h4Volatility * 1.5;
    bool strongH1Movement = MathAbs(h1Momentum) > h1Volatility * 1.5;
    
    // 5. Check for breakout from daily range
    double d1Range = MathAbs(ratesD1[1].high - ratesD1[1].low) / _Point;
    bool breakoutUp = currentPrice > ratesD1[1].high + (d1Range * 0.1);
    bool breakoutDown = currentPrice < ratesD1[1].low - (d1Range * 0.1);
    
    // 6. Multi-timeframe trend alignment check
    bool alignedBullish = h4Momentum > 0 && h1Momentum > 0 && m15Momentum > 0;
    bool alignedBearish = h4Momentum < 0 && h1Momentum < 0 && m15Momentum < 0;
    
    // Combine all factors for trend prediction
    if(h4Bullish && alignedBullish && (strongH4Movement || breakoutUp)) {
        prediction.strongTrend = true;
        prediction.isUptrend = true;
        prediction.reason = "Strong bullish trend: H4 pattern with aligned momentum and " + 
                          (breakoutUp ? "breakout" : "strong movement");
    }
    else if(h4Bearish && alignedBearish && (strongH4Movement || breakoutDown)) {
        prediction.strongTrend = true;
        prediction.isUptrend = false;
        prediction.reason = "Strong bearish trend: H4 pattern with aligned momentum and " + 
                          (breakoutDown ? "breakout" : "strong movement");
    }
    
  
    return prediction;
}

// Updated trend following management function

// Add this global variable at the top with other globals
bool g_InHedgeCycle = false;


// Modified OpenHedgeOrder function




// Add this function to handle hedge cycle completion




// Helper function to calculate optimal lot size for trend orders
double CalculateTrendLotSize(double baseSize, double priceDistance) {
    double multiplier = 1.0;
    double pipDistance = priceDistance / _Point;
    
    // Progressive lot sizing based on distance
    if(pipDistance >= TrendLotLevel3) {
        multiplier = TrendLotMultiplier3;
    }
    else if(pipDistance >= TrendLotLevel2) {
        multiplier = TrendLotMultiplier2;
    }
    else if(pipDistance >= TrendLotLevel1) {
        multiplier = TrendLotMultiplier1;
    }
    
    // Add market condition adjustments
    double marketRange = CalculateMarketRange();
    if(marketRange > g_CurrentAIThreshold * 1.5) {
        multiplier = 1; // Reduce size in high volatility
    }
    else if(marketRange > g_CurrentAIThreshold) {
        multiplier = 1; // Slightly reduce size in moderate volatility
    }
    
    double calculatedLot = NormalizeDouble(baseSize * multiplier, 2);

          
    return calculatedLot;
}

double CalculateMarketMomentum() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    int copied = CopyRates(_Symbol, g_DynamicTimeframe , 0, 10, rates);
    
    if(copied < 10) return 0;
    
    double priceMomentum = 0;
    double volumeMomentum = 0;
    
    for(int i = 0; i < 9; i++) {
        double priceChange = rates[i].close - rates[i+1].close;
        priceMomentum += priceChange;
        
        double volumeChange = (double)rates[i].tick_volume - (double)rates[i+1].tick_volume;
        volumeMomentum += volumeChange;
    }
    
    double normalizedVolumeMomentum = volumeMomentum / 1000;
    double combinedMomentum = (priceMomentum + normalizedVolumeMomentum * 0.3) / _Point;
    
    return combinedMomentum;
}




double CalculateDailyProfit() {
    double profit = 0;
    datetime today = StringToTime(TimeToString(TimeCurrent(), TIME_DATE));
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol) {
            profit += PositionGetDouble(POSITION_PROFIT);
        }
    }
    
    // Add closed positions profit for today
    HistorySelect(today, TimeCurrent());
    for(int i = HistoryDealsTotal() - 1; i >= 0; i--) {
        ulong ticket = HistoryDealGetTicket(i);
        if(HistoryDealGetString(ticket, DEAL_SYMBOL) == _Symbol) {
            profit += HistoryDealGetDouble(ticket, DEAL_PROFIT);
        }
    }
    
    return profit;
}


// Add function to count active cycles
void CountActiveCycles() {
   g_ActiveBuyCycles = 0;
   g_ActiveSellCycles = 0;
   double lastBuyPrice = 0;
   double lastSellPrice = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol) {
         ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
         double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
         
         if(posType == POSITION_TYPE_BUY) {
            if(MathAbs(openPrice - lastBuyPrice) > DCADistance * _Point || lastBuyPrice == 0) {
               g_ActiveBuyCycles++;
               lastBuyPrice = openPrice;
            }
         } else {
            if(MathAbs(openPrice - lastSellPrice) > DCADistance * _Point || lastSellPrice == 0) {
               g_ActiveSellCycles++;
               lastSellPrice = openPrice;
            }
         }
      }
   }
}


// Thêm hàm m?i ?? xác ??nh ?i?m vào hedging t?i ?u
double GetOptimalHedgingEntry(ENUM_POSITION_TYPE posType) {
   double optimalEntry = 0;
   double totalVolume = 0;
   double weightedSum = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && 
         PositionGetString(POSITION_SYMBOL) == _Symbol &&
         PositionGetInteger(POSITION_TYPE) == posType) {
         double volume = PositionGetDouble(POSITION_VOLUME);
         double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
         weightedSum += openPrice * volume;
         totalVolume += volume;
      }
   }
   
   if(totalVolume > 0) {
      optimalEntry = NormalizeDouble(weightedSum / totalVolume, _Digits);
   }
   
   return optimalEntry;
}

// Hàm ki?m tra th?i gian giao d?ch h?p l?
// S?a ??i hàm IsValidTradingTime ?? tr? v? tr?ng thái
bool IsValidTradingTime(bool &isAfterHours) {
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    int currentHour = time_struct.hour;
   
    isAfterHours = !(currentHour >= Period1StartHour && currentHour < Period1EndHour) &&
                   !(currentHour >= Period2StartHour && currentHour < Period2EndHour) &&
                   !(currentHour >= Period3StartHour && currentHour < Period3EndHour);
   
    return true;  // Always allow trading
}

bool IsSpreadOK() {
   long currentSpread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
   if(currentSpread > MaxSpread) {
      return false;
   }
   return true;
}

//+------------------------------------------------------------------+
//| Check if AI connection is OK (for testing AI integration)       |
//+------------------------------------------------------------------+
bool IsAIConnectionOK() {
   // N?u không yêu c?u AI → cho phép trading
   if(!RequireAIConnection) {
      return true;
   }

   // N?u yêu c?u AI → ki?m tra tr?ng thái
   if(!g_APIAvailable) {
      static datetime lastWarning = 0;
      // Log warning m?i 5 phút
      if(TimeCurrent() - lastWarning > 300) {
         lastWarning = TimeCurrent();
      }
      return false;
   }

   return true;
}


// Check for existing trend orders
bool HasTrendOrders() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket)) {
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Trend Follow") >= 0) {
                return true;
            }
        }
    }
    return false;
}

// Modified GetAdjustedDCADistance function




// Helper function to check if we should handle hedging
bool ShouldCheckHedging() {
    // Don't check hedging if there are no open positions
    if(PositionsTotal() == 0) return false;
    
    // Find the first order
    bool hasFirstOrder = false;
    ulong firstOrderTicket = 0;
    double firstOrderLoss = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "|| L1") >= 0) {
            hasFirstOrder = true;
            firstOrderTicket = ticket;
            firstOrderLoss = PositionGetDouble(POSITION_PROFIT);
            break;
        }
    }
    
    // Only check hedging if we have a first order and it's in loss
    if(hasFirstOrder) {
        return firstOrderLoss < 0;
    }
    
    return false;
}



// Enhanced version of ShouldStartHedging
bool ShouldStartHedging(double currentPrice) {
    if(!EnableHedging) return false;
    
    // Track losses and trapped positions
    double buyPnL = 0;
    double sellPnL = 0;
    int trappedBuyOrders = 0;
    int trappedSellOrders = 0;
    double highestBuyPrice = 0;
    double lowestSellPrice = DBL_MAX;
    bool hasBuyTrend = false;
    bool hasSellTrend = false;
    
    // Analyze existing positions
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double profit = PositionGetDouble(POSITION_PROFIT);
        string comment = PositionGetString(POSITION_COMMENT);

        // Track trend orders
        if(StringFind(comment, "Trend Follow Buy") >= 0) hasBuyTrend = true;
        if(StringFind(comment, "Trend Follow Sell") >= 0) hasSellTrend = true;

        if(posType == POSITION_TYPE_BUY) {
            buyPnL += profit;
            if(openPrice > highestBuyPrice) highestBuyPrice = openPrice;
            // Consider a buy order trapped if price is significantly below entry
            if(currentPrice < openPrice - HedgingThreshold * _Point) trappedBuyOrders++;
        } else {
            sellPnL += profit;
            if(openPrice < lowestSellPrice) lowestSellPrice = openPrice;
            // Consider a sell order trapped if price is significantly above entry
            if(currentPrice > openPrice + HedgingThreshold * _Point) trappedSellOrders++;
        }
    }
    
    // Get market momentum for confirmation
    double momentum = CalculateMarketMomentum();
    
    // Enhanced hedging conditions
    bool shouldHedgeBuy = false;
    bool shouldHedgeSell = false;
    
    // Check for trapped buy positions
    if(trappedBuyOrders >= 5 && !hasSellTrend && buyPnL < -HedgingThreshold) {
        if(currentPrice < highestBuyPrice - HedgingThreshold * _Point && momentum < -MomentumEntryThreshold) {
            shouldHedgeSell = true;
        }
    }
    
    // Check for trapped sell positions
    if(trappedSellOrders >= 5 && !hasBuyTrend && sellPnL < -HedgingThreshold) {
        if(currentPrice > lowestSellPrice + HedgingThreshold * _Point && momentum > MomentumEntryThreshold) {
            shouldHedgeBuy = true;
        }
    }
    

    
    return (shouldHedgeBuy || shouldHedgeSell);
}



// Ki?m tra có l?nh trend ho?c initial order không
bool HasTrendOrInitialOrders() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Trend") >= 0 || StringFind(comment, "L1") >= 0) {
            return true;
        }
    }
    return false;
}

// ?ánh giá tr?ng thái v? th?
struct PositionStatus {
    double totalProfit;
    double maxDrawdown;
    int orderCount;
    datetime oldestOrderTime;
    bool needsHedge;
};

// Structure to track market conditions
struct MarketCondition {
    bool isVolatile;
    bool isReversal;
    double momentum;
    double priceDistance;
    bool isTrendBreaking;
    string reason;
};

// Phân tích ?i?u ki?n th? tr??ng
MarketCondition AnalyzeMarketCondition(ENUM_POSITION_TYPE posType) {
    MarketCondition condition;
    condition.isVolatile = false;
    condition.isReversal = false;
    condition.momentum = 0;
    condition.priceDistance = 0;
    condition.isTrendBreaking = false;
    condition.reason = "";
    
    double currentPrice = GetCleanPrice();
    
    // Tính toán momentum và volatility
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    
    if(CopyRates(_Symbol, PERIOD_M5, 0, 6, rates) < 6) return condition;
    
    // Tính toán ?? bi?n ??ng
    double volatility = 0;
    for(int i = 0; i < 5; i++) {
        volatility += MathAbs(rates[i].high - rates[i].low);
    }
    volatility = volatility / 5 / _Point;
    
    // Tính momentum
    condition.momentum = (rates[0].close - rates[5].close) / _Point;
    
    // Ki?m tra reversal pattern
    bool priceAction = (posType == POSITION_TYPE_BUY) ? 
                      (rates[0].close < rates[1].low && rates[1].close < rates[2].low) :
                      (rates[0].close > rates[1].high && rates[1].close > rates[2].high);
                      
    // Ki?m tra m?c ?? bi?n ??ng
    condition.isVolatile = volatility > g_CurrentAIThreshold/2;
    
    // Ki?m tra ??o chi?u
    if(posType == POSITION_TYPE_BUY) {
        condition.isReversal = condition.momentum < -MomentumEntryThreshold*0.5 && priceAction;
    } else {
        condition.isReversal = condition.momentum > MomentumEntryThreshold*0.5 && priceAction;
    }
    
    // Ki?m tra break trend
    condition.isTrendBreaking = false;
    if(posType == POSITION_TYPE_BUY && currentPrice < rates[5].low) {
        condition.isTrendBreaking = true;
        condition.reason = "Price broke below support";
    }
    else if(posType == POSITION_TYPE_SELL && currentPrice > rates[5].high) {
        condition.isTrendBreaking = true;
        condition.reason = "Price broke above resistance";
    }
    
    return condition;
}

// C?p nh?t logic ?ánh giá v? th?
PositionStatus EvaluatePositionStatus(ENUM_POSITION_TYPE posType) {
    PositionStatus status;
    status.totalProfit = 0;
    status.maxDrawdown = 0;
    status.orderCount = 0;
    status.oldestOrderTime = TimeCurrent();
    status.needsHedge = false;

    double totalVolume = 0;
    double weightedPrice = 0;
    
    // Phân tích các l?nh hi?n t?i
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) continue;
        
        double profit = PositionGetDouble(POSITION_PROFIT);
        double volume = PositionGetDouble(POSITION_VOLUME);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        
        status.totalProfit += profit;
        totalVolume += volume;
        weightedPrice += openPrice * volume;
        status.orderCount++;
        
        if(openTime < status.oldestOrderTime) {
            status.oldestOrderTime = openTime;
        }
    }
    
    if(totalVolume > 0) {
        double avgPrice = weightedPrice / totalVolume;
        double currentPrice = GetCleanPrice();
        status.maxDrawdown = MathAbs(currentPrice - avgPrice) / _Point;
    }
    
    // Ki?m tra ?i?u ki?n th? tr??ng
    MarketCondition marketCondition = AnalyzeMarketCondition(posType);
    
    // ?i?u ki?n kích ho?t hedge nhanh
    bool quickHedgeNeeded = false;
    string hedgeReason = "";
    
    // 1. ?i?u ki?n v? l?nh và th?i gian
    bool basicCondition = status.orderCount >= 6 && // Gi?m s? l??ng l?nh t?i thi?u xu?ng 2
                         TimeCurrent() - status.oldestOrderTime > 5 * 60; // Gi?m th?i gian xu?ng 15 phút
    
    // 2. ?i?u ki?n v? th? tr??ng
    if(marketCondition.isReversal && marketCondition.isVolatile) {
        quickHedgeNeeded = true;
        hedgeReason = "Market reversal with high volatility";
    }
    
    if(marketCondition.isTrendBreaking && status.maxDrawdown > HedgingThreshold*0.7) {
        quickHedgeNeeded = true;
        hedgeReason = "Trend break with significant drawdown";
    }
    
    if(MathAbs(marketCondition.momentum) > MomentumEntryThreshold*2) {
        quickHedgeNeeded = true;
        hedgeReason = "Strong adverse momentum";
    }
    
    // 3. ?i?u ki?n v? l?
    bool profitCondition = status.totalProfit < -100|| // Gi?m ng??ng l? xu?ng
                          status.maxDrawdown > HedgingThreshold*0.8; // Gi?m ng??ng drawdown
    
    status.needsHedge = (basicCondition && (quickHedgeNeeded || profitCondition));
    
    if(status.needsHedge) {
     
    }
    
    return status;
}



// Modified GetLatestCyclePrice function to include cycleId
double GetLatestCyclePrice(ENUM_POSITION_TYPE posType, int cycleId) {
    double latestPrice = 0;
    datetime latestTime = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(ExtractCycleId(comment) != cycleId) continue;
        
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        if(openTime > latestTime) {
            latestTime = openTime;
            latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        }
    }
    
    return latestPrice;
}

// Modified OpenOrder function with additional checks
// Add these globals at the top with other globals
int g_CurrentPeriodOrders = 0;
int g_CurrentPeriodLimit = 0;
datetime g_LastPeriodCheck = 0;
void GetCurrentPeriodInfo(int &maxOrders, string &periodName) {
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    int currentHour = time_struct.hour;
    
    if(currentHour >= Period1StartHour && currentHour < Period1EndHour) {
        maxOrders = Period1MaxOrders;
        periodName = "Period 1";
    }
    else if(currentHour >= Period2StartHour && currentHour < Period2EndHour) {
        maxOrders = Period2MaxOrders;
        periodName = "Period 2";
    }
    else if(currentHour >= Period3StartHour && currentHour < Period3EndHour) {
        maxOrders = Period3MaxOrders;
        periodName = "Period 3";
    }
    else {
        maxOrders = OutsideHoursMaxOrders;
        periodName = "Outside Hours";
    }
}


// Enhanced order counting function
void UpdatePeriodOrderCount() {
    datetime currentTime = TimeCurrent();
    
    // Only update once per minute
    if(currentTime - g_LastPeriodCheck < 60) return;
    
    g_CurrentPeriodOrders = 0;
    string periodName;
    GetCurrentPeriodInfo(g_CurrentPeriodLimit, periodName);
    
    // Count regular orders in current period
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        // Skip hedge and trend orders
        if(StringFind(comment, "Hedge") >= 0 || StringFind(comment, "Trend") >= 0) continue;
        
        g_CurrentPeriodOrders++;
    }
    
    g_LastPeriodCheck = currentTime;
    

}
// Structure to track period order stats
struct PeriodStats {
    int regularOrders;
    int hedgeOrders;
    int trendOrders;
    datetime lastUpdate;
};

// Global variable for period tracking
PeriodStats g_PeriodStats = {0, 0, 0, 0};


// Helper function to check new order against period limit
bool CheckNewOrderAllowed(string orderComment) {
    // Hedge and trend orders bypass period limits
    if(StringFind(orderComment, "Hedge") >= 0 || 
       StringFind(orderComment, "Trend Follow") >= 0) {
        return true;
    }
    
    // Regular orders must respect period limits
    return CanOpenMoreOrdersInPeriod();
}
// Helper function to get the current period details


// Global variables to track period orders
string g_CurrentPeriodName = "";
datetime g_PeriodStartTime = 0;
int g_PeriodOrdersOpened = 0;

// Function to update and enforce period order limits
// Global variables for period tracking
int g_CurrentPeriodMaxOrders = 0;
int g_CurrentPeriodOrderCount = 0;
int g_LastPeriodHour = -1;
int g_LastPeriodDay = -1;



bool EnforcePeriodOrderLimits() {
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    int currentHour = time_struct.hour;
    int currentDay = time_struct.day;
    
    // Check if we've entered a new period or day
    bool newPeriod = false;
    if(currentDay != g_LastPeriodDay || currentHour != g_LastPeriodHour) {
        newPeriod = true;
        g_LastPeriodHour = currentHour;
        g_LastPeriodDay = currentDay;
    }
    
    // Determine current period max orders
    if(currentHour >= Period1StartHour && currentHour < Period1EndHour) {
        g_CurrentPeriodMaxOrders = Period1MaxOrders;
    }
    else if(currentHour >= Period2StartHour && currentHour < Period2EndHour) {
        g_CurrentPeriodMaxOrders = Period2MaxOrders;
    }
    else if(currentHour >= Period3StartHour && currentHour < Period3EndHour) {
        g_CurrentPeriodMaxOrders = Period3MaxOrders;
    }
    else {
        g_CurrentPeriodMaxOrders = OutsideHoursMaxOrders;
    }
    
    // Count ALL orders including recovery orders
    int regularOrderCount = 0;
    int hedgeOrderCount = 0;
    int trendOrderCount = 0;
    int zoneOrderCount = 0;
    int recoveryOrderCount = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        
        // Count recovery orders separately but include them
        if(StringFind(comment, "Recovery") >= 0) {
            recoveryOrderCount++;
        }
        else if(StringFind(comment, "Hedge") >= 0) {
            hedgeOrderCount++;
        } 
        else if(StringFind(comment, "Trend") >= 0) {
            trendOrderCount++;
        }
        else if(StringFind(comment, "Zone") >= 0) {
            zoneOrderCount++;
        }
        else {
            regularOrderCount++;
        }
    }
    
    // INCLUDE ALL ORDER TYPES in the total count
    int totalOrderCount = regularOrderCount + hedgeOrderCount + trendOrderCount + zoneOrderCount + recoveryOrderCount;
    g_CurrentPeriodOrderCount = totalOrderCount;
    
    // Get period name for debugging
    string periodName = (currentHour >= Period1StartHour && currentHour < Period1EndHour) ? "Period 1" :
                        (currentHour >= Period2StartHour && currentHour < Period2EndHour) ? "Period 2" :
                        (currentHour >= Period3StartHour && currentHour < Period3EndHour) ? "Period 3" : 
                        "Outside Hours";
    
    // Enhanced logging with recovery orders
  
    
    // STRICT ENFORCEMENT: Include recovery orders in check
    if(totalOrderCount >= g_CurrentPeriodMaxOrders) {

        return false;
    }
    
    return true;
}

// Replace the old function
bool CanOpenMoreOrdersInPeriod() {
    return EnforcePeriodOrderLimits();
}

// Modified CanOpenMoreOrdersInPeriod function to check only regular cycle orders

// Function to count orders by type and cycle
void CountOrdersByType(int &regularOrders, int &hedgeOrders, int &trendOrders) {
    regularOrders = 0;
    hedgeOrders = 0;
    trendOrders = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) {
            hedgeOrders++;
        }
        else if(StringFind(comment, "Trend Follow") >= 0) {
            trendOrders++;
        }
        else {
            regularOrders++;
        }
    }
}



// Modified function to check if specific order type can be opened
bool CanOpenOrderType(ENUM_ORDER_TYPE orderType, string orderComment) {
    // For hedge orders, check only hedge-specific conditions
    if(StringFind(orderComment, "Hedge") >= 0) {
        return true;  // Allow hedge orders regardless of period limits
    }
    
    // For trend orders, apply trend-specific conditions
    if(StringFind(orderComment, "Trend Follow") >= 0) {
        return IsTrendModeValid();  // Check only trend conditions
    }
    
    // For regular orders, check period limits
    return CanOpenMoreOrdersInPeriod();
}






// New function to calculate hedge TP
double CalculateHedgeTP(ENUM_ORDER_TYPE orderType, double entryPrice) {
    double baseTP = 1; // Use trend TP as base
    
    // Calculate volatility-adjusted TP
    double marketRange = CalculateMarketRange();
    double momentum = MathAbs(CalculateMarketMomentum());
    
    // Adjust TP based on market conditions
    if(marketRange > g_CurrentAIThreshold * 1.5) {
        baseTP *= 1.5; // Increase TP in high volatility
    }
    else if(marketRange > g_CurrentAIThreshold) {
        baseTP *= 1.2; // Slightly increase TP in moderate volatility
    }
    
    // Further adjust based on momentum
    if(momentum > MomentumEntryThreshold * 2) {
        baseTP *= 1.3; // Increase TP with strong momentum
    }
    
    // Calculate final TP level
    double takeProfit = orderType == ORDER_TYPE_BUY ?
        NormalizeDouble(entryPrice + baseTP * _Point, _Digits) :
        NormalizeDouble(entryPrice - baseTP * _Point, _Digits);
        
  
          
    return takeProfit;
}




// Helper function to count hedge orders
int CountHedgeOrders(ENUM_POSITION_TYPE posType) {
    int count = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) {
            count++;
        }
    }
    return count;
}
// Modified HandleHedgeDCA to include period extra distance

// New helper function to adjust extra distance based on market conditions
double AdjustExtraDistance(double baseExtra, double marketRange) {
    double adjusted = baseExtra;
    
    if(marketRange > g_CurrentAIThreshold * 1.5) {
        // Very high volatility - increase extra distance significantly
        adjusted *= HighRangeMultiplier * 1.5;
    }
    else if(marketRange > g_CurrentAIThreshold) {
        // High volatility - increase extra distance
        adjusted *= HighRangeMultiplier;
    }
    else {
        // Normal volatility - use normal multiplier
        adjusted *= NormalRangeMultiplier;
    }
    
    // Ensure minimum extra distance
    adjusted = MathMax(adjusted, MinimumOrderDistance);
    
    return adjusted;
}


// Global function to get custom hedge DCA gap
double GetCustomHedgeDCAGap(int orderNumber) {
    switch(orderNumber) {
        case 1: return FirstOrderGap;
        case 2: return SecondOrderGap;
        case 3: return ThirdOrderGap;
        case 4: return FourthOrderGap;
        case 5: return FifthOrderGap;
        case 6: return SixthOrderGap;
        case 7: return SeventhOrderGap;
        case 8: return EighthOrderGap;
        case 9: return NinthOrderGap;
        case 10: return TenthOrderGap;
        case 11: return EleventhOrderGap;
        case 12: return TwelfthOrderGap;
        case 13: return ThirteenthOrderGap;
        case 14: return FourteenthOrderGap;
        case 15: return FifteenthOrderGap;
        case 16: return SixteenthOrderGap;
        default: return DCADistance;
    }
}


// Helper function to get latest hedge order price
double GetLatestHedgeOrderPrice(ENUM_POSITION_TYPE posType) {
    double latestPrice = 0;
    datetime latestTime = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) {
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            if(openTime > latestTime) {
                latestTime = openTime;
                latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            }
        }
    }
    
    return latestPrice;
}


// Hàm l?y thông tin l?nh hedge
bool GetLatestHedgeInfo(ENUM_POSITION_TYPE &hedgeType, double &hedgePrice) {
    datetime latestTime = 0;
    bool found = false;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) {
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            if(openTime > latestTime) {
                latestTime = openTime;
                hedgeType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                hedgePrice = PositionGetDouble(POSITION_PRICE_OPEN);
                found = true;
            }
        }
    }
    
    return found;
}

// Modified GetSafeHedgeDCADistance function with enhanced distance calculation
double GetSafeHedgeDCADistance() {
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    int currentHour = time_struct.hour;
    
    // Get base distance according to current period
    double baseDistance;
    if(currentHour >= Period1StartHour && currentHour < Period1EndHour) {
        baseDistance = Period1FirstEntryDistance;
    }
    else if(currentHour >= Period2StartHour && currentHour < Period2EndHour) {
        baseDistance = Period2FirstEntryDistance;
    }
    else if(currentHour >= Period3StartHour && currentHour < Period3EndHour) {
        baseDistance = Period3FirstEntryDistance;
    }
    else {
        baseDistance = OutsideHoursFirstEntryDistance;
    }
    
    // Factor in market conditions
    double marketRange = CalculateMarketRange();
    double momentum = MathAbs(CalculateMarketMomentum());
    
    // Adjust distance based on market conditions
    if(marketRange > g_CurrentAIThreshold * 1.5) {
        baseDistance = FirstOrderGap * 1; // Double distance in very high volatility
    }
    else if(marketRange > g_CurrentAIThreshold) {
        baseDistance = FirstOrderGap * 1; // Increase distance in high volatility
    }
    
    // Ensure minimum safe distance
    baseDistance = MathMax(baseDistance, MinimumOrderDistance * 1);

    
    return baseDistance;
}



// New function to count total orders including hedge orders
int CountTotalOrdersByType(ENUM_POSITION_TYPE posType) {
    int count = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        count++;
    }
    return count;
}




void AnalyzeTrappedPositions(double currentPrice, bool &hasTrappedBuys, bool &hasTrappedSells) {
    hasTrappedBuys = false;
    hasTrappedSells = false;
    int trappedBuyOrders = 0;
    int trappedSellOrders = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        
        if(posType == POSITION_TYPE_BUY) {
            if(currentPrice < openPrice - HedgingThreshold * _Point) trappedBuyOrders++;
        } else {
            if(currentPrice > openPrice + HedgingThreshold * _Point) trappedSellOrders++;
        }
    }
    
    hasTrappedBuys = (trappedBuyOrders >0 );
    hasTrappedSells = (trappedSellOrders>0);
    
 
}

void ManageExistingHedge(double currentPrice, ENUM_POSITION_TYPE hedgeType) {
    // Calculate profit/loss of original positions and hedge
    double originalPnL = 0;
    double hedgePnL = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        double profit = PositionGetDouble(POSITION_PROFIT);
        
        if(StringFind(comment, "Hedge") >= 0) {
            hedgePnL += profit;
        } else {
            originalPnL += profit;
        }
    }
    
  
}

// Add these global variables at the top with other globals
bool g_SLRecoveryEnabled = true;                // Toggle for SL recovery feature
bool g_InSLRecoveryMode = false;               // Tracks if we're in SL recovery mode
int g_SLRecoveryCycle = 0;                     // ID of cycle that triggered SL
ENUM_POSITION_TYPE g_SLRecoveryType;           // Type of positions (buy/sell) in recovery
double g_SLRecoveryStartPrice = 0;             // Price at which SL was triggered
double g_SLRecoveryStartVolume = 0;            // Total volume of cycle that hit SL
datetime g_SLRecoveryStartTime = 0;            // Time when SL recovery started
int g_SLRecoveryOrderCount = 0;                // Count of orders opened for recovery

bool IsWeekendProtectionForRecovery() {
    if(!EnableWeekendProtection) return false;
    
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
    // Ki?m tra n?u là th? 6 sau gi? gi?i h?n
    if(time_struct.day_of_week == FRIDAY && time_struct.hour >= FridayLastTradeHour - 2) {
        return true;
    }
    
    // Th? 7 và Ch? nh?t
    if(time_struct.day_of_week == SATURDAY || time_struct.day_of_week == SUNDAY) {
        return true;
    }
    
    // Th? 2 tr??c gi? giao d?ch
    if(time_struct.day_of_week == MONDAY && time_struct.hour < MondayFirstTradeHour) {
        return true;
    }
    
    return false;
}

bool CloseAllPositionsEarly(int minOrderCount, double minProfit) {
    // ??m t?ng s? l?nh và tính t?ng l?i nhu?n
    int totalPositions = 0;
    double totalProfit = 0;
    
    // M?ng l?u các ticket ?? ?óng
    ulong ticketsToClose[500]; // ?? l?n ?? l?u t?t c? ticket
    int ticketCount = 0;
    
    // Duy?t qua t?t c? các v? th?
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        totalPositions++;
        totalProfit += PositionGetDouble(POSITION_PROFIT);
        
        // L?u ticket ?? ?óng sau khi ki?m tra ?i?u ki?n
        ticketsToClose[ticketCount++] = ticket;
    }
    
    // Ki?m tra ?i?u ki?n ?óng l?nh s?m
    bool shouldClose = (totalPositions >= minOrderCount && totalProfit >= minProfit);
    
    if(shouldClose) {
       
        // ?óng t?t c? các v? th? ?ã l?u
        int closedCount = 0;
        for(int i = 0; i < ticketCount; i++) {
            if(trade.PositionClose(ticketsToClose[i])) {
                closedCount++;
            } else {
            }
        }
        
        
        // ??t l?i các bi?n theo dõi chu k?
        g_WaitingForNewEntry = true;
        g_HasActiveBuyCycle = false;
        g_HasActiveSellCycle = false;
        g_LastCycleCompleteTime = TimeCurrent();
        g_LastCycleCompletePrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        
        return true;
    }
    
    return false;
}
// FIX: TP CALCULATION SỬ DỤNG ĐÚNG INPUT PARAMETERS



// Cải tiến hàm GetOrderTP để handle trường hợp orderNumber > 10

// Sửa OpenOrder để đảm bảo dùng đúng TP calculation
bool OpenOrder(ENUM_ORDER_TYPE orderType, double lotSize, double currentPrice, string customComment = "") {
    if(!EnforcePeriodOrderLimits()) return false;
    if(!CanOpenMoreOrdersInPeriod()) return false;
    
    ENUM_POSITION_TYPE posType = (orderType == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
    int totalOrders = (posType == POSITION_TYPE_BUY) ? g_TotalOrders_Buy : g_TotalOrders_Sell;
    
    bool isZoneOrder = (StringFind(customComment, "Zone") >= 0);
    
    // Comment
    string comment;
    if(customComment != "") {
        comment = customComment;
    } else {
        string baseComment = (orderType == ORDER_TYPE_BUY) ? BuyComment : SellComment;
        comment = StringFormat("%s %d || L%d", 
                             baseComment,
                             (posType == POSITION_TYPE_BUY) ? g_ActiveBuyCycles : g_ActiveSellCycles,
                             totalOrders + 1);
                             
    }
    
    // Mở lệnh without TP/SL
    bool result = trade.PositionOpen(_Symbol, orderType, lotSize, currentPrice, 0, 0, comment);

    if(result) {
        UpdatePeriodOrderCount();
    }

    return result;
}

//+------------------------------------------------------------------+
//| Mở lệnh dựa trên AI Imbalance                                     |
//| - Imbalance > 0: Mở lệnh BUY                                      |
//| - Imbalance < 0: Mở lệnh SELL                                     |
//| - Imbalance = 0: Không mở lệnh                                    |
//+------------------------------------------------------------------+
bool OpenOrderByAIImbalance(double lotSize = 0, string customComment = "") {
    // CRITICAL: Kiểm tra flag để ngăn mở trùng lặp trong cùng 1 tick
    if(g_AI_OrderPending) {
        return false;
    }

    // SCALPING: Kiểm tra cooldown để tránh mở nhiều lệnh liên tục
    datetime currentTime = TimeCurrent();
    if(currentTime - g_LastAIOrderTime < AI_ORDER_COOLDOWN) {
        return false;
    }

    // Kiểm tra kết nối AI
    if(!g_APIAvailable) {
        return false;
    }

    // Đặt flag để ngăn các lần gọi khác trong cùng tick
    g_AI_OrderPending = true;

    // Lấy imbalance từ AI
    double imbalance = GetAIImbalance();

    // Log imbalance value

    // SCALPING: Kiểm tra ngưỡng tối thiểu cho scalping
    if(MathAbs(imbalance) < AI_MIN_IMBALANCE_THRESHOLD) {
        g_AI_OrderPending = false; // Reset flag
        return false;
    }

    // Xác định loại lệnh dựa trên DẤU của imbalance
    // CHỈ KIỂM TRA DẤU (+/-), KHÔNG QUAN TÂM GIÁ TRỊ
    ENUM_ORDER_TYPE orderType;
    string direction;

    if(imbalance > 0) {
        // Imbalance dương (+) → BUY (ví dụ: +0.200 → BUY)
        orderType = ORDER_TYPE_BUY;
        direction = "BUY";
    } else if(imbalance < 0) {
        // Imbalance âm (-) → SELL (ví dụ: -0.150 → SELL)
        orderType = ORDER_TYPE_SELL;
        direction = "SELL";
    } else {
        // Imbalance = 0 → Không có tín hiệu
        g_AI_OrderPending = false; // Reset flag
        return false;
    }

    // SCALPING: Kiểm tra xung đột - tránh mở nhiều lệnh cùng chiều
    if(orderType == ORDER_TYPE_BUY && g_TotalOrders_Buy > 0) {
        g_AI_OrderPending = false; // Reset flag
        return false;
    }
    if(orderType == ORDER_TYPE_SELL && g_TotalOrders_Sell > 0) {
        g_AI_OrderPending = false; // Reset flag
        return false;
    }

    // Lấy giá hiện tại
    double currentPrice = GetCleanPrice();

    // Xác định lot size
    double finalLotSize = (lotSize > 0) ? lotSize : defaultFixLength;

    // Tạo comment
    string comment;
    if(customComment != "") {
        comment = StringFormat("%s (AI-Imb:%.2f)", customComment, imbalance);
    } else {
        comment = StringFormat("AI-%s (Imb:%.2f)", direction, imbalance);
    }



    // Kiểm tra điều kiện cơ bản
    if(!EnforcePeriodOrderLimits()) {
        g_AI_OrderPending = false; // Reset flag
        return false;
    }

    if(!CanOpenMoreOrdersInPeriod()) {
        g_AI_OrderPending = false; // Reset flag
        return false;
    }

    // SCALPING: Tính TP cố định 400 points cho scalping nhanh
    ENUM_POSITION_TYPE posType = (orderType == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
    int totalOrders = (posType == POSITION_TYPE_BUY) ? g_TotalOrders_Buy : g_TotalOrders_Sell;
    const int SCALPING_TP_POINTS = DefaultTP; // TP cố định cho scalping
    double takeProfit;
    if(orderType == ORDER_TYPE_BUY) {
        takeProfit = NormalizeDouble(currentPrice + DefaultTP * _Point, _Digits);
    } else {
        takeProfit = NormalizeDouble(currentPrice - DefaultTP * _Point, _Digits);
    }

    // Tính SL - Ưu tiên AI SL nếu được bật
    double stopLoss = CalculateAISL(orderType, currentPrice);

  
    // Kiểm tra TP hợp lệ
    if(!IsValidTPLevel(currentPrice, takeProfit, posType)) {
        g_AI_OrderPending = false; // Reset flag
        return false;
    }

    // Mở lệnh without TP/SL
    bool result = trade.PositionOpen(_Symbol, orderType, finalLotSize, currentPrice, 0, 0, comment);

    if(result) {
   

        // SCALPING: Cập nhật thời gian mở lệnh AI để kích hoạt cooldown
        g_LastAIOrderTime = TimeCurrent();

        // Reset flag sau khi mở lệnh thành công
        g_AI_OrderPending = false;

        // Cập nhật counter
        UpdatePeriodOrderCount();

        // Cập nhật combined TP nếu cần
        int newOrderCount = totalOrders + 1;
        if(newOrderCount >= CombinedTPLevel) {
            // UpdateCombinedTP(posType, false);
        }
    } else {
  
        g_AI_OrderPending = false;
    }

    return result;
}

// 2. Add a function to check if any cycle has hit stop loss
bool CheckForStopLossHit() {
    static datetime lastSLCheck = 0;
    datetime currentTime = TimeCurrent();
    
    // Only check every 5 seconds to reduce processing load
    if(currentTime - lastSLCheck < 5) {
        return false;
    }
    lastSLCheck = currentTime;
    
    // Skip check if we're already in SL recovery mode
    if(g_InSLRecoveryMode) {
        return false;
    }
    
    // Get current market price
    double currentPrice = GetCleanPrice();
    
    // Check buy cycles for SL breach
    for(int i = 0; i < ArraySize(g_BuyCycleStats); i++) {
        if(!g_BuyCycleStats[i].isActive) continue; // Skip inactive cycles
        
        int cycleId = g_BuyCycleStats[i].cycleId;
        
        // Check if any position in this cycle has SL set
        for(int j = PositionsTotal() - 1; j >= 0; j--) {
            ulong ticket = PositionGetTicket(j);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_BUY) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            if(ExtractCycleId(comment) != cycleId) continue;
            
            double stopLoss = PositionGetDouble(POSITION_SL);
            
            // If no SL is set, skip
            if(stopLoss == 0) continue;
            
            // Check if SL is breached
            if(currentPrice <= stopLoss) {
           // Calculate total volume of the cycle for recovery sizing
                double totalVolume = GetCycleTotalVolume(POSITION_TYPE_BUY, cycleId);
                
                // Activate SL recovery mode
                ActivateSLRecoveryMode(POSITION_TYPE_BUY, cycleId, totalVolume, currentPrice);
                return true;
            }
        }
    }
    
    // Check sell cycles for SL breach
    for(int i = 0; i < ArraySize(g_SellCycleStats); i++) {
        if(!g_SellCycleStats[i].isActive) continue; // Skip inactive cycles
        
        int cycleId = g_SellCycleStats[i].cycleId;
        
        // Check if any position in this cycle has SL set
        for(int j = PositionsTotal() - 1; j >= 0; j--) {
            ulong ticket = PositionGetTicket(j);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_SELL) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            if(ExtractCycleId(comment) != cycleId) continue;
            
            double stopLoss = PositionGetDouble(POSITION_SL);
            
            // If no SL is set, skip
            if(stopLoss == 0) continue;
            
            // Check if SL is breached
            if(currentPrice >= stopLoss) {
             
                // Calculate total volume of the cycle for recovery sizing
                double totalVolume = GetCycleTotalVolume(POSITION_TYPE_SELL, cycleId);
                
                // Activate SL recovery mode
                ActivateSLRecoveryMode(POSITION_TYPE_SELL, cycleId, totalVolume, currentPrice);
                return true;
            }
        }
    }
    
    return false;
}

// 3. Helper function to get total volume of a cycle
double GetCycleTotalVolume(ENUM_POSITION_TYPE posType, int cycleId) {
    double totalVolume = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(ExtractCycleId(comment) == cycleId) {
            totalVolume += PositionGetDouble(POSITION_VOLUME);
        }
    }
    
    return totalVolume;
}

// 4. Function to activate SL recovery mode
void ActivateSLRecoveryMode(ENUM_POSITION_TYPE posType, int cycleId, double volume, double currentPrice) {
    // Skip if feature not enabled

    g_InSLRecoveryMode = true;
    g_SLRecoveryCycle = cycleId;
    g_SLRecoveryType = posType;
    g_SLRecoveryStartPrice = currentPrice;
    g_SLRecoveryStartVolume = volume;
    g_SLRecoveryStartTime = TimeCurrent();
    g_SLRecoveryOrderCount = 0;

    
    // Open first recovery order
    OpenSLRecoveryOrder();
}

// 5. Function to open SL recovery order
bool OpenSLRecoveryOrder() {
    // Verify period limits
    if(!EnforcePeriodOrderLimits()) {
        return false;
    }
    
    // Calculate appropriate position size for recovery (opposite to the original position)
    double recoveryVolume = CalculateSLRecoveryVolume();
    
    // Determine order type (opposite of original)
    ENUM_ORDER_TYPE recoveryOrderType;
    if(g_SLRecoveryType == POSITION_TYPE_BUY) {
        recoveryOrderType = ORDER_TYPE_SELL;
    } else {
        recoveryOrderType = ORDER_TYPE_BUY;
    }
    
    // Get current price
    double currentPrice = GetCleanPrice();
    
    // Create comment for recovery order
    string comment = StringFormat("SL Recovery %s #%d",
                                EnumToString(recoveryOrderType),
                                g_SLRecoveryOrderCount + 1);
    
    // Calculate take profit based on weighted average
    double takeProfit = CalculateSLRecoveryTP(recoveryOrderType, currentPrice);

    // Calculate SL for recovery order
    double stopLoss = CalculateAISL(recoveryOrderType, currentPrice);

    // Open the recovery order without TP/SL
    trade.SetExpertMagicNumber(10051990); // Use a special magic number for SL recovery
    bool result = trade.PositionOpen(_Symbol, recoveryOrderType, recoveryVolume, currentPrice, 0, 0, comment);
    trade.SetExpertMagicNumber(10051988); // Reset to standard magic

    if(result) {
        g_SLRecoveryOrderCount++;
        
 
    } else {
    }
    
    return result;
}

// 6. Calculate appropriate volume for SL recovery
double CalculateSLRecoveryVolume() {
    // Base recovery volume on the original cycle volume
    double baseVolume = g_SLRecoveryStartVolume;
    
    // First recovery order should be 1-1.5x the original volume
    if(g_SLRecoveryOrderCount == 0) {
        return NormalizeLotSize(baseVolume * 1.2);
    }
    
    // For subsequent orders, increase volume based on order count
    double volumeMultiplier;
    switch(g_SLRecoveryOrderCount) {
        case 1: volumeMultiplier = 1.3; break;
        case 2: volumeMultiplier = 1.5; break;
        case 3: volumeMultiplier = 1.7; break;
        case 4: volumeMultiplier = 2.0; break;
        default: volumeMultiplier = 2.2; break;
    }
    
    // Calculate and normalize
    double volume = baseVolume * volumeMultiplier;
    return NormalizeLotSize(volume);
}

// 7. Calculate TP for SL recovery orders
double CalculateSLRecoveryTP(ENUM_ORDER_TYPE orderType, double entryPrice) {
    // Use a more aggressive TP for recovery orders
    // double tpPoints = GetPeriodTP() // DISABLED: Using virtual TP/SL * 0.7; // 70% of normal TP
    
    return 1;
}

// 8. Function to handle DCA for SL recovery
void HandleSLRecoveryDCA() {
    if(!g_InSLRecoveryMode) return;
    
    // Throttle checks
    static datetime lastSLDCACheck = 0;
    datetime currentTime = TimeCurrent();
    if(currentTime - lastSLDCACheck < 60) return; // Check once per minute
    lastSLDCACheck = currentTime;
    
    // Get current price
    double currentPrice = GetCleanPrice();
    
    // Get latest recovery order price
    double latestRecoveryPrice = GetLatestSLRecoveryOrderPrice();
    if(latestRecoveryPrice == 0) return;
    
    // Determine the DCA direction based on recovery type
    bool validDcaDirection = false;
    ENUM_ORDER_TYPE recoveryOrderType;
    
    if(g_SLRecoveryType == POSITION_TYPE_BUY) {
        // If original was BUY, recovery is SELL
        recoveryOrderType = ORDER_TYPE_SELL;
        validDcaDirection = (currentPrice > latestRecoveryPrice); // For SELL DCA, price must rise
    } else {
        // If original was SELL, recovery is BUY
        recoveryOrderType = ORDER_TYPE_BUY;
        validDcaDirection = (currentPrice < latestRecoveryPrice); // For BUY DCA, price must fall
    }
    
    // Check if DCA direction is valid
    if(!validDcaDirection) return;
    
    // Calculate required distance for DCA
    double requiredDistance = GetDCADistanceForSLRecovery(g_SLRecoveryOrderCount + 1);
    double currentDistance = MathAbs(currentPrice - latestRecoveryPrice) / _Point;
    
  
    
    // Open DCA if distance is sufficient
    if(currentDistance >= requiredDistance) {
        // Check minimum distance from all orders
        if(CheckMinimumDistanceBetweenOrders(currentPrice, 
                                           recoveryOrderType == ORDER_TYPE_BUY ? 
                                           POSITION_TYPE_BUY : POSITION_TYPE_SELL)) {
            OpenSLRecoveryOrder();
        }
    }
}

// 9. Helper function to get distance for SL recovery DCA
double GetDCADistanceForSLRecovery(int orderNumber) {
    // Use similar distances as regular DCA but adjusted for recovery
    double baseDistance = GetStandardDCADistance(orderNumber);
    
    // Adjust distance based on market conditions
    MarketConditionType marketCondition = DetermineMarketCondition();
    
    switch(marketCondition) {
        case MARKET_VOLATILE:
            baseDistance *= 1.2; // Increase distances in volatile markets
            break;
        case MARKET_TRENDING:
            baseDistance *= 1.1; // Slightly increase in trending markets
            break;
        case MARKET_RANGING:
            baseDistance *= 0.9; // Slightly decrease in ranging markets
            break;
        default:
            break;
    }
    
    return MathMax(baseDistance, MinimumOrderDistance);
}

// 10. Helper function to get latest SL recovery order price
double GetLatestSLRecoveryOrderPrice() {
    double latestPrice = 0;
    datetime latestTime = 0;
    
    // Recovery order type is opposite to the SL recovery type
    ENUM_POSITION_TYPE recoveryPosType = (g_SLRecoveryType == POSITION_TYPE_BUY) ? 
                                       POSITION_TYPE_SELL : POSITION_TYPE_BUY;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != recoveryPosType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "SL Recovery") < 0) continue;
        
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        if(openTime > latestTime) {
            latestTime = openTime;
            latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        }
    }
    
    return latestPrice;
}

// 11. Function to check if recovery achieved target
bool CheckSLRecoveryTarget() {
    if(!g_InSLRecoveryMode) return false;
    
    // Calculate total profit across original cycle and recovery orders
    double totalProfit = 0;
    int cyclePosCount = 0;
    int recoveryPosCount = 0;
    
    // Recovery position type (opposite of original)
    ENUM_POSITION_TYPE recoveryPosType = (g_SLRecoveryType == POSITION_TYPE_BUY) ? 
                                       POSITION_TYPE_SELL : POSITION_TYPE_BUY;
    
    // Check all positions
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double profit = PositionGetDouble(POSITION_PROFIT);
        totalProfit += profit;
        
        if(posType == g_SLRecoveryType) {
            string comment = PositionGetString(POSITION_COMMENT);
            if(ExtractCycleId(comment) == g_SLRecoveryCycle) {
                cyclePosCount++;
            }
        } else if(posType == recoveryPosType) {
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "SL Recovery") >= 0) {
                recoveryPosCount++;
            }
        }
    }
    
    // Check if profit is positive or if we've been in recovery too long
    bool profitTarget = (totalProfit > 0);
    
    int recoveryAgeMinutes = (int)(TimeCurrent() - g_SLRecoveryStartTime) / 60;
    bool timeLimit = (recoveryAgeMinutes > 360); // 6 hours timeout
    
    if(profitTarget || timeLimit) {
        // Log reason for exiting recovery
      
        
        // Close all positions (original cycle and recovery)
        CloseAllPositions("SL Recovery " + (profitTarget ? "Target Reached" : "Timeout"));
        
        // Reset SL recovery mode
        g_InSLRecoveryMode = false;
        g_SLRecoveryCycle = 0;
        g_SLRecoveryStartPrice = 0;
        g_SLRecoveryStartVolume = 0;
        g_SLRecoveryStartTime = 0;
        g_SLRecoveryOrderCount = 0;
        
        return true;
    }
    
    return false;
}

// 12. Add this to OnTick to process SL checks and recovery management
void ManageSLRecovery() {
    // First check if any cycle has hit stop loss
    if(!g_InSLRecoveryMode) {
        CheckForStopLossHit();
    }
    
    // If in SL recovery mode, manage the recovery process
    if(g_InSLRecoveryMode) {
        // Check if recovery target is reached
        if(CheckSLRecoveryTarget()) {
            return; // Exit if positions were closed due to target reached
        }
        
        // Handle DCA for recovery orders
        HandleSLRecoveryDCA();
    }
}

// 13. Modify CloseAllPositions to respect SL recovery mode
void CloseAllPositions(string reason = "") {
    // If we're in SL recovery mode and no specific reason is given, skip
    if(g_InSLRecoveryMode && reason == "") {
        return;
    }
    
    // If a specific reason is provided, proceed with closing
    if(reason != "")
    
    int closedCount = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        if(trade.PositionClose(ticket)) {
        } else {
        }
    }
    
    
    // Reset relevant flags
    if(g_InSLRecoveryMode) {
        g_InSLRecoveryMode = false;
        g_SLRecoveryCycle = 0;
        g_SLRecoveryStartPrice = 0;
        g_SLRecoveryStartVolume = 0;
        g_SLRecoveryStartTime = 0;
        g_SLRecoveryOrderCount = 0;
    }
}


// 1. Cycle tracking structure
struct CycleStats {
    int cycleId;
    double peakProfit;
    double currentProfit;
    int orderCount;
    datetime startTime;
    bool hasReachedTP;
    bool isActive;
};

// Global arrays to track cycle statistics
CycleStats g_BuyCycleStats[];
CycleStats g_SellCycleStats[];

// 2. Modified HandleCycleCompletion with proper array handling

// 3. Function to find cycle stats index
int FindCycleStatsIndex(int cycleId, ENUM_POSITION_TYPE posType) {
    if(posType == POSITION_TYPE_BUY) {
        for(int i = 0; i < ArraySize(g_BuyCycleStats); i++) {
            if(g_BuyCycleStats[i].cycleId == cycleId) {
                return i;
            }
        }
    } else {
        for(int i = 0; i < ArraySize(g_SellCycleStats); i++) {
            if(g_SellCycleStats[i].cycleId == cycleId) {
                return i;
            }
        }
    }
    return -1;
}
// Modified ShouldCloseCycle function with better TP protection




// 4. Function to add new cycle stats
int AddNewCycleStats(int cycleId, ENUM_POSITION_TYPE posType) {
    if(posType == POSITION_TYPE_BUY) {
        int newIndex = ArraySize(g_BuyCycleStats);
        ArrayResize(g_BuyCycleStats, newIndex + 1);
        g_BuyCycleStats[newIndex].cycleId = cycleId;
        g_BuyCycleStats[newIndex].peakProfit = 0;
        g_BuyCycleStats[newIndex].currentProfit = 0;
        g_BuyCycleStats[newIndex].orderCount = 0;
        g_BuyCycleStats[newIndex].startTime = TimeCurrent();
        g_BuyCycleStats[newIndex].hasReachedTP = false;
        g_BuyCycleStats[newIndex].isActive = true;
        return newIndex;
    } else {
        int newIndex = ArraySize(g_SellCycleStats);
        ArrayResize(g_SellCycleStats, newIndex + 1);
        g_SellCycleStats[newIndex].cycleId = cycleId;
        g_SellCycleStats[newIndex].peakProfit = 0;
        g_SellCycleStats[newIndex].currentProfit = 0;
        g_SellCycleStats[newIndex].orderCount = 0;
        g_SellCycleStats[newIndex].startTime = TimeCurrent();
        g_SellCycleStats[newIndex].hasReachedTP = false;
        g_SellCycleStats[newIndex].isActive = true;
        return newIndex;
    }
}
// Modified HandleCycleCompletion function with anchor price adjustment

// 5. Modified UpdateCycleStatistics
void UpdateCycleStatistics() {
    // Reset arrays
    ArrayResize(g_BuyCycleStats, 0);
    ArrayResize(g_SellCycleStats, 0);
    
    // First pass: Initialize cycles
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        int cycleId = ExtractCycleId(comment);
        
        int statsIndex = FindCycleStatsIndex(cycleId, posType);
        if(statsIndex == -1) {
            AddNewCycleStats(cycleId, posType);
        }
    }
    
    // Second pass: Update statistics
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        int cycleId = ExtractCycleId(comment);
        double profit = PositionGetDouble(POSITION_PROFIT);
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        
        int statsIndex = FindCycleStatsIndex(cycleId, posType);
        if(statsIndex != -1) {
            if(posType == POSITION_TYPE_BUY) {
                g_BuyCycleStats[statsIndex].orderCount++;
                g_BuyCycleStats[statsIndex].currentProfit += profit;
                if(profit > g_BuyCycleStats[statsIndex].peakProfit) {
                    g_BuyCycleStats[statsIndex].peakProfit = profit;
                }
                if(openTime < g_BuyCycleStats[statsIndex].startTime) {
                    g_BuyCycleStats[statsIndex].startTime = openTime;
                }
            } else {
                g_SellCycleStats[statsIndex].orderCount++;
                g_SellCycleStats[statsIndex].currentProfit += profit;
                if(profit > g_SellCycleStats[statsIndex].peakProfit) {
                    g_SellCycleStats[statsIndex].peakProfit = profit;
                }
                if(openTime < g_SellCycleStats[statsIndex].startTime) {
                    g_SellCycleStats[statsIndex].startTime = openTime;
                }
            }
        }
    }
}



void CountOrdersAndCalculateAverages() {
   g_TotalOrders_Buy = 0;
   g_TotalOrders_Sell = 0;
   g_TotalVolume_Buy = 0;
   g_TotalVolume_Sell = 0;
   double weightedSum_Buy = 0;
   double weightedSum_Sell = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol) {
         double volume = PositionGetDouble(POSITION_VOLUME);
         double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
         ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
         
         // Store exact volumes without intermediate normalization
         if(posType == POSITION_TYPE_BUY) {
            g_TotalOrders_Buy++;
            g_TotalVolume_Buy += volume;
            weightedSum_Buy += openPrice * volume;
         } else {
            g_TotalOrders_Sell++;
            g_TotalVolume_Sell += volume;
            weightedSum_Sell += openPrice * volume;
         }
      }
   }
   
   // Apply final normalization only once at the end
   g_TotalVolume_Buy = NormalizeDouble(g_TotalVolume_Buy, 2);
   g_TotalVolume_Sell = NormalizeDouble(g_TotalVolume_Sell, 2);
   
   // Calculate average prices with improved precision
   if(g_TotalVolume_Buy > 0) {
      g_AveragePrice_Buy = NormalizeDouble(weightedSum_Buy / g_TotalVolume_Buy, _Digits);
   }
   if(g_TotalVolume_Sell > 0) {
      g_AveragePrice_Sell = NormalizeDouble(weightedSum_Sell / g_TotalVolume_Sell, _Digits);
   }
}




bool IsValidTPLevel(double price, double tp, ENUM_POSITION_TYPE posType) {
    double minDistance = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
    long spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
    double requiredDistance = (minDistance + spread + 10) * _Point;  // Add buffer

    if(posType == POSITION_TYPE_BUY) {
        return tp > price && (tp - price) >= requiredDistance;
    } else {
        return tp < price && (price - tp) >= requiredDistance;
    }
}


// Modified ModifyOrdersTP to prevent rapid updates


double g_CurrentFirstOrderGap = FirstOrderGap;    // Dynamic gaps that will be adjusted
double g_CurrentSecondOrderGap = SecondOrderGap;
double g_CurrentThirdOrderGap = ThirdOrderGap;
double g_CurrentFourthOrderGap = FourthOrderGap;
double g_CurrentFifthOrderGap = FifthOrderGap;
int g_CompletedCycles = 0;                        // Track number of completed cycles
datetime g_LastCycleCompletionTime = 0;           // Track when last cycle was completed





// 1. First fix the GetAdjustedDCADistance function

// Add these global variables at the top with other globals
datetime g_LastSinglePositionCheck = 0;
datetime g_SinglePositionOpenTime = 0;

// Add this function to check and close single remaining positions
void CheckAndCloseSinglePosition() {
    // Only check once per day
    datetime currentTime = TimeCurrent();
    MqlDateTime current_struct;
    TimeToStruct(currentTime, current_struct);
    
    // Check if we're in a new day
    if(current_struct.day == g_LastDayChecked) return;
    
    // Count total positions
    int totalPositions = 0;
    ulong singleTicket = 0;
    datetime positionOpenTime = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        totalPositions++;
        if(totalPositions == 1) {
            singleTicket = ticket;
            positionOpenTime = (datetime)PositionGetInteger(POSITION_TIME);
        }
    }
    
    // If only one position remains and it's from a previous day
    if(totalPositions == 1 && singleTicket > 0) {
        MqlDateTime pos_struct;
        TimeToStruct(positionOpenTime, pos_struct);
        
        // Check if position was opened on a previous day
        if(pos_struct.day != current_struct.day) {
            double profit = PositionGetDouble(POSITION_PROFIT);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
 
            // Close the position
            if(trade.PositionClose(singleTicket)) {
                
                // Reset relevant tracking variables
                if(posType == POSITION_TYPE_BUY) {
                    g_HasActiveBuyCycle = false;
                    g_ActiveBuyCycles = 0;
                } else {
                    g_HasActiveSellCycle = false;
                    g_ActiveSellCycles = 0;
                }
                
                g_WaitingForNewEntry = true;
                g_LastCycleCompleteTime = currentTime;
                g_LastCycleCompletePrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            } else {
            }
        }
    }
}

// Modify the UpdateMarketInfo function to include the new check
void UpdateMarketInfo() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    int copied = CopyRates(_Symbol, PERIOD_D1, 0, 1, rates);
    
    if(copied == 1) {
        g_DailyOpenPrice = rates[0].open;
        g_AnchorPrice = g_DailyOpenPrice;  // Set anchor price to daily open
    }
    
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    if(time_struct.hour == 0 && time_struct.min == 0) {
        g_DayOpenPrice = g_DailyOpenPrice;
    }
    
    // Add check for single remaining position
    
    isNewDay = true;
    canOpenNewTrade_Buy = true;
    canOpenNewTrade_Sell = true;
}
// 2. Fix the HandleBuyDCA function

// 4. Add a helper function to check distance between all orders
bool CheckDistanceBetweenAllOrders(double currentPrice, ENUM_POSITION_TYPE posType) {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && 
           PositionGetString(POSITION_SYMBOL) == _Symbol &&
           PositionGetInteger(POSITION_TYPE) == posType) {
            
            double orderPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double distance = MathAbs(currentPrice - orderPrice) / _Point;
            
            if(distance < MinimumOrderDistance) {
                return false;
            }
        }
    }
    return true;
}

// Modified GetPeriodExtraDistance function
// Modified GetPeriodExtraDistance function
double GetPeriodExtraDistance() {
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    int currentHour = time_struct.hour;
    
    // Get market volatility state
    double marketRange = CalculateMarketRange();
    bool isHighVolatility = marketRange > g_CurrentAIThreshold;
    
    // Calculate base extra distance based on time period
    double baseExtraDistance;
    string periodName;
    
    if(currentHour >= Period1StartHour && currentHour < Period1EndHour) {
        baseExtraDistance = Period1ExtraDistance;
        periodName = "Period 1";
    }
    else if(currentHour >= Period2StartHour && currentHour < Period2EndHour) {
        baseExtraDistance = Period2ExtraDistance;
        periodName = "Period 2";
    }
    else if(currentHour >= Period3StartHour && currentHour < Period3EndHour) {
        baseExtraDistance = Period3ExtraDistance;
        periodName = "Period 3";
    }
    else {
        baseExtraDistance = OutsideHoursExtraDistance;
        periodName = "Outside Hours";
    }
    
    // Apply volatility-based multipliers
    double finalExtraDistance;
    if(isHighVolatility) {
        finalExtraDistance = baseExtraDistance * HighRangeMultiplier;
    } else {
        finalExtraDistance = baseExtraDistance * NormalRangeMultiplier; // Will be 0 when NormalRangeMultiplier is 0
    }

    
    return finalExtraDistance;
}


void OpenDCAOrder(double currentPrice, ENUM_POSITION_TYPE posType) {
    // AI-Based DCA Block Check
    if(posType == POSITION_TYPE_BUY && g_AI_BlockDCA_Buy) {
        return;
    }
    if(posType == POSITION_TYPE_SELL && g_AI_BlockDCA_Sell) {
        return;
    }

    double latestOrderPrice = GetLatestOrderPrice(posType);
    double requiredDistance = GetAdjustedDCADistanceEnhanced(posType == POSITION_TYPE_BUY ? g_TotalOrders_Buy : g_TotalOrders_Sell);
    double currentDistance = MathAbs(currentPrice - latestOrderPrice) / _Point;

    if (currentDistance >= requiredDistance) {
        double volume = GetNextLotSize(posType);
        string comment = posType == POSITION_TYPE_BUY ? BuyComment : SellComment;

        ENUM_ORDER_TYPE orderType = (posType == POSITION_TYPE_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
        if (OpenOrder(orderType, volume, currentPrice)) {
           
        }
    }
}


// Helper function to identify order type from comment
enum ORDER_CATEGORY {
    INITIAL_ORDER,
    TREND_ORDER,
    HEDGE_ORDER
};

ORDER_CATEGORY GetOrderCategory(string comment) {
    if(StringFind(comment, "Trend Follow") >= 0) return TREND_ORDER;
    if(StringFind(comment, "Hedge") >= 0) return HEDGE_ORDER;
    return INITIAL_ORDER;
}

// Get latest order price by category
double GetLatestOrderPriceByCategory(ENUM_POSITION_TYPE posType, ORDER_CATEGORY category) {
    double latestPrice = 0;
    datetime latestTime = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(GetOrderCategory(comment) == category) {
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            if(openTime > latestTime) {
                latestTime = openTime;
                latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            }
        }
    }
    return latestPrice;
}


// Fixed function definition with optional parameter
double GetAdjustedDCADistanceEnhanced(int orderNumber, MarketConditionType marketCondition = MARKET_NORMAL) {
    // Function implementation
    // Get base DCA distance from custom settings
    double baseDistance = GetBaseDCADistance(orderNumber);
    
    // Get period-based extra distance
    double periodExtra = GetPeriodExtraDistance();
    
    // Calculate ATR for volatility reference
    double atr = CalculateATR(PERIOD_H1, 14) / _Point;
    
    // Adjust distance based on market condition
    double conditionMultiplier = 1.0;
    
    switch(marketCondition) {
        case MARKET_TRENDING:
            // In trending markets, increase distance to avoid over-trading
            conditionMultiplier = 1.3;
            baseDistance = MathMax(baseDistance, atr * 0.6);
            break;
            
        case MARKET_RANGING:
            // In ranging markets, standard distance
            conditionMultiplier = 1.0;
            baseDistance = MathMax(baseDistance, atr * 0.4);
            break;
            
        case MARKET_VOLATILE:
            // In volatile markets, significantly increase distance
            conditionMultiplier = 1;
            baseDistance = MathMax(baseDistance, atr * 1.2);
            break;
            
        default: // MARKET_NORMAL
            conditionMultiplier = 1.0;
            baseDistance = MathMax(baseDistance, atr * 0.3);
            break;
    }
    
    // Apply condition multiplier
    double adjustedBaseDistance = baseDistance * conditionMultiplier;
    double adjustedPeriodExtra = periodExtra * conditionMultiplier;
    
    // Calculate final distance
    double finalDistance = adjustedBaseDistance + adjustedPeriodExtra;
    
    // Ensure minimum distance is maintained
    finalDistance = MathMax(finalDistance, MinimumOrderDistance);
    

          
    return finalDistance;
}



// Modified function signature to include all parameters
double GetLatestOrderPrice(ENUM_POSITION_TYPE posType, bool includeHedge = true, bool includeTrend = true) {
    double latestPrice = 0;
    datetime latestTime = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
           PositionGetInteger(POSITION_TYPE) == posType) {
            
            string comment = PositionGetString(POSITION_COMMENT);
            bool isHedge = (StringFind(comment, "Hedge") >= 0);
            bool isTrend = (StringFind(comment, "Trend") >= 0);
            
            // Skip based on flags
            if(!includeHedge && isHedge) continue;
            if(!includeTrend && isTrend) continue;
            
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            if(openTime > latestTime) {
                latestTime = openTime;
                latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            }
        }
    }
    
    return latestPrice;
}

// Add new helper function to check if latest order is hedge
bool IsLatestOrderHedge(ENUM_POSITION_TYPE posType) {
    datetime latestTime = 0;
    bool isHedge = false;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && 
           PositionGetString(POSITION_SYMBOL) == _Symbol &&
           PositionGetInteger(POSITION_TYPE) == posType) {
            
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            if(openTime > latestTime) {
                latestTime = openTime;
                string comment = PositionGetString(POSITION_COMMENT);
                isHedge = (StringFind(comment, "Hedge") >= 0);
            }
        }
    }
    return isHedge;
}

// Add new function to open DCA orders that follow hedge orders
void OpenDCAOrderWithHedge(ENUM_ORDER_TYPE orderType, double lotSize, double currentPrice, bool isHedgeFollow) {
    if(!IsSpreadOK() || !CanOpenMoreOrdersInPeriod()) return;

    ENUM_POSITION_TYPE posType = (orderType == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
    int totalOrders = (posType == POSITION_TYPE_BUY) ? g_TotalOrders_Buy : g_TotalOrders_Sell;
    
    string baseComment = (orderType == ORDER_TYPE_BUY) ? BuyComment : SellComment;
    string hedgeLabel = isHedgeFollow ? "Hedge" : "";
    string comment = StringFormat("%s %s %d || L%d", 
                                baseComment,
                                hedgeLabel,
                                (posType == POSITION_TYPE_BUY) ? g_ActiveBuyCycles : g_ActiveSellCycles,
                                totalOrders + 1);

    // Calculate take profit level
    double takeProfit = 0;
    if(totalOrders + 1 >= CombinedTPLevel) {
        double weightedSum = currentPrice * lotSize;
        double totalVolume = lotSize;
        
        // Calculate weighted average including all orders
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket) && 
               PositionGetString(POSITION_SYMBOL) == _Symbol &&
               PositionGetInteger(POSITION_TYPE) == posType) {
                double posVolume = PositionGetDouble(POSITION_VOLUME);
                double posPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                weightedSum += posPrice * posVolume;
                totalVolume += posVolume;
            }
        }
        
    
        // Open position and update all TPs
        if(trade.PositionOpen(_Symbol, orderType, lotSize, currentPrice, 0, 0, comment)) {
            for(int i = PositionsTotal() - 1; i >= 0; i--) {
                ulong ticket = PositionGetTicket(i);
                if(PositionSelectByTicket(ticket) &&
                   PositionGetString(POSITION_SYMBOL) == _Symbol &&
                   PositionGetInteger(POSITION_TYPE) == posType) {
                    // Ch? c?p nh?t n?u TP khác giá tr? hi?n t?i
                    double currentTP = PositionGetDouble(POSITION_TP);
                    if(MathAbs(currentTP - takeProfit) > _Point) {
                        double currentSL = PositionGetDouble(POSITION_SL);
                        trade.PositionModify(ticket, currentSL, takeProfit);
                    }
                }
            }
        }
    } else {
        // Individual TP disabled - using virtual TP/SL system
        // double tpPoints = GetOrderTP(totalOrders + 1); // DISABLED
        // takeProfit = (orderType == ORDER_TYPE_BUY) ?
        //             NormalizeDouble(currentPrice + tpPoints * _Point, _Digits) :
        //             NormalizeDouble(currentPrice - tpPoints * _Point, _Digits);

        trade.PositionOpen(_Symbol, orderType, lotSize, currentPrice, 0, 0, comment);
    }
}

int GetCurrentCycleOrderNumber(ENUM_POSITION_TYPE posType) {
   int orderCount = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && 
         PositionGetString(POSITION_SYMBOL) == _Symbol &&
         PositionGetInteger(POSITION_TYPE) == posType) {
         orderCount++;
      }
   }
   return orderCount + 1; // Return next order number
}



double GetLatestOrderPriceAndUpdateSL(ENUM_POSITION_TYPE posType) {
    double latestPrice = 0;
    datetime latestTime = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket) && 
           PositionGetString(POSITION_SYMBOL) == _Symbol &&
           PositionGetInteger(POSITION_TYPE) == posType) {
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            if(openTime > latestTime) {
                latestTime = openTime;
                latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            }
        }
    }
    
    return latestPrice;
}

// Structure to track cycle information
struct CycleInfo {
    int cycleNumber;
    datetime startTime;
    double startPrice;
    double currentDrawdown;
    int orderCount;
    bool isTrending;
    bool isHedged;
};

// Array to store cycle information
CycleInfo g_BuyCycles[];
CycleInfo g_SellCycles[];

// Function to initialize cycle tracking
void InitializeCycleTracking() {
    ArrayResize(g_BuyCycles, 0);
    ArrayResize(g_SellCycles, 0);
}




// Function to determine optimal order parameters for new cycle
bool GetOptimalCycleParameters(ENUM_POSITION_TYPE posType, double &entryPrice, double &volume) {
    double currentPrice = GetCleanPrice();
    
    // Default parameters
    entryPrice = currentPrice;
    volume = defaultFixLength;
    
    // Get market context
    double marketRange = CalculateMarketRange();
    double momentum = CalculateMarketMomentum();
    
    // Adjust entry based on market conditions
    if(marketRange > g_CurrentAIThreshold) {
        // In high volatility, wait for better entry
        if(posType == POSITION_TYPE_BUY && momentum > 0) return false;
        if(posType == POSITION_TYPE_SELL && momentum < 0) return false;
        
        // Adjust volume based on volatility
        volume *= (marketRange > g_CurrentAIThreshold * 1.5) ? 0.8 : 0.9;
    }
    
    // Check existing positions distribution
    double avgOrderDistance = 0;
    int orderCount = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        double orderPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        avgOrderDistance += MathAbs(currentPrice - orderPrice);
        orderCount++;
    }
    
    if(orderCount > 0) {
        avgOrderDistance /= orderCount;
        
        // If average distance is small, new cycle might be too close
        if(avgOrderDistance < MinimumOrderDistance * 2) {
            return false;
        }
    }
    

    
    return true;
}

// Function to check existing order types
struct OrderTypes {
    bool hasInitial;
    bool hasTrend;
    bool hasHedge;
    int count;
};

OrderTypes CheckExistingOrderTypes() {
    OrderTypes types = {false, false, false, 0};
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Trend Follow") >= 0) {
            types.hasTrend = true;
            types.count++;
        }
        else if(StringFind(comment, "Hedge") >= 0) {
            types.hasHedge = true;
            types.count++;
        }
        else {
            types.hasInitial = true;
            types.count++;
        }
    }
    return types;
}


void ResetTrendModeTracking() {
    g_CycleInTrendMode = false;
    g_TrendModeDistance = 0;
   
}

// Fix 2: Improved NormalizeLotSize function
// THAY TH? HOÀN TOÀN HÀM CalculateOptimizedVolume TRONG EA
double CalculateOptimizedVolume(ENUM_POSITION_TYPE posType, string cycleType = "regular") {
    int currentOrderNumber = GetCurrentCycleOrderNumber(posType);
    double baseVolume = defaultFixLength;
    
    // === LOGIC C?P S? NHÂN CHO CÁC LO?I CHU K? ===
    double volumeMultiplier = 1.0;
    
    if(cycleType == "regular") {
        // Chu k? th??ng: S? d?ng GetExactMultiplier cho c?p s? nhân
        volumeMultiplier = GetExactMultiplier(currentOrderNumber);
    }
    else if(cycleType == "hedge") {
        // Chu k? hedge: T?ng d?n nh?
        double hedgeMultiplier = 1.0 + (currentOrderNumber * 0.15);
        volumeMultiplier = MathMin(3.0, hedgeMultiplier);
    }
    else if(cycleType == "recovery") {
        // Chu k? recovery: S? d?ng RecoveryVolumeMultiplier c? ??nh
        volumeMultiplier = RecoveryVolumeMultiplier;
        // LO?I B?: volumeMultiplier = MathMax(volumeMultiplier, 0.5); // ?ÂY LÀ BUG!
    }
    else if(cycleType == "trend") {
        // Chu k? trend: H? s? c? ??nh
        volumeMultiplier = 1.2;
    }
    else if(cycleType == "zone") {
        // Chu k? zone: S? d?ng GetExactMultiplier
        volumeMultiplier = GetExactMultiplier(currentOrderNumber);
    }
    
    // === TÍNH KH?I L??NG CU?I CÙNG ===
    double volume = baseVolume * volumeMultiplier;
    
    // === CHU?N HÓA KH?I L??NG ===
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    
    volume = MathRound(volume / lotStep) * lotStep;
    volume = MathMax(volume, minLot);
    volume = MathMin(volume, maxLot);
    
 
    
    return NormalizeDouble(volume, 2);
}

// C?I TI?N GetExactMultiplier v?i logic c?p s? nhân ?úng
double GetExactMultiplier(int orderNumber) {
    double multiplier = 1.0;
    
    // Logic c?p s? nhân l?y tích - m?i c?p nhân v?i c?p tr??c
    if(orderNumber >= FirstMultiplyOrder && orderNumber < SecondMultiplyOrder) {
        multiplier = FirstMultiplier;
    }
    else if(orderNumber >= SecondMultiplyOrder && orderNumber < ThirdMultiplyOrder) {
        multiplier = FirstMultiplier * SecondMultiplier;
    }
    else if(orderNumber >= ThirdMultiplyOrder && orderNumber < FourthMultiplyOrder) {
        multiplier = FirstMultiplier * SecondMultiplier * ThirdMultiplier;
    }
    else if(orderNumber >= FourthMultiplyOrder && orderNumber < FifthMultiplyOrder) {
        multiplier = FirstMultiplier * SecondMultiplier * ThirdMultiplier * FourthMultiplier;
    }
    else if(orderNumber >= FifthMultiplyOrder && orderNumber < SixthMultiplyOrder) {
        multiplier = FirstMultiplier * SecondMultiplier * ThirdMultiplier * FourthMultiplier * FifthMultiplier;
    }
    else if(orderNumber >= SixthMultiplyOrder) {
        // T?t c? multiplier nhân l?i
        multiplier = FirstMultiplier * SecondMultiplier * ThirdMultiplier * 
                    FourthMultiplier * FifthMultiplier * SixthMultiplier;
        
        // Cho các l?nh sau SixthMultiplyOrder, ti?p t?c nhân v?i SixthMultiplier
        int extraOrders = orderNumber - SixthMultiplyOrder;
        for(int i = 0; i < extraOrders; i++) {
            multiplier *= SixthMultiplier;
        }
    }
    
    // ??m b?o multiplier t?i thi?u
    if(multiplier < 1.0) multiplier = 1.0;
    
    
    return multiplier;
}
// Sửa hàm GetNextLotSize để sử dụng cấp số nhân với biến có sẵn
// Hàm phân tích volume momentum để đạt TP nhanh
double GetVolumeLotMultiplier(ENUM_POSITION_TYPE posType, double currentPrice) {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M5, 0, 20, rates) < 20) return 1.0;
    
    // Tính average volume
    long totalVolume = 0;
    for(int i = 1; i < 20; i++) {
        totalVolume += rates[i].tick_volume;
    }
    double avgVolume = (double)totalVolume / 19;
    
    // Current volume
    long currentVol = rates[0].tick_volume;
    double volRatio = (double)currentVol / avgVolume;
    
    // Check price momentum (3 bars gần nhất)
    bool bullishMomentum = (rates[0].close > rates[2].close);
    bool bearishMomentum = (rates[0].close < rates[2].close);
    
    // Volume tăng dần (momentum building)
    bool volumeIncreasing = (rates[0].tick_volume > rates[1].tick_volume && 
                             rates[1].tick_volume > rates[2].tick_volume);
    
    // HIGH VOLUME + MOMENTUM ĐÚNG CHIỀU = TĂNG LOT
    if(volRatio > 1.5 && volumeIncreasing) {
        if(posType == POSITION_TYPE_BUY && bullishMomentum) {
            // Buy positions, giá đang tăng với volume cao → tăng lot, TP nhanh
            return 1.3;
        }
        else if(posType == POSITION_TYPE_SELL && bearishMomentum) {
            // Sell positions, giá đang giảm với volume cao → tăng lot, TP nhanh
            return 1.3;
        }
        else {
            // Volume cao nhưng ngược chiều → rejection zone, giảm lot
            return 0.7;
        }
    }
    
    // MEDIUM VOLUME + MOMENTUM ĐÚNG = TĂNG NHẸ
    if(volRatio > 1.2) {
        if((posType == POSITION_TYPE_BUY && bullishMomentum) ||
           (posType == POSITION_TYPE_SELL && bearishMomentum)) {
            return 1.15;
        }
    }
    
    // LOW VOLUME = GIỮ NGUYÊN HOẶC GIẢM
    if(volRatio < 0.8) {
        return 0.9;
    }
    
    return 1.0;
}

// Hàm check volatility để adjust
double GetVolatilityLotMultiplier() {
    double atr[];
    ArraySetAsSeries(atr, true);
    
    int atrHandle = iATR(_Symbol, PERIOD_M15, 14);
    if(atrHandle == INVALID_HANDLE) return 1.0;
    
    if(CopyBuffer(atrHandle, 0, 0, 10, atr) < 10) {
        IndicatorRelease(atrHandle);
        return 1.0;
    }
    
    double avgATR = 0;
    for(int i = 1; i < 10; i++) {
        avgATR += atr[i];
    }
    avgATR = avgATR / 9;
    
    double currentATR = atr[0];
    double atrRatio = currentATR / avgATR;
    
    IndicatorRelease(atrHandle);
    
    // ATR cao (>1.3x) = volatility mạnh = TĂNG lot để đạt TP nhanh
    if(atrRatio > 1.3) return 1.2;
    
    // ATR thấp = sideway = giảm lot
    if(atrRatio < 0.8) return 0.85;
    
    return 1.0;
}

double GetNextLotSize(ENUM_POSITION_TYPE posType) {
    int currentOrders = (posType == POSITION_TYPE_BUY) ? g_TotalOrders_Buy : g_TotalOrders_Sell;
    int nextOrderIndex = currentOrders + 1;
    
    double lotSize = defaultFixLength;
    
    if(nextOrderIndex == 1) {
        return NormalizeDouble(defaultFixLength, 2);
    }
    
    // Tính cấp số nhân cơ bản
    lotSize = defaultFixLength;
    
    for(int i = 2; i <= nextOrderIndex; i++) {
        if(i >= FirstMultiplyOrder && i < SecondMultiplyOrder) {
            lotSize *= FirstMultiplier;
        }
        else if(i >= SecondMultiplyOrder && i < ThirdMultiplyOrder) {
            lotSize *= SecondMultiplier;
        }
        else if(i >= ThirdMultiplyOrder && i < FourthMultiplyOrder) {
            lotSize *= ThirdMultiplier;
        }
        else if(i >= FourthMultiplyOrder && i < FifthMultiplyOrder) {
            lotSize *= FourthMultiplier;
        }
        else if(i >= FifthMultiplyOrder && i < SixthMultiplyOrder) {
            lotSize *= FifthMultiplier;
        }
        else if(i >= SixthMultiplyOrder) {
            lotSize *= SixthMultiplier;
        }
    }
    
    // ÁP DỤNG VOLUME PROFILE MULTIPLIER
    double currentPrice = GetCleanPrice();
    double volumeMultiplier = GetVolumeLotMultiplier(posType, currentPrice);
    
    // ÁP DỤNG VOLATILITY MULTIPLIER
    double volatilityMultiplier = GetVolatilityLotMultiplier();
    
    // COMBINED MULTIPLIER - ĐẨY NHANH TP
    lotSize *= volumeMultiplier * volatilityMultiplier;
    
    // Check min/max lot
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    
    if(lotSize < minLot) lotSize = minLot;
    if(lotSize > maxLot) lotSize = maxLot;
    
    return NormalizeDouble(lotSize, 2);
}
double NormalizeLotSize(double lots) {
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double stepLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    
   
    
    // Làm tròn theo b??c lot
    double normalizedLots = MathRound(lots / stepLot) * stepLot;
    
    // ??m b?o trong gi?i h?n - KHÔNG dùng 0.5 làm t?i thi?u
    normalizedLots = MathMax(normalizedLots, minLot);
    normalizedLots = MathMin(normalizedLots, maxLot);
    
    double finalLots = NormalizeDouble(normalizedLots, 2);
    
    return finalLots;
}



// Add this new function to handle time-based TP adjustments
// Add this function to properly close cycles




bool g_RecoveryOpenedInCurrentCycle = false;
double g_CurrentCycleID = 0;
datetime g_CycleStartTime = 0;
bool g_DailyRecoveryUsed = false;
datetime g_LastRecoveryDayReset = 0;


// Modified function to update cycle information and reset recovery flag
void UpdateCycleInfo(ulong ticket, bool isNewCycle = false) {
    if(!PositionSelectByTicket(ticket)) return;
    
    ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    int currentSize;
    
    if(isNewCycle) {
        // This is a new cycle, so increment the cycle ID and reset recovery flag
        g_CurrentCycleID++;
        g_RecoveryOpenedInCurrentCycle = false;
        g_CycleStartTime = TimeCurrent();
        
        
        if(posType == POSITION_TYPE_BUY) {
            currentSize = ArraySize(g_BuyCycles);
            ArrayResize(g_BuyCycles, currentSize + 1);
            g_BuyCycles[currentSize].cycleNumber = currentSize + 1;
            g_BuyCycles[currentSize].startTime = TimeCurrent();
            g_BuyCycles[currentSize].startPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            g_BuyCycles[currentSize].orderCount = 1;
            g_BuyCycles[currentSize].isTrending = false;
            g_BuyCycles[currentSize].isHedged = false;
        } else {
            currentSize = ArraySize(g_SellCycles);
            ArrayResize(g_SellCycles, currentSize + 1);
            g_SellCycles[currentSize].cycleNumber = currentSize + 1;
            g_SellCycles[currentSize].startTime = TimeCurrent();
            g_SellCycles[currentSize].startPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            g_SellCycles[currentSize].orderCount = 1;
            g_SellCycles[currentSize].isTrending = false;
            g_SellCycles[currentSize].isHedged = false;
        }
    } else {
        // Update existing cycle info
        if(posType == POSITION_TYPE_BUY) {
            for(int i = ArraySize(g_BuyCycles) - 1; i >= 0; i--) {
                double currentPrice = GetCleanPrice();
                g_BuyCycles[i].currentDrawdown = MathAbs(currentPrice - g_BuyCycles[i].startPrice) / _Point;
                
                string comment = PositionGetString(POSITION_COMMENT);
                if(StringFind(comment, "Trend") >= 0) g_BuyCycles[i].isTrending = true;
                if(StringFind(comment, "Hedge") >= 0) g_BuyCycles[i].isHedged = true;
            }
        } else {
            for(int i = ArraySize(g_SellCycles) - 1; i >= 0; i--) {
                double currentPrice = GetCleanPrice();
                g_SellCycles[i].currentDrawdown = MathAbs(g_SellCycles[i].startPrice - currentPrice) / _Point;
                
                string comment = PositionGetString(POSITION_COMMENT);
                if(StringFind(comment, "Trend") >= 0) g_SellCycles[i].isTrending = true;
                if(StringFind(comment, "Hedge") >= 0) g_SellCycles[i].isHedged = true;
            }
        }
    }
}


// Add these to existing global variables
struct CyclePerformanceMetrics {
    int cycleId;
    double maxDrawdown;
    double profitLoss;
    int orderCount;
    double averagePrice;
    double deviationFromCenter;
    datetime startTime;
    datetime endTime;
    bool wasRecovered;
    string failureReason;
};

// Arrays to store recent cycle metrics
CyclePerformanceMetrics g_LastBuyCycles[10];  // Store last 10 buy cycles
CyclePerformanceMetrics g_LastSellCycles[10]; // Store last 10 sell cycles
int g_BuyCycleHistoryCount = 0;
int g_SellCycleHistoryCount = 0;

double g_LastRecoveryError = 0;        // Store the error/deviation of last recovery
int g_ConsecutiveRecoveries = 0;       // Track consecutive recovery activations
bool g_IncreasingErrorPattern = false; // Flag for detecting increasing error pattern

// Function to save completed cycle metrics
void SaveCycleMetrics(int cycleId, ENUM_POSITION_TYPE posType, double profitLoss, bool wasRecovered = false) {
    CyclePerformanceMetrics metrics;
    
    metrics.cycleId = cycleId;
    metrics.profitLoss = profitLoss;
    metrics.wasRecovered = wasRecovered;
    metrics.endTime = TimeCurrent();
    
    // Calculate other metrics
    metrics.maxDrawdown = CalculateCycleMaxDrawdown(cycleId, posType);
    metrics.orderCount = GetCycleOrderCount(posType, cycleId);
    metrics.averagePrice = CalculateCycleAveragePrice(cycleId, posType);
    metrics.deviationFromCenter = CalculateDeviationFromCenter(metrics.averagePrice);
    metrics.failureReason = DetermineCycleFailureReason(cycleId, posType);
    
    // Store in appropriate history array
    if(posType == POSITION_TYPE_BUY) {
        // Shift array to make room for new entry
        for(int i = 9; i > 0; i--) {
            g_LastBuyCycles[i] = g_LastBuyCycles[i-1];
        }
        g_LastBuyCycles[0] = metrics;
        g_BuyCycleHistoryCount = MathMin(g_BuyCycleHistoryCount + 1, 10);
    } else {
        // Shift array to make room for new entry
        for(int i = 9; i > 0; i--) {
            g_LastSellCycles[i] = g_LastSellCycles[i-1];
        }
        g_LastSellCycles[0] = metrics;
        g_SellCycleHistoryCount = MathMin(g_SellCycleHistoryCount + 1, 10);
    }

}

// Supporting functions for cycle metrics
double CalculateCycleMaxDrawdown(int cycleId, ENUM_POSITION_TYPE posType) {
    double maxDrawdown = 0;
    // For simplicity, return a placeholder value
    return maxDrawdown;
}

double CalculateCycleAveragePrice(int cycleId, ENUM_POSITION_TYPE posType) {
    double weightedSum = 0;
    double totalVolume = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(ExtractCycleId(comment) != cycleId) continue;
        
        double volume = PositionGetDouble(POSITION_VOLUME);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        
        weightedSum += openPrice * volume;
        totalVolume += volume;
    }
    
    return (totalVolume > 0) ? weightedSum / totalVolume : 0;
}

double CalculateDeviationFromCenter(double price) {
    if(price == 0) return 0;
    double centerPrice = CalculateCenterPrice();
    return MathAbs(price - centerPrice) / _Point;
}

string DetermineCycleFailureReason(int cycleId, ENUM_POSITION_TYPE posType) {
    MarketConditionType marketCondition = DetermineMarketCondition();
    
    switch(marketCondition) {
        case MARKET_TRENDING: return "Adverse trend movement";
        case MARKET_VOLATILE: return "Excessive volatility";
        case MARKET_RANGING: return "Range breakout";
        default: return "Normal market deviation";
    }
}

// Calculate error metric based on previous cycles
double CalculateRecoveryErrorMetric() {
    double errorMetric = 0;
    
    // Check for patterns in recent cycles
    int recoveredCycles = 0;
    double avgDrawdown = 0;
    double avgDeviation = 0;
    
    // Count recovered buy cycles
    for(int i = 0; i < g_BuyCycleHistoryCount; i++) {
        if(g_LastBuyCycles[i].wasRecovered) {
            recoveredCycles++;
            avgDrawdown += g_LastBuyCycles[i].maxDrawdown;
            avgDeviation += g_LastBuyCycles[i].deviationFromCenter;
        }
    }
    
    // Count recovered sell cycles
    for(int i = 0; i < g_SellCycleHistoryCount; i++) {
        if(g_LastSellCycles[i].wasRecovered) {
            recoveredCycles++;
            avgDrawdown += g_LastSellCycles[i].maxDrawdown;
            avgDeviation += g_LastSellCycles[i].deviationFromCenter;
        }
    }
    
    // Calculate averages if we have recovery history
    if(recoveredCycles > 0) {
        avgDrawdown /= recoveredCycles;
        avgDeviation /= recoveredCycles;
        
        errorMetric = g_ConsecutiveRecoveries * 0.2 + 
                      avgDrawdown / 10000.0 +
                      avgDeviation / 5000.0;
    } else {
        // Default modest error metric if no history
        errorMetric = 0.5;
    }
    
    // Check if errors are increasing
    g_IncreasingErrorPattern = (errorMetric > g_LastRecoveryError);
    g_LastRecoveryError = errorMetric;
    
    return errorMetric;
}

// Functions to calculate ADX components
double CalculatePlusDI(ENUM_TIMEFRAMES timeframe, int period) {
    int adxHandle = iADX(_Symbol, timeframe, period);
    if(adxHandle == INVALID_HANDLE) return 0;
    
    double plusDI[];
    ArraySetAsSeries(plusDI, true);
    if(CopyBuffer(adxHandle, 1, 0, 1, plusDI) <= 0) {
        IndicatorRelease(adxHandle);
        return 0;
    }
    
    double plusDIvalue = plusDI[0];
    IndicatorRelease(adxHandle);
    
    return plusDIvalue;
}

double CalculateMinusDI(ENUM_TIMEFRAMES timeframe, int period) {
    int adxHandle = iADX(_Symbol, timeframe, period);
    if(adxHandle == INVALID_HANDLE) return 0;
    
    double minusDI[];
    ArraySetAsSeries(minusDI, true);
    if(CopyBuffer(adxHandle, 2, 0, 1, minusDI) <= 0) {
        IndicatorRelease(adxHandle);
        return 0;
    }
    
    double minusDIvalue = minusDI[0];
    IndicatorRelease(adxHandle);
    
    return minusDIvalue;
}
// Fully automatic recovery system with no dependency on input parameters
// Simple fix for recovery - just modify your existing function by replacing:

// Simple version with minimal changes to original function
// Modified OpenRecoveryOrder function with fixed volume calculation
// Modified OpenRecoveryOrder function with reduced volume calculation

// Add these global variables
bool g_LastOrderWasLarge = false;     // Tracks if the last order was a large volume order
double g_LastLargeOrderPrice = 0;     // Tracks the price of the last large volume order
int g_SmallOrdersCounter = 0;         // Counts consecutive small orders
int g_OptimalPriceCounter = 0;        // Tracks how many optimal price points we've hit

// Function to determine if current price is at a key level for larger volume
bool IsOptimalPriceLevel(double currentPrice, ENUM_ORDER_TYPE orderType) {
    // Get reference price (enhanced center price)
    double centerPrice = CalculateCenterPrice();
    
    // Calculate distance from center
    double distanceFromCenter = MathAbs(currentPrice - centerPrice) / _Point;
    
    // Get key Fibonacci levels
    double fib382 = 0.382;
    double fib618 = 0.618;
    double fib786 = 0.786;
    double fib1618 = 1.618;
    
    // Calculate market range for reference
    double atr = CalculateATR(PERIOD_H1, 14) / _Point;
    
  // Define Fibonacci constants

// Major price levels (calculated from ATR)
double keyDistances[5];  // Declare the array with 5 elements
keyDistances[0] = atr * fib618;    // ~0.618 of ATR
keyDistances[1] = atr * 1.0;       // 1 ATR
keyDistances[2] = atr * fib1618;   // ~1.618 of ATR
keyDistances[3] = atr * 2.0;       // 2 ATR
keyDistances[4] = atr * 2.618;     // ~2.618 of ATR
    // Check if price is near a key level based on distance from center
    for(int i = 0; i < ArraySize(keyDistances); i++) {
        double lowerBound = keyDistances[i] - (atr * 0.1);  // 10% tolerance below
        double upperBound = keyDistances[i] + (atr * 0.1);  // 10% tolerance above
        
        if(distanceFromCenter >= lowerBound && distanceFromCenter <= upperBound) {
            // Confirm with direction (buy below center, sell above center)
            if((orderType == ORDER_TYPE_BUY && currentPrice < centerPrice) || 
               (orderType == ORDER_TYPE_SELL && currentPrice > centerPrice)) {
                
                // Prevent clustering of large orders at similar price levels
                if(g_LastLargeOrderPrice > 0) {
                    double distanceFromLastLarge = MathAbs(currentPrice - g_LastLargeOrderPrice) / _Point;
                    if(distanceFromLastLarge < atr) {
                        // Too close to previous large order
                        return false;
                    }
                }
                
                // Additional check: Trend confirmation
                MarketConditionType marketCondition = DetermineMarketCondition();
                if(marketCondition == MARKET_TRENDING) {
                    double adx = CalculateADX(PERIOD_H1, 14);
                    double plusDI = CalculatePlusDI(PERIOD_H1, 14);
                    double minusDI = CalculateMinusDI(PERIOD_H1, 14);
                    
                    // Confirm trend direction matches order type
                    bool trendConfirmed = (orderType == ORDER_TYPE_BUY && plusDI > minusDI) || 
                                         (orderType == ORDER_TYPE_SELL && minusDI > plusDI);
                    
                    // Strong trend required for optimal price level
                    if(adx < 20 || !trendConfirmed) {
                        return false;
                    }
                }
                
                // We need at least 3 small orders between large orders
                if(g_LastOrderWasLarge && g_SmallOrdersCounter < 3) {
                    return false;
                }
                
                return true;
            }
        }
    }
    
    return false;
}


// Thêm globals
int g_AD_Handle = INVALID_HANDLE;
int g_Force_Handle = INVALID_HANDLE;
double g_AD_Buffer[], g_Force_Buffer[];




// Hàm phân tích order flow
enum OrderFlowStrength {
    FLOW_STRONG_BUY,
    FLOW_WEAK_BUY,
    FLOW_NEUTRAL,
    FLOW_WEAK_SELL,
    FLOW_STRONG_SELL
};

OrderFlowStrength AnalyzeOrderFlowAdvanced() {
    if(CopyBuffer(g_AD_Handle, 0, 0, 3, g_AD_Buffer) < 3) return FLOW_NEUTRAL;
    if(CopyBuffer(g_Force_Handle, 0, 0, 2, g_Force_Buffer) < 2) return FLOW_NEUTRAL;
    
    double ad = g_AD_Buffer[0];
    double ad_prev = g_AD_Buffer[1];
    double ad_prev2 = g_AD_Buffer[2];
    double force = g_Force_Buffer[0];
    double force_prev = g_Force_Buffer[1];
    
    // A/D và Force cùng chiều = strong
    bool adRising = (ad > ad_prev && ad_prev > ad_prev2);
    bool adFalling = (ad < ad_prev && ad_prev < ad_prev2);
    bool forceRising = (force > 0 && force > force_prev);
    bool forceFalling = (force < 0 && force < force_prev);
    
    if(adRising && forceRising) return FLOW_STRONG_BUY;
    if(adFalling && forceFalling) return FLOW_STRONG_SELL;
    
    if(adRising || forceRising) return FLOW_WEAK_BUY;
    if(adFalling || forceFalling) return FLOW_WEAK_SELL;
    
    return FLOW_NEUTRAL;
}

bool ShouldAllowTrade(ENUM_POSITION_TYPE posType) {
    OrderFlowStrength flow = AnalyzeOrderFlowAdvanced();
    
    if(posType == POSITION_TYPE_BUY) {
        return (flow == FLOW_STRONG_BUY || flow == FLOW_WEAK_BUY);
    } else {
        return (flow == FLOW_STRONG_SELL || flow == FLOW_WEAK_SELL);
    }
}
int g_EMA_Handle = INVALID_HANDLE;

// C?p nh?t hàm OnInit ?? kh?i t?o các bi?n DCA recovery
int OnInit() {
    InitializeDynamicGaps();
// Thêm vào cu?i hàm OnInit() tr??c return(INIT_SUCCEEDED);
if(EnableWeekendProtection) {
    g_TimerHandle = EventSetTimer(60);
}  // Trong OnInit()
g_MFI_Handle = iMFI(_Symbol, PERIOD_M1, 14, VOLUME_TICK);
if(g_MFI_Handle == INVALID_HANDLE) {
    return(INIT_PARAMETERS_INCORRECT);
}g_EMA_Handle = iMA(_Symbol, PERIOD_M15, 20, 0, MODE_EMA, PRICE_CLOSE);
if(g_EMA_Handle == INVALID_HANDLE) {
    return(INIT_PARAMETERS_INCORRECT);
}
ArraySetAsSeries(g_EMA_Buffer, true);
    ArraySetAsSeries(g_MFI_Buffer, true);
    g_ADX_Handle = iADX(_Symbol, PERIOD_H1, 14);
if(g_ADX_Handle == INVALID_HANDLE) {
    return(INIT_PARAMETERS_INCORRECT);
} g_EMA_Handle = iMA(_Symbol, PERIOD_M1, 3, 0, MODE_EMA, PRICE_CLOSE);

if(g_EMA_Handle == INVALID_HANDLE) {
    return(INIT_PARAMETERS_INCORRECT);
}
ArraySetAsSeries(g_EMA_Buffer, true);
ArraySetAsSeries(g_ADX_Buffer, true);
    // Các kh?i t?o c?n thi?t
    trade.SetExpertMagicNumber(10051988);
    g_AnchorPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    g_DynamicTimeframe = GetOptimalTimeframe();

    g_LastAnchorPrice = g_AnchorPrice;
    g_LastBuyAnchor = g_AnchorPrice;
    g_LastSellAnchor = g_AnchorPrice;
    g_CurrentTimeframe = g_DynamicTimeframe ; // Kh?i t?o v?i timeframe m?c ??nh
    g_DailyRecoveryOrderOpened = false;
    g_LastRecoveryDay = 0;
    g_InRecoveryMode = false;
    g_RecoveryOrderOpenTime = 0;
    g_DailyRecoveryOrderOpened = false;
       g_AD_Handle = iAD(_Symbol, PERIOD_M15, VOLUME_TICK);
    g_Force_Handle = iForce(_Symbol, PERIOD_M15, 13, MODE_EMA, VOLUME_TICK);
    
    if(g_AD_Handle == INVALID_HANDLE || g_Force_Handle == INVALID_HANDLE) {
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    ArraySetAsSeries(g_AD_Buffer, true);
    ArraySetAsSeries(g_Force_Buffer, true);
    // Initialize resume trading variables
    g_HasResumedTrading = false;
    g_RecoveryResumeTime = 0;
    
    // Initialize recovery cycle variables
    g_RecoveryOpenedInCurrentCycle = false;
    g_CurrentCycleID = 0;
    g_CycleStartTime = TimeCurrent();
    
    // Kh?i t?o bi?n DCA recovery
    g_RecoveryDCAEnabled = EnableRecoveryDCA;
    g_RecoveryOrderCount = 0;
    g_RecoveryTotalVolume = 0;
    g_RecoveryAveragePrice = 0;
    g_LastMarketVolatility = 0;
    g_LastVolatilityCheck = 0;
    g_VolatilityDecreasing = false;
    
    ArrayResize(g_OrderLots, 0);
    ArrayResize(g_OrderTimes, 0);
    ArrayResize(g_OrderTypes, 0);
    CreateControlPanel();
    
    // Create info label
    ObjectCreate(0, infoLabelName, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, infoLabelName, OBJPROP_CORNER, CORNER_LEFT_LOWER);
    ObjectSetInteger(0, infoLabelName, OBJPROP_XDISTANCE, 10);
    ObjectSetInteger(0, infoLabelName, OBJPROP_YDISTANCE, 20);
    
    string message = StringFormat(
        "=== Merlin ===\n"
        " Symbol: %s",
        _Symbol
    );
    
    ObjectSetString(0, infoLabelName, OBJPROP_TEXT, message);
    ObjectSetString(0, infoLabelName, OBJPROP_FONT, "Arial");
    ObjectSetInteger(0, infoLabelName, OBJPROP_FONTSIZE, 10);
    ObjectSetInteger(0, infoLabelName, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, infoLabelName, OBJPROP_ANCHOR, ANCHOR_LEFT_LOWER);

    // Initialize AI Integration
    InitAIIntegration();

    // Initialize AI Threshold v?i giá tr? m?c ??nh
    g_CurrentAIThreshold = MarketRangeThreshold;
    g_LastThresholdUpdate = 0;

    return(INIT_SUCCEEDED);
}

// Modified OpenOrder function to track new cycles
// Helper function to check for any active recovery orders
bool HasActiveRecoveryOrders() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
            return true;
        }
    }
    return false;
}




// Modified UpdateInfoLabel to include cycle recovery information
// Thêm c?u hình input cho Recovery DCA
input group "===== RECOVERY DCA SETTINGS ====="
input bool EnableRecoveryDCA = true;             // B?t ch? ?? DCA cho l?nh recovery
input int MaxRecoveryDCAOrders = 5;              // S? l?nh DCA recovery t?i ?a
input bool CloseRecoveryWhenVolatilityDecreases = true; // ?óng recovery khi th? tr??ng h?t bi?n ??ng
// Modified function to reset recovery metrics when cycle completes successfully

// Thêm globals
enum ActiveTradeType {
    TRADE_NONE,
    TRADE_SIDEWAY,
    TRADE_BREAKOUT
};

ActiveTradeType g_ActiveTradeType = TRADE_NONE;
bool g_WaitingForCycleCompletion = false;

// Hàm kiểm tra loại lệnh đang active
ActiveTradeType GetActiveTradeType() {
    if(PositionsTotal() == 0) return TRADE_NONE;
    
    bool hasSidewayOrders = false;
    bool hasBreakoutOrders = false;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        
        // Sideway orders
        if(StringFind(comment, "Box Buy") >= 0 || StringFind(comment, "Box Sell") >= 0 ||
           StringFind(comment, "Sideway") >= 0) {
            hasSidewayOrders = true;
        }
        
        // Breakout/Single direction orders
        if(StringFind(comment, "Single") >= 0 || StringFind(comment, "Breakout") >= 0 ||
           StringFind(comment, "Trend") >= 0) {
            hasBreakoutOrders = true;
        }
    }
    
    if(hasSidewayOrders) return TRADE_SIDEWAY;
    if(hasBreakoutOrders) return TRADE_BREAKOUT;
    
    return TRADE_NONE;
}

void HandleCycleCompletion() {
    if(PositionsTotal() == 0) {
        // Reset khi không còn lệnh
        g_ActiveTradeType = TRADE_NONE;
        g_WaitingForCycleCompletion = false;
        return;
    }
    
    datetime currentTime = TimeCurrent();
    double currentPrice = GetCleanPrice();
    
    // Xác định loại lệnh đang active
    ActiveTradeType currentTradeType = GetActiveTradeType();
    
    double totalProfit = 0;
    double buyProfit = 0;
    double sellProfit = 0;
    int buyOrders = 0;
    int sellOrders = 0;
    
    // Tính profit và count orders
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        double profit = PositionGetDouble(POSITION_PROFIT);
        totalProfit += profit;
        
        if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) {
            buyProfit += profit;
            buyOrders++;
        } else {
            sellProfit += profit;
            sellOrders++;
        }
    }
    

    // Check if cycle is complete (profit > 0)
    if(totalProfit > 0 || buyProfit > 0 || sellProfit > 0) {
        bool cycleCompleted = false;
        
        if(totalProfit > 0) {
            cycleCompleted = true;
        } else if(buyProfit > 0 && buyOrders > 0) {
            cycleCompleted = true;
        } else if(sellProfit > 0 && sellOrders > 0) {
            cycleCompleted = true;
        }
        
        if(cycleCompleted) {
            // Reset recovery metrics
            g_ConsecutiveRecoveries = 0;
            g_CompletedCycles++;
            
            // Update anchor price based on profit direction
            if(buyProfit > sellProfit) {
                // Buy profitable = price rising
                g_AnchorPrice += 3000 * _Point;
            } else if(sellProfit > buyProfit) {
                // Sell profitable = price falling
            }
            
            g_LastAnchorPrice = g_AnchorPrice;
            g_LastBuyAnchor = g_AnchorPrice;
            g_LastSellAnchor = g_AnchorPrice;
            
            // Adjust DCA gaps based on completed cycles
            if(g_CompletedCycles == 39) {
                g_CurrentFirstOrderGap = FirstOrderGap * 3;
                g_CurrentSecondOrderGap = SecondOrderGap * 3;
                g_CurrentThirdOrderGap = ThirdOrderGap * 3;
                g_CurrentFourthOrderGap = FourthOrderGap * 3;
                g_CurrentFifthOrderGap = FifthOrderGap * 3;
            }
            else if(g_CompletedCycles == 69) {
                g_CurrentFirstOrderGap = FirstOrderGap * 3;
                g_CurrentSecondOrderGap = SecondOrderGap * 3;
                g_CurrentThirdOrderGap = ThirdOrderGap * 3;
                g_CurrentFourthOrderGap = FourthOrderGap * 3;
                g_CurrentFifthOrderGap = FifthOrderGap * 3;
            }
            else if(g_CompletedCycles >= 99) {
                g_CurrentFirstOrderGap = FirstOrderGap;
                g_CurrentSecondOrderGap = SecondOrderGap;
                g_CurrentThirdOrderGap = ThirdOrderGap;
                g_CurrentFourthOrderGap = FourthOrderGap;
                g_CurrentFifthOrderGap = FifthOrderGap;
                g_CompletedCycles = 0;
            }
            
            g_LastCycleCompletionTime = currentTime;
            g_LastCycleCompleteTime = currentTime;
            g_LastCycleCompletePrice = currentPrice;
            
            // Reset cycle flags
            g_CycleInTrendMode = false;
            g_TrendModeDistance = 0;
            g_HasActiveHedgeOrder = false;
            g_ActiveHedgeBuys = 0;
            g_ActiveHedgeSells = 0;
            g_RecoveryOpenedInCurrentCycle = false;
            g_WaitingForNewEntry = true;
            
            // RESET TRADE TYPE - cho phép chuyển logic mới
            if(PositionsTotal() == 0) {
                g_ActiveTradeType = TRADE_NONE;
                g_WaitingForCycleCompletion = false;
                canOpenNewTrade_Buy = true;
                canOpenNewTrade_Sell = true;
            }
        }
    }
    
    // NẾU VẪN CÒN LỆNH SIDEWAY → KHÔNG CHO CHUYỂN SANG BREAKOUT
    if(currentTradeType == TRADE_SIDEWAY && !g_InsideBox) {
        g_WaitingForCycleCompletion = true;
      
    }
    
    // NẾU VẪN CÒN LỆNH BREAKOUT → KHÔNG CHO CHUYỂN SANG SIDEWAY
    if(currentTradeType == TRADE_BREAKOUT && g_InsideBox) {
        g_WaitingForCycleCompletion = true;
      
    }
    
    // Update active trade type
    if(PositionsTotal() > 0) {
        g_ActiveTradeType = currentTradeType;
    }
}
// Modified for cycle tracking in ForceCloseAllPositions
void ForceCloseAllPositions(string reason) {
    
    // First, disable recovery mode
    if(g_InRecoveryMode) {
        g_InRecoveryMode = false;
        g_RecoveryOrderTicket = 0;
        g_RecoveryOrderOpenTime = 0;
        g_RecoveryAttempts = 0;
        g_RecoveryDCACount = 0;
    }
    
    // Count positions before closing
    int beforeCount = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        beforeCount++;
    }
    
    
    // First attempt - normal closing
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        // Try normal close
        trade.SetDeviationInPoints(10);
        if(trade.PositionClose(ticket)) {
        } else {
        }
    }
    
    // Reset other EA states
    g_WaitingForNewEntry = true;
    g_HasActiveBuyCycle = false;
    g_HasActiveSellCycle = false;
    g_HasActiveHedgeOrder = false;
    g_ActiveHedgeBuys = 0;
    g_ActiveHedgeSells = 0;
    
    // Reset recovery cycle flag
    g_RecoveryOpenedInCurrentCycle = false;
    
    // Start a new cycle ID
    g_CurrentCycleID++;
    g_CycleStartTime = TimeCurrent();
    
}
// Modified CalculateRecoveryTP function to use standard cycle TP logic

// Helper function to get current period name for logging
string GetCurrentPeriodName() {
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    int currentHour = time_struct.hour;
    
    if(currentHour >= Period1StartHour && currentHour < Period1EndHour) {
        return "Period 1";
    }
    else if(currentHour >= Period2StartHour && currentHour < Period2EndHour) {
        return "Period 2";
    }
    else if(currentHour >= Period3StartHour && currentHour < Period3EndHour) {
        return "Period 3";
    }
    else {
        return "Outside Hours";
    }
}



double CalculateRecoveryDCAVolume(int dcaAttempt) {
    // MODIFIED: Use GetNextLotSize for consistent volume logic
    // Determine position type from existing recovery orders
    ENUM_POSITION_TYPE recoveryType = POSITION_TYPE_BUY; // Default
    
    // Find the position type of the existing recovery orders
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
            recoveryType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            break;
        }
    }
    
    // Use the same GetNextLotSize function for consistent volume logic
    return GetNextLotSize(recoveryType);
}
// 1. Modified OpenRecoveryOrder function

// Add these global variables at the top with other globals
int g_MarketDirectionBias = 0;       // Range: -100 (strong sell) to +100 (strong buy)
datetime g_LastDirectionUpdate = 0;
int g_DirectionUpdateInterval = 60;  // Update direction every 60 seconds

void CheckAndActivateRecoveryMode() {
    // Skip if recovery is disabled, already active, or already used in this cycle
    if(!EnableRecoveryMode || g_InRecoveryMode || g_RecoveryOpenedInCurrentCycle) {
        static datetime lastDebugTime = 0;
        if(TimeCurrent() - lastDebugTime > 300) {  // Log every 5 minutes
     
        }
        return;
    }
    
    if(IsWeekendProtectionForRecovery()) {
        static datetime lastWeekendLog = 0;
        if(TimeCurrent() - lastWeekendLog > 300) {
            lastWeekendLog = TimeCurrent();
        }
        return;
    }
    
    // Throttle checks (check only once every 5 seconds)
    static datetime lastCheckTime = 0;
    datetime currentTime = TimeCurrent();
    if(currentTime - lastCheckTime < 5) return;
    lastCheckTime = currentTime;
    
    // Calculate total profit/loss
    double totalPnL = 0;
    int positionCount = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        // Skip positions that are already recovery positions
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) continue;
        
        totalPnL += PositionGetDouble(POSITION_PROFIT);
        positionCount++;
    }
    
    // No positions, no need for recovery
    if(positionCount == 0) return;
    
    // Log recovery check status
    static datetime lastStatusLog = 0;
    if(currentTime - lastStatusLog > 60) { // Log every minute
    
        lastStatusLog = currentTime;
    }
    
    // SIMPLE CLEAR CHECK: Does the loss exceed the threshold?
    // Note: Recovery threshold should be negative (e.g., -500)
    if(totalPnL <= RecoveryLossThreshold) {
        // Activate recovery mode
        g_InRecoveryMode = true;
        g_RecoveryStartLoss = totalPnL;
        g_RecoveryStartTime = currentTime;
        g_HasResumedTrading = false;
        g_RecoveryOpenedInCurrentCycle = true;
        g_RecoveryOrderCount = 0;
        g_CurrentRecoveryCycleId++;
        
    
        // Open the recovery order
        OpenRecoveryOrder();
    }
}

// Modified OpenRecoveryOrder to match recovery principles
void OpenRecoveryOrder() {
    // Add period limit check
    UpdatePeriodOrderCount();
     if(!CheckAndUpdateDrawdownStatus()) {
        return ;
    }
    if(g_CurrentPeriodOrders >= g_CurrentPeriodLimit) {
        g_InRecoveryMode = false; // Reset recovery mode if we can't open the order
        return;
    }
    
       bool hasExistingRecovery = false;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Recovery") >= 0) {
            hasExistingRecovery = true;
            break;
        }
    }
    
    if(hasExistingRecovery) {
        return;
    }
// Add this at the start of every order opening function:
if(!EnforcePeriodOrderLimits()) {
    return ;
}
    trade.SetExpertMagicNumber(10051989); // Special magic for recovery
    
    // Reset trackers
    g_RecoveryOrderCount = 0;
    g_RecoveryTotalVolume = 0;
    g_RecoveryAveragePrice = 0;
    
    // PRINCIPLE 9: SMART DIRECTION SELECTION
    // Analyze existing positions to determine optimal recovery direction
    double buyPnL = 0, sellPnL = 0;
    int buyPositions = 0, sellPositions = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double profit = PositionGetDouble(POSITION_PROFIT);
        
        if(posType == POSITION_TYPE_BUY) {
            buyPnL += profit;
            buyPositions++;
        } else {
            sellPnL += profit;
            sellPositions++;
        }
    }
    
    // Get market direction bias
    int directionBias = AnalyzeMarketDirection();
    
    // PRINCIPLE 10: COUNTER-TREND RECOVERY
    // Determine recovery direction opposite to the dominant loss positions
    ENUM_ORDER_TYPE recoveryOrderType;
    
    if(sellPositions > buyPositions && sellPnL < 0 && MathAbs(sellPnL) > MathAbs(buyPnL)) {
        // More loss in sell positions - use BUY recovery
        recoveryOrderType = ORDER_TYPE_SELL;
    } 
    else if(buyPositions > sellPositions && buyPnL < 0 && MathAbs(buyPnL) > MathAbs(sellPnL)) {
        // More loss in buy positions - use SELL recovery
        recoveryOrderType = ORDER_TYPE_BUY;
    }
 
    
 
    
    // PRINCIPLE 12: VOLUME SCALING
    // Calculate volume based on dominant position size and loss
    double dominantLoss = (sellPositions > buyPositions) ? MathAbs(sellPnL) : MathAbs(buyPnL);
    double baseVolume = defaultFixLength;
    
    // Scale volume based on loss severity (more severe = larger volume)
    double lossRatio = dominantLoss / MathAbs(RecoveryLossThreshold);
    double volumeMultiplier = RecoveryVolumeMultiplier * MathMin(2.0, MathMax(1.0, lossRatio));
    
    double volume = NormalizeLotSize(baseVolume * volumeMultiplier);
    
    // Get entry price
    double entryPrice = (recoveryOrderType == ORDER_TYPE_BUY) ? 
                      SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
                      SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // PRINCIPLE 13: WIDER TAKE PROFIT
    // Use wider TP for recovery orders to ensure they have room to work
    // double standardTP = CalculateOrderTP( // DISABLEDrecoveryOrderType, entryPrice, 1);
  

    // Order comment
    string comment = StringFormat("Recovery %s #%d", 
                                EnumToString(recoveryOrderType), 
                                g_RecoveryAttempts + 1);
    

    // Open order using standard function
    if(trade.PositionOpen(_Symbol, recoveryOrderType, volume, entryPrice, 0, 0, comment)) {
        g_RecoveryOrderTicket = trade.ResultOrder();
        g_RecoveryAttempts++;
        g_RecoveryOrderOpenTime = TimeCurrent();
        g_RecoveryOrderCount = 1;
        g_RecoveryTotalVolume = volume;
        g_RecoveryAveragePrice = entryPrice;
        
        // Update period order count after successful opening
        UpdatePeriodOrderCount();
    } else {
        g_InRecoveryMode = false;
    }
    
    trade.SetExpertMagicNumber(10051988); // Reset to standard magic
}

// Enhanced recovery management function
void ManageRecoveryMode() {
    
    datetime currentTime = TimeCurrent();
    bool timeoutDetected = false;
      MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
    // Friday check - more precise hour comparison
    if(EnableWeekendProtection && time_struct.day_of_week == FRIDAY && time_struct.hour >= FridayLastTradeHour - 2) {
        // Handle recovery orders for weekend specifically
        
        // If all recovery positions were closed, exit recovery mode
        int recoveryCount = 0;
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Recovery") >= 0) {
                recoveryCount++;
            }
        }
        
        if(recoveryCount == 0) {
            g_InRecoveryMode = false;
            g_RecoveryOrderTicket = 0;
            g_RecoveryOrderOpenTime = 0;
            g_RecoveryAttempts = 0;
            g_HasResumedTrading = false;
            return;
        }
    }
    // PRINCIPLE 14: RECOVERY ORDER TRACKING
    // Check if recovery order exists and track its status
    bool recoveryOrderExists = false;
    double recoveryProfit = 0;
    
    if(g_RecoveryOrderTicket > 0) {
        if(PositionSelectByTicket(g_RecoveryOrderTicket)) {
            recoveryOrderExists = true;
            recoveryProfit = PositionGetDouble(POSITION_PROFIT);
            
            // Log recovery status periodically
            static datetime lastStatusUpdate = 0;
            if(currentTime - lastStatusUpdate > 300) { // Every 5 minutes
               
                lastStatusUpdate = currentTime;
            }
        }
    }
    
    // PRINCIPLE 15: TIMEOUT MANAGEMENT
    // Check if recovery order has been open for too long
    if(recoveryOrderExists && g_RecoveryOrderOpenTime > 0) {
        int hoursOpen = (int)(currentTime - g_RecoveryOrderOpenTime) / 3600;
        
        // Resume trading logic - if enabled and enough time has passed
        if(EnableResumeTrading && !g_HasResumedTrading && hoursOpen >= ResumeTradeAfterHours) {
            g_HasResumedTrading = true;
            g_RecoveryResumeTime = currentTime;
      
        }
        
        // Timeout check
        if(hoursOpen >= RecoveryMaxLifetimeHours) {
       
         
            trade.PositionClose(g_RecoveryOrderTicket);
            
            timeoutDetected = true;
        }
    }
    
    // PRINCIPLE 16: EARLY PROFIT DETECTION
  
    
    // PRINCIPLE 17: MARKET REVERSAL DETECTION
    // If market has reversed significantly against our recovery order, consider cutting losses
    if(recoveryOrderExists) {
        ENUM_POSITION_TYPE recoveryType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double currentPrice = GetCleanPrice();
        int directionBias = AnalyzeMarketDirection();
        
        bool strongAdverse = false;
        if(recoveryType == POSITION_TYPE_BUY && directionBias <= -80 && currentPrice < openPrice) {
            strongAdverse = true;
        } else if(recoveryType == POSITION_TYPE_SELL && directionBias >= 80 && currentPrice > openPrice) {
            strongAdverse = true;
        }
        
        if(strongAdverse && recoveryProfit < -MathAbs(RecoveryProfitTarget) * 0.5) {
          
            // Consider closing if loss exceeds half of target
            // In a real system, you might want to add more conditions here
        }
    }
    
    // Check if recovery target has been reached
    if(CheckAndCloseOnRecoveryTarget()) {
        g_HasResumedTrading = false;  // Reset resume trading flag
        return; // Exit function if positions closed due to target reached
    }
    
    // Reset recovery mode if timeout occurred or recovery order is gone
    if(timeoutDetected || (!recoveryOrderExists && !CheckAndStartNewRecovery())) {
        g_InRecoveryMode = false;
        g_RecoveryOrderTicket = 0;
        g_RecoveryOrderOpenTime = 0;
        g_RecoveryAttempts = 0;
        g_HasResumedTrading = false;  // Reset resume trading flag
    }
}

// Modified CheckAndCloseOnRecoveryTarget for clearer behavior
bool CheckAndCloseOnRecoveryTarget() {
    if(!g_InRecoveryMode || RecoveryProfitTarget <= 0) return false;
    
    // Calculate total current profit
    double totalProfit = 0;
    int positionCount = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        totalProfit += PositionGetDouble(POSITION_PROFIT);
        positionCount++;
    }
    
    // PRINCIPLE 18: INCREMENTAL TARGET REDUCTION
    // As time passes, gradually reduce the required profit target
    double adjustedTarget = RecoveryProfitTarget;
    int recoveryAgeHours = 0;
    
    if(g_RecoveryOrderOpenTime > 0) {
        recoveryAgeHours = (int)(TimeCurrent() - g_RecoveryOrderOpenTime) / 3600;
        
        // Reduce target by 10% for each hour, down to a minimum of 30%
        double reductionFactor = MathMax(0.3, 1.0 - (recoveryAgeHours * 0.1));
        adjustedTarget *= reductionFactor;
    }
    
    // Check if profit target is reached
    if(totalProfit >= adjustedTarget && positionCount > 0) {
  
        // Reset recovery metrics since this recovery was successful
        g_ConsecutiveRecoveries = 0;
        
        // Close all positions
        CloseAllPositions();
        
        // Reset recovery mode and cycle flag
        g_InRecoveryMode = false;
        g_RecoveryOrderTicket = 0;
        g_RecoveryOrderOpenTime = 0;
        g_RecoveryAttempts = 0;
        g_RecoveryDCACount = 0;
        g_RecoveryOpenedInCurrentCycle = false;
        g_HasResumedTrading = false;
        
        return true;
    }
    
    return false;
}



// Globals
enum TradeDirectionMode {
    DIR_MODE_BOTH,
    DIR_MODE_BUY_ONLY,
    DIR_MODE_SELL_ONLY,
    DIR_MODE_DISABLED
};

TradeDirectionMode g_TradeDirectionMode = DIR_MODE_BOTH;

// Hàm phân tích và cập nhật direction
void UpdateAllowedTradeDirection() {
    // Chỉ update mỗi 5 phút
    if(TimeCurrent() - g_LastDirectionUpdate < 300) return;
    g_LastDirectionUpdate = TimeCurrent();
    
    // Phân tích positions hiện tại
    int buyCount = 0, sellCount = 0;
    double buyProfit = 0, sellProfit = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double profit = PositionGetDouble(POSITION_PROFIT);
        
        if(posType == POSITION_TYPE_BUY) {
            buyCount++;
            buyProfit += profit;
        } else {
            sellCount++;
            sellProfit += profit;
        }
    }
    
    // Nếu không có lệnh nào, cho phép cả 2
    if(buyCount == 0 && sellCount == 0) {
        g_TradeDirectionMode = DIR_MODE_BOTH;
        return;
    }
    
    // Check drawdown threshold
    double totalDrawdown = 0;
    if(buyProfit < 0) totalDrawdown += MathAbs(buyProfit);
    if(sellProfit < 0) totalDrawdown += MathAbs(sellProfit);
    
    // Chỉ can thiệp khi drawdown > 50% limit
    if(totalDrawdown < MaxDailyDrawdown * 0.5) {
        g_TradeDirectionMode = DIR_MODE_BOTH;
        return;
    }
    
    // Phân tích trend direction
    double adx[], plus_di[], minus_di[];
    bool isTrendingUp = false, isTrendingDown = false;
    
    if(CopyBuffer(g_ADX_Handle, 0, 0, 1, adx) >= 1 &&
       CopyBuffer(g_ADX_Handle, 1, 0, 1, plus_di) >= 1 &&
       CopyBuffer(g_ADX_Handle, 2, 0, 1, minus_di) >= 1) {
        
        if(adx[0] > 25) { // Strong trend
            isTrendingUp = (plus_di[0] > minus_di[0] && plus_di[0] > 25);
            isTrendingDown = (minus_di[0] > plus_di[0] && minus_di[0] > 25);
        }
    }
    
    // Xác định direction mode
    // BUY đang lỗ nhiều + trend down -> stop BUY
    if(buyProfit < sellProfit * 2 && buyProfit < 0 && isTrendingDown) {
        g_TradeDirectionMode = DIR_MODE_SELL_ONLY;
        return;
    }
    
    // SELL đang lỗ nhiều + trend up -> stop SELL
    if(sellProfit < buyProfit * 2 && sellProfit < 0 && isTrendingUp) {
        g_TradeDirectionMode = DIR_MODE_BUY_ONLY;
        return;
    }
    
    // Check volume profile support
    double currentPrice = GetCleanPrice();
    double volumeMultiplier = GetVolumeMultiplierAtPrice(currentPrice);
    
    // Low volume zone = tránh cả 2 direction
    if(volumeMultiplier < 0.8 && totalDrawdown > MaxDailyDrawdown * 0.7) {
        g_TradeDirectionMode = DIR_MODE_DISABLED;
        return;
    }
    
    // Default: cho phép cả 2
    g_TradeDirectionMode = DIR_MODE_BOTH;
}

// Hàm check có thể mở lệnh theo direction
bool CanTradeDirection(ENUM_POSITION_TYPE posType) {
    if(g_TradeDirectionMode == DIR_MODE_BOTH) return true;
    if(g_TradeDirectionMode == DIR_MODE_DISABLED) return false;
    if(g_TradeDirectionMode == DIR_MODE_BUY_ONLY && posType == POSITION_TYPE_BUY) return true;
    if(g_TradeDirectionMode == DIR_MODE_SELL_ONLY && posType == POSITION_TYPE_SELL) return true;
    return false;
}
// Hàm phân tích volume tại vùng giá
double GetVolumeMultiplierAtPrice(double price) {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M15, 0, 50, rates) < 50) return 1.0;
    
    // Tính average volume
    long totalVolume = 0;
    for(int i = 0; i < 50; i++) {
        totalVolume += rates[i].tick_volume;
    }
    double avgVolume = (double)totalVolume / 50;
    
    // Volume tại vùng giá hiện tại (±50 points)
    long volumeAtPrice = 0;
    int barsInZone = 0;
    
    for(int i = 0; i < 50; i++) {
        double priceDistance = MathAbs(price - rates[i].close) / _Point;
        if(priceDistance < 50) {
            volumeAtPrice += rates[i].tick_volume;
            barsInZone++;
        }
    }
    
    if(barsInZone == 0) return 1.0;
    
    double volumeRatio = (double)volumeAtPrice / (avgVolume * barsInZone);
    
    // Low volume zone (< 0.7x avg) = good entry
    if(volumeRatio < 0.7) return 1.15;
    
    // High volume zone (> 1.5x avg) = rejection zone
    if(volumeRatio > 1.5) return 0.75;
    
    return 1.0; // Normal volume
}

void HandleParallelDCA(double currentPrice) {
    // Ki?m tra gi?i h?n chu k?
    if(!EnforcePeriodOrderLimits()) {
        return;
    }
     if(EnablePriceZoneStrategy && HasAnyZoneOrders()) {
        // Skip hedging if zone orders exist
        static datetime lastHedgeSkipLog = 0;
        if(TimeCurrent() - lastHedgeSkipLog > 300) {
            lastHedgeSkipLog = TimeCurrent();
        }
    }
    // Phân tích các v? th? hi?n t?i
    OrderGroup buyGroup, sellGroup;
    buyGroup.Initialize();
    sellGroup.Initialize();
    
    // C?u trúc ?? theo dõi l?nh Recovery DCA
    struct RecoveryDCAInfo {
        bool hasRecoveryOrders;   // Có l?nh recovery không
        int recoveryOrderCount;    // S? l??ng l?nh recovery
        double lastRecoveryPrice;  // Giá l?nh recovery cu?i cùng
        datetime lastRecoveryTime; // Th?i gian l?nh recovery cu?i
    };
    
    RecoveryDCAInfo buyRecovery = {false, 0, 0, 0};
    RecoveryDCAInfo sellRecovery = {false, 0, 0, 0};
    
    // Phân tích t?t c? các l?nh ?? tìm l?nh Recovery DCA
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        string comment = PositionGetString(POSITION_COMMENT);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        
        // Ch? tìm l?nh Recovery DCA
        if(StringFind(comment, "Recovery DCA") >= 0) {
            if(posType == POSITION_TYPE_BUY) {
                buyRecovery.hasRecoveryOrders = true;
                buyRecovery.recoveryOrderCount++;
                
                // C?p nh?t giá và th?i gian l?nh recovery g?n nh?t
                if(openTime > buyRecovery.lastRecoveryTime) {
                    buyRecovery.lastRecoveryTime = openTime;
                    buyRecovery.lastRecoveryPrice = openPrice;
                }
            } else {
                sellRecovery.hasRecoveryOrders = true;
                sellRecovery.recoveryOrderCount++;
                
                // C?p nh?t giá và th?i gian l?nh recovery g?n nh?t
                if(openTime > sellRecovery.lastRecoveryTime) {
                    sellRecovery.lastRecoveryTime = openTime;
                    sellRecovery.lastRecoveryPrice = openPrice;
                }
            }
        }
    }
    
  
    // X? lý DCA cho l?nh Recovery BUY
    if(buyRecovery.hasRecoveryOrders) {
        // L?y kho?ng cách DCA t? input cho l?nh ti?p theo
        int nextOrderNumber = buyRecovery.recoveryOrderCount + 1;
        double requiredDistance = GetExactDCADistance(nextOrderNumber);
        
        // Tính kho?ng cách hi?n t?i
        double currentDistance = MathAbs(currentPrice - buyRecovery.lastRecoveryPrice) / _Point;
        
        // Ch? x? lý n?u giá hi?n t?i TH?P H?N giá l?nh recovery g?n nh?t (cho BUY)
        if(currentPrice < buyRecovery.lastRecoveryPrice) {
         
                  
            if(currentDistance >= requiredDistance) {
                // Ki?m tra kho?ng cách t?i thi?u v?i t?t c? l?nh Buy hi?n có
                bool allDistancesOK = true;
                for(int i = PositionsTotal() - 1; i >= 0; i--) {
                    ulong ticket = PositionGetTicket(i);
                    if(!PositionSelectByTicket(ticket)) continue;
                    if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                    if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_BUY) continue;
                    
                    double orderPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                    double orderDistance = MathAbs(currentPrice - orderPrice) / _Point;
                    
                    if(orderDistance < MinimumOrderDistance) {
                        allDistancesOK = false;
                        break;
                    }
                }
                
                if(allDistancesOK) {
                    // Check AI Block trước khi mở Buy DCA
                    if(g_AI_BlockDCA_Buy) {
                        return;
                    }

                    // S? d?ng hàm GetNextLotSize cho l?nh ti?p theo
                    double volume = GetNextLotSize(POSITION_TYPE_BUY);

                    // T?o comment cho l?nh Recovery DCA
                    string comment = StringFormat("Recovery DCA %s #%d",
                                               "Buy", nextOrderNumber);

                    // S? d?ng OpenOrder ?? m? l?nh Recovery DCA
                    bool result = trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, volume, currentPrice, 0, 0, comment);
                    
                    if(result) {
                     
                    } else {
                    }
                }
            }
        }
    }
    
    // X? lý DCA cho l?nh Recovery SELL
    if(sellRecovery.hasRecoveryOrders) {
        // L?y kho?ng cách DCA t? input cho l?nh ti?p theo
        int nextOrderNumber = sellRecovery.recoveryOrderCount + 1;
        double requiredDistance = GetExactDCADistance(nextOrderNumber);
        
        // Tính kho?ng cách hi?n t?i
        double currentDistance = MathAbs(currentPrice - sellRecovery.lastRecoveryPrice) / _Point;
        
        // Ch? x? lý n?u giá hi?n t?i CAO H?N giá l?nh recovery g?n nh?t (cho SELL)
        if(currentPrice > sellRecovery.lastRecoveryPrice) {
      
                  
            if(currentDistance >= requiredDistance) {
                // Ki?m tra kho?ng cách t?i thi?u v?i t?t c? l?nh Sell hi?n có
                bool allDistancesOK = true;
                for(int i = PositionsTotal() - 1; i >= 0; i--) {
                    ulong ticket = PositionGetTicket(i);
                    if(!PositionSelectByTicket(ticket)) continue;
                    if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                    if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_SELL) continue;
                    
                    double orderPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                    double orderDistance = MathAbs(currentPrice - orderPrice) / _Point;
                    
                    if(orderDistance < MinimumOrderDistance) {
                        allDistancesOK = false;
                        break;
                    }
                }
                
                if(allDistancesOK) {
                    // Check AI Block trước khi mở Sell DCA
                    if(g_AI_BlockDCA_Sell) {
                        return;
                    }

                    // S? d?ng hàm GetNextLotSize cho l?nh ti?p theo
                    double volume = GetNextLotSize(POSITION_TYPE_SELL);

                    // T?o comment cho l?nh Recovery DCA
                    string comment = StringFormat("Recovery DCA %s #%d",
                                               "Sell", nextOrderNumber);

                    // S? d?ng OpenOrder ?? m? l?nh Recovery DCA
                    bool result = trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, volume, currentPrice, 0, 0, comment);
                    
                    if(result) {
                     
                    } else {
                    
                    }
                }
            }
        }
    }
    
    // Ti?p t?c x? lý DCA cho các l?nh th??ng và hedge
    AnalyzeOrderGroups(buyGroup, sellGroup);
    
    // X? lý DCA cho l?nh Buy th??ng
    if(buyGroup.hasRegularOrders && g_TotalOrders_Buy>0) {
        double regularDistance = MathAbs(currentPrice - buyGroup.lastRegularPrice) / _Point;
        double requiredDistance = GetExactDCADistance(buyGroup.regularCount + 1);
        
        if(regularDistance >= requiredDistance && currentPrice < buyGroup.lastRegularPrice) {
            if(CheckMinimumDistanceBetweenOrders(currentPrice, POSITION_TYPE_BUY)) {
                // Check AI Block trước khi mở Buy DCA
                if(g_AI_BlockDCA_Buy) {
                    return;
                }

                double volume = GetNextLotSize(POSITION_TYPE_BUY);
                string comment = StringFormat("%s %d || L%d",
                                          BuyComment,
                                          g_ActiveBuyCycles,
                                          buyGroup.regularCount + 1);

                if(OpenOrder(ORDER_TYPE_BUY, volume, currentPrice)) {
                }
            }
        }
    }
    
    // X? lý DCA cho l?nh Sell th??ng
    if(sellGroup.hasRegularOrders && g_TotalOrders_Sell > 0) {
        double regularDistance = MathAbs(currentPrice - sellGroup.lastRegularPrice) / _Point;
        double requiredDistance = GetExactDCADistance(sellGroup.regularCount + 1);
        
        if(regularDistance >= requiredDistance && currentPrice > sellGroup.lastRegularPrice) {
            if(CheckMinimumDistanceBetweenOrders(currentPrice, POSITION_TYPE_SELL)) {
                // Check AI Block trước khi mở Sell DCA
                if(g_AI_BlockDCA_Sell) {
                    return;
                }

                double volume = GetNextLotSize(POSITION_TYPE_SELL);
                string comment = StringFormat("%s %d || L%d",
                                          SellComment,
                                          g_ActiveSellCycles,
                                          sellGroup.regularCount + 1);

                if(OpenOrder(ORDER_TYPE_SELL, volume, currentPrice)) {
                }
            }
        }
    }
}
// Completely rewrite this function to match exactly the DCA gap calculation used in normal trading
double CalculateRecoveryDCADistance(int orderNumber) {
    // DIRECTLY use the custom DCA gap values that normal trading uses
    return GetCustomHedgeDCAGap(orderNumber);
}

// This function is what needs to be used for recovery DCA - it gets the exact gaps from the input parameters
double GetRecoveryDCAGap(int orderNumber) {
    // This is a direct copy of the normal cycle gap function
    switch(orderNumber) {
        case 1: return FirstOrderGap;
        case 2: return SecondOrderGap;
        case 3: return ThirdOrderGap;
        case 4: return FourthOrderGap;
        case 5: return FifthOrderGap;
        case 6: return SixthOrderGap;
        case 7: return SeventhOrderGap;
        case 8: return EighthOrderGap;
        case 9: return NinthOrderGap;
        case 10: return TenthOrderGap;
        case 11: return EleventhOrderGap;
        case 12: return TwelfthOrderGap;
        case 13: return ThirteenthOrderGap;
        case 14: return FourteenthOrderGap;
        case 15: return FifteenthOrderGap;
        case 16: return SixteenthOrderGap;
        default: return DCADistance;
    }
}



// Modify the OpenHedgeDCAOrder function to check for recovery mode
bool OpenHedgeDCAOrder(ENUM_ORDER_TYPE orderType, double volume, double currentPrice) {
    // Add recovery mode check
    // Direct period limit check first
    if(!EnforcePeriodOrderLimits()) {
        return false;
    }
    
    if(!CanOpenMoreOrdersInPeriod()) {
        return false;
    }
    
    ENUM_POSITION_TYPE posType = (orderType == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
    string comment = StringFormat("Hedge DCA %s", orderType == ORDER_TYPE_BUY ? "Buy" : "Sell");
    
    // Double check distance with extra before opening
    int hedgeCount = CountHedgeOrders(posType);
    double lastPrice = GetLatestHedgeOrderPrice(posType);
    
    if(lastPrice > 0) {
        double baseDistance = GetBaseDCADistance(hedgeCount + 1);
        double extraDistance = GetPeriodExtraDistance();
        double totalRequired = baseDistance + AdjustExtraDistance(extraDistance, CalculateMarketRange());
        double currentDistance = MathAbs(currentPrice - lastPrice) / _Point;
        
        if(currentDistance < totalRequired) {
   
            return false;
        }
    }
    
    // Calculate TP using weighted average
    double weightedSum = currentPrice * volume;
    double totalVolume = volume;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string orderComment = PositionGetString(POSITION_COMMENT);
        if(StringFind(orderComment, "Hedge") >= 0) {
            double orderVolume = PositionGetDouble(POSITION_VOLUME);
            double orderPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            weightedSum += orderPrice * orderVolume;
            totalVolume += orderVolume;
        }
    }
    
    if(totalVolume <= 0) return false;
    
    double avgPrice = NormalizeDouble(weightedSum / totalVolume, _Digits);
    // int tpPoints = GetPeriodTP(); // DISABLED: Using virtual TP/SL
    

    bool result = trade.PositionOpen(_Symbol, orderType, volume, currentPrice, 0, 0, comment);
    
    if(result) {
  
    }
    
    return result;
}



// Optional enhancement: Add a function to clean up existing hedge orders when entering recovery mode
void CleanupHedgeOrdersOnRecovery() {
    if(g_InRecoveryMode) return;
    
    int closedCount = 0;
    

    
    if(closedCount > 0) {
    } else {
    }
    
    // Reset hedge tracking variables
    g_HasActiveHedgeOrder = false;
    g_ActiveHedgeBuys = 0;
    g_ActiveHedgeSells = 0;
    g_InHedgeCycle = false;
}

// Hàm ki?m tra n?n M1 ?óng



void ResetDailyRecoveryFlag() {
    datetime currentTime = TimeCurrent();
    MqlDateTime current_struct;
    TimeToStruct(currentTime, current_struct);
    
    // Get date of last reset
    MqlDateTime last_struct;
    TimeToStruct(g_LastRecoveryDayReset, last_struct);
    
    // Reset flag at the start of a new day
    if(g_LastRecoveryDayReset == 0 || current_struct.day != last_struct.day) {
        g_DailyRecoveryUsed = false;
        g_LastRecoveryDayReset = currentTime;
  
    }
}
// Add these global variables at the top with other global variables
int g_TrendOrderCount = 0;                  // Tracks number of orders in trend cycle
datetime g_LastTrendOrderTime = 0;          // Tracks when the last trend order was placed
double g_LastTrendOrderPrice = 0;           // Tracks the price of the last trend order
datetime g_TrendLimitPlacementTime = 0;     // Tracks when trend limit order was placed
const int TREND_LIMIT_MAX_LIFETIME = 3600;  // Maximum lifetime for trend limit orders (1 hour)
bool g_HasPendingTrendOrder = false;        // Tracks if there's a pending trend limit order


// Check and delete unfilled trend limit orders
void CheckAndDeleteUnfilledTrendLimits() {
    datetime currentTime = TimeCurrent();
    
    // Only check every 5 minutes to avoid excessive processing
    static datetime lastTrendLimitCheck = 0;
    if(currentTime - lastTrendLimitCheck < 300) return;
    lastTrendLimitCheck = currentTime;
    
    // Skip if no trend limit orders were recently placed
    if(g_TrendLimitPlacementTime == 0 || !g_HasPendingTrendOrder) return;
    
    // Check if it's been long enough since we placed a trend limit order
    if(currentTime - g_TrendLimitPlacementTime > TREND_LIMIT_MAX_LIFETIME) {
        bool foundTrendLimit = false;
        
        // Look for pending trend limit orders
        for(int i = OrdersTotal() - 1; i >= 0; i--) {
            ulong ticket = OrderGetTicket(i);
            if(!OrderSelect(ticket)) continue;
            if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
            
            string comment = OrderGetString(ORDER_COMMENT);
            if(StringFind(comment, "Trend Follow") >= 0) {
                ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
                
                // Make sure it's a limit order
                if(orderType == ORDER_TYPE_BUY_LIMIT || orderType == ORDER_TYPE_SELL_LIMIT) {
                  if(trade.OrderDelete(ticket)) {
                    } else {
                    }
                    
                    foundTrendLimit = true;
                }
            }
        }
        
        // Reset tracking if we found and processed trend limits
        if(foundTrendLimit) {
            g_TrendLimitPlacementTime = 0;
            g_HasPendingTrendOrder = false;
        } else {
            // If no trend limits found but the flag is set, it means they've been filled or manually deleted
            // In either case, we should reset the tracker
            g_TrendLimitPlacementTime = 0;
            g_HasPendingTrendOrder = false;
        }
    } else {
        int minutesRemaining = (TREND_LIMIT_MAX_LIFETIME - (currentTime - g_TrendLimitPlacementTime)) / 60;
    }
}

// Function to check if market conditions have changed significantly for trend orders
bool HaveMarketConditionsChangedForTrend() {
    static int lastMarketDirection = 0;
    static double lastMarketVolatility = 0;
    int currentMarketDirection = AnalyzeMarketDirection();
    double currentMarketVolatility = CalculateMarketRange();
    
    // Check for significant changes
    bool directionChanged = (lastMarketDirection * currentMarketDirection < 0) && // Changed sign
                            (MathAbs(currentMarketDirection) > 40); // And is significant
                            
    bool volatilityChanged = (currentMarketVolatility > lastMarketVolatility * 1.5) || // 50% increase
                             (currentMarketVolatility < lastMarketVolatility * 0.5);  // 50% decrease
    
    // Update stored values
    lastMarketDirection = currentMarketDirection;
    lastMarketVolatility = currentMarketVolatility;
    
    return directionChanged || volatilityChanged;
}



void ManagePendingOrders() {
    static datetime lastCheck = 0;
    datetime currentTime = TimeCurrent();
    
    // Only check every 30 seconds to reduce load
    if(currentTime - lastCheck < 30) return;
    lastCheck = currentTime;
    
    // SIMPLIFIED: Remove market direction and condition checks
    
    // Check and update Buy Limit orders
    for(int i = 0; i < g_BuyZonesCount; i++) {
        if(g_BuyZones[i].pendingOrderTicket > 0) {
            // Check if order still exists
            if(!OrderSelect(g_BuyZones[i].pendingOrderTicket)) {
                g_BuyZones[i].pendingOrderTicket = 0;
                continue;
            }
            
            // Check expiry only
            if(currentTime > g_BuyZones[i].expiryTime) {
                trade.OrderDelete(g_BuyZones[i].pendingOrderTicket);
                g_BuyZones[i].pendingOrderTicket = 0;
                continue;
            }
            
            // REMOVED: Market direction and condition change checks
        }
    }
    
    // Check and update Sell Limit orders - same simplification
    for(int i = 0; i < g_SellZonesCount; i++) {
        if(g_SellZones[i].pendingOrderTicket > 0) {
            // Check if order still exists
            if(!OrderSelect(g_SellZones[i].pendingOrderTicket)) {
                g_SellZones[i].pendingOrderTicket = 0;
                continue;
            }
            
            // Check expiry only
            if(currentTime > g_SellZones[i].expiryTime) {
                trade.OrderDelete(g_SellZones[i].pendingOrderTicket);
                g_SellZones[i].pendingOrderTicket = 0;
                continue;
            }
            
            // REMOVED: Market direction and condition change checks
        }
    }
}

// Simplify trend order functions as well
bool OpenTrendOrder(ENUM_ORDER_TYPE orderType) {
    // Keep safety checks
    if(HasActiveTrendOrder() || HasPendingTrendOrder()) return false;
     if(!CheckAndUpdateDrawdownStatus()) {
        return false;
    }
    if(!EnforcePeriodOrderLimits()) {
        return false;
    }
     if(EnablePriceZoneStrategy && HasAnyZoneOrders()) {
        // Skip hedging if zone orders exist
        static datetime lastHedgeSkipLog = 0;
        if(TimeCurrent() - lastHedgeSkipLog > 300) {
            lastHedgeSkipLog = TimeCurrent();
        }
    }
    // Skip cooldown and market condition checks - SIMPLIFIED
    g_TrendOrderMutex = true;

    double currentPrice = GetCleanPrice();
    double limitPrice;
    string comment;
    
    bool isNewTrendCycle = (g_TrendOrderCount == 0 || g_LastTrendOrderPrice == 0);
    if(isNewTrendCycle) g_TrendOrderCount = 1;
    else g_TrendOrderCount++;
    
    // Calculate based on PRICE ONLY
    if(orderType == ORDER_TYPE_BUY) {
        limitPrice = NormalizeDouble(currentPrice - (99990* _Point), _Digits);
        comment = "Trend Follow Buy " + IntegerToString(g_TrendOrderCount);
    } else {
        limitPrice = NormalizeDouble(currentPrice + (99999 * _Point), _Digits);
        comment = "Trend Follow Sell " + IntegerToString(g_TrendOrderCount);
    }

    double lotSize = isNewTrendCycle ? defaultFixLength :
                    GetNextLotSize((orderType == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL);

    ENUM_ORDER_TYPE limitOrderType = (orderType == ORDER_TYPE_BUY) ? ORDER_TYPE_BUY_LIMIT : ORDER_TYPE_SELL_LIMIT;

    // Final safety check
    if(HasActiveTrendOrder() || HasPendingTrendOrder()) {
        g_TrendOrderMutex = false;
        return false;
    }

    bool result = trade.OrderOpen(
        _Symbol,
        limitOrderType,
        lotSize,
        0,
        limitPrice,
        0,
        0,
        0,
        0,
        comment
    );
        datetime currentTime = TimeCurrent();

    if(result) {
        g_HasPendingTrendOrder = true;
        g_TrendLimitPlacementTime = currentTime;
  
    }
    
    g_TrendOrderMutex = false;
    return result;
}

// REMOVE market condition checks from trend order management
void CheckAndDeleteTrendLimitsOnMarketChange() {
    // SIMPLIFIED: Don't check market conditions, only delete based on timeout
    if(g_TrendLimitPlacementTime == 0 || !g_HasPendingTrendOrder) return;
    
    // Only delete based on time
    datetime currentTime = TimeCurrent();
    if(currentTime - g_TrendLimitPlacementTime > TREND_LIMIT_MAX_LIFETIME) {
        DeleteAllPendingTrendOrders();
    }
}

// Helper function to delete all pending trend orders
void DeleteAllPendingTrendOrders() {
    bool foundTrendLimit = false;
    
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Trend Follow") >= 0) {
            ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            
            if(orderType == ORDER_TYPE_BUY_LIMIT || orderType == ORDER_TYPE_SELL_LIMIT) {
                if(trade.OrderDelete(ticket)) {
                    foundTrendLimit = true;
                }
            }
        }
    }
    
    if(foundTrendLimit) {
        g_TrendLimitPlacementTime = 0;
        g_HasPendingTrendOrder = false;
    }
}
void CheckTrendDCAOpportunity() {
    // Only proceed if we have an active trend order
    if(!HasActiveTrendOrder()) return;
    
    // Verify the trend order still exists
    if(!PositionSelectByTicket(g_CurrentTrendTicket)) {
        g_HasActiveTrendOrder = false;
        g_CurrentTrendTicket = 0;
        g_LastTrendOrderPrice = 0;
        g_TrendOrderCount = 0;
        return;
    }
    
    // Only check periodically to reduce processing load
    datetime currentTime = TimeCurrent();
    static datetime lastTrendDCACheck = 0;
    if(currentTime - lastTrendDCACheck < 60) return; // Check once per minute
    lastTrendDCACheck = currentTime;
    
    // Get trend order information
    ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    ENUM_ORDER_TYPE orderType = (posType == POSITION_TYPE_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    
    // Get current price
    double currentPrice = GetCleanPrice();
    
    // UPDATED: Use the standard DCA distance calculation
    double requiredDistance = GetStandardDCADistance(g_TrendOrderCount + 1);
    double currentDistance = MathAbs(currentPrice - g_LastTrendOrderPrice) / _Point;
    
    // Direction check
    bool validDirection = false;
    if(posType == POSITION_TYPE_BUY && currentPrice < g_LastTrendOrderPrice) validDirection = true;
    if(posType == POSITION_TYPE_SELL && currentPrice > g_LastTrendOrderPrice) validDirection = true;
    
  
    
    // Check if we should add a DCA order to the trend
    // THÊM VÀO: C?p nh?t TP g?p n?u ?? s? l?nh
    if(g_TrendOrderCount >= CombinedTPLevel) {
        // UpdateCombinedTP(posType, true); // true = bao g?m l?nh trend
    }
    
    if(currentDistance >= requiredDistance && validDirection && g_TrendOrderCount < MaxOrders) {
        // Check minimum distance from all orders
        if(CheckMinimumDistanceBetweenOrders(currentPrice, posType)) {
            OpenTrendDCAOrder(orderType, GetNextLotSize(posType), currentPrice);
        }
    }
}

// Modified OpenTrendDCAOrder to use limit orders
void OpenTrendDCAOrder(ENUM_ORDER_TYPE orderType, double volume, double currentPrice) {
    ENUM_POSITION_TYPE posType = (orderType == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
          // Direct period limit check first
    if(!EnforcePeriodOrderLimits()) {
        return ;
    } if(EnablePriceZoneStrategy && HasAnyZoneOrders()) {
        // Skip hedging if zone orders exist
        static datetime lastHedgeSkipLog = 0;
        if(TimeCurrent() - lastHedgeSkipLog > 300) {
            lastHedgeSkipLog = TimeCurrent();
        }
    }
    
    // Calculate limit price
    double limitPrice;
    if(orderType == ORDER_TYPE_BUY) {
        // For Buy Limit, place below current price
        limitPrice = NormalizeDouble(currentPrice - (2998 * _Point), _Digits); // 2 pips below
    } else {
    
        // For Sell Limit, place above current price
        limitPrice = NormalizeDouble(currentPrice + (2998 * _Point), _Digits); // 2 pips above
    }
    
    string comment = StringFormat("Trend Follow %s DCA %d", 
                                  (orderType == ORDER_TYPE_BUY) ? "Buy" : "Sell",
                                  g_TrendOrderCount + 1);
                                
    // Calculate takeProfit using standard logic
    // double takeProfit = CalculateOrderTP( // DISABLEDorderType, limitPrice, g_TrendOrderCount + 1);
    
    // Convert to limit order type
    ENUM_ORDER_TYPE limitOrderType = (orderType == ORDER_TYPE_BUY) ? ORDER_TYPE_BUY_LIMIT : ORDER_TYPE_SELL_LIMIT;
    
    if(IsValidTPLevel(limitPrice,900, posType)) {
        bool result = trade.OrderOpen(
            _Symbol,
            limitOrderType,
            volume,
            0, // Current price not used
            limitPrice,
            0, // No SL
            0, // No expiration
            0, // No expiration time
            comment
        );
        
        if(result) {
            g_TrendOrderCount++;
            g_LastTrendOrderTime = TimeCurrent();
            g_LastTrendOrderPrice = limitPrice;
             if(g_TrendOrderCount >= CombinedTPLevel) {
        // UpdateCombinedTP(posType, true);
    }
       
        }
    }
}
void CloseTrendCycle() {
    
    // Close any pending trend limit orders first
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Trend Follow") >= 0) {
            if(trade.OrderDelete(ticket)) {
            }
        }
    }
    
    // Then close any active trend positions
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Trend Follow") >= 0) {
            // SOLUCIÓN: Realmente cerrar la posición
            if(trade.PositionClose(ticket)) {
            } else {
            }
        }
    }
    
    // Reset trend tracking variables
    g_HasActiveTrendOrder = false;
    g_CurrentTrendTicket = 0;
    g_LastTrendOrderPrice = 0;
    g_TrendOrderCount = 0;
    g_LastTPTime = TimeCurrent();
    g_HasPendingTrendOrder = false;
    g_TrendLimitPlacementTime = 0;
    
}

// Add these global variables at the top with other globals
datetime g_LastTrendOrderAttemptTime = 0;    // Tracks when we last tried to place a trend order
const int TREND_COOLDOWN_SECONDS = 60;       // Cooldown period between trend order attempts (1 minute)
static bool g_TrendOrderMutex = false;       // Mutex to prevent concurrent trend order operations

// Improved HasActiveTrendOrder function that checks both flags and actual positions
bool HasActiveTrendOrder() {
    // If our flag indicates there's an active trend order, verify it exists
    if(g_HasActiveTrendOrder && g_CurrentTrendTicket > 0) {
        if(PositionSelectByTicket(g_CurrentTrendTicket)) {
            // Verify it's actually a trend order
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Trend Follow") >= 0) {
                return true;
            } else {
                // Comment doesn't match, position exists but isn't a trend order
                g_HasActiveTrendOrder = false;
                g_CurrentTrendTicket = 0;
            }
        } else {
            // Position doesn't exist anymore
            g_HasActiveTrendOrder = false;
            g_CurrentTrendTicket = 0;
        }
    }
    
    // If flag is false or ticket doesn't exist, search for any trend orders
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Trend Follow") >= 0) {
            // Found a trend order, update our tracking
            g_HasActiveTrendOrder = true;
            g_CurrentTrendTicket = ticket;
            g_LastTrendOrderPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            return true;
        }
    }
    
    return false;
}

// Improved HasPendingTrendOrder function that checks both flags and actual orders
bool HasPendingTrendOrder() {
    // Skip full check if flag is already false
    if(!g_HasPendingTrendOrder) return false;
    
    // Check for any pending trend orders
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Trend Follow") >= 0) {
            ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            if(orderType == ORDER_TYPE_BUY_LIMIT || orderType == ORDER_TYPE_SELL_LIMIT) {
                return true;
            }
        }
    }
    
    // If we got here, we didn't find any pending trend orders
    g_HasPendingTrendOrder = false; // Update our tracking flag
    return false;
}


// Modified CheckForFilledTrendOrders with improved order management
void CheckForFilledTrendOrders() {
    // MUTEX PROTECTION: Skip if mutex is active
    if(g_TrendOrderMutex) return;
    
    // Skip if we don't think we have any pending trend orders
    if(!g_HasPendingTrendOrder) return;
    
    // Check if our flag indicates a pending order but none actually exists
    if(g_HasPendingTrendOrder && !HasPendingTrendOrder()) {
        // Check if we now have an active trend order instead (order was filled)
        if(HasActiveTrendOrder()) {
            g_HasPendingTrendOrder = false;
            g_TrendLimitPlacementTime = 0;
            
        } else {
            // Neither pending nor active order found - reset everything
            g_HasPendingTrendOrder = false;
            g_TrendLimitPlacementTime = 0;
            g_HasActiveTrendOrder = false;
            g_CurrentTrendTicket = 0;
            
        }
    }
}

// Modified ManageTrendFollowing function with improved safety checks
void ManageTrendFollowing() {
    // MUTEX PROTECTION: Skip if trend order processing is in progress
    if(g_TrendOrderMutex) return;
    
    // Check for filled trend limit orders and update flags
    CheckForFilledTrendOrders();
    
    // Check and delete unfilled trend limit orders if needed
    CheckAndDeleteUnfilledTrendLimits();
    
    // Check and delete trend limits if market conditions changed
    CheckAndDeleteTrendLimitsOnMarketChange();
    
    // Check for active trend order first with improved checking
    if(HasActiveTrendOrder()) {
        // First, check if the current trend order is in profit or hit TP
        double currentPrice = GetCleanPrice();
        if(PositionSelectByTicket(g_CurrentTrendTicket)) {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double tp = PositionGetDouble(POSITION_TP);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            // Check if TP hit
            bool tpHit = (posType == POSITION_TYPE_BUY && currentPrice >= tp) ||
                        (posType == POSITION_TYPE_SELL && currentPrice <= tp);
                        
            if(tpHit) {
                g_HasActiveTrendOrder = false;
                g_CurrentTrendTicket = 0;
                g_LastTPTime = TimeCurrent();
                g_LastTrendOrderPrice = 0;
                g_TrendOrderCount = 0;
                return;
            }
            
            // Check for DCA opportunity in trend
            CheckTrendDCAOpportunity();
        }
        else {
            // Trend order no longer exists, reset flags
            g_HasActiveTrendOrder = false;
            g_CurrentTrendTicket = 0;
            g_LastTrendOrderPrice = 0;
            g_TrendOrderCount = 0;
        }
        return;
    }

    // Don't open new trend orders if we already have a pending one
    if(HasPendingTrendOrder()) {
        return;
    }

    // Skip trend management if we have other orders
    if(HasInitialDCAOrders() || !IsTrendModeValid()) {
        return;
    }
    
    // Check cooldown period
    datetime currentTime = TimeCurrent();
    if(currentTime - g_LastTrendOrderAttemptTime < TREND_COOLDOWN_SECONDS) {
        return;
    }

    // Calculate market range and momentum for confirmation
    double marketRange = CalculateMarketRange();
    double momentum = MathAbs(CalculateMarketMomentum());
    
    // Additional trend confirmation checks
    bool strongMarketMovement = marketRange > g_CurrentAIThreshold && 
                               momentum > MomentumEntryThreshold;
    
    // Get optimal direction based on market analysis with high confidence threshold
    ENUM_ORDER_TYPE optimalDirection = GetOptimalTradeDirection(40); // Higher confidence (40%) for trend orders
    
    // Open new trend order if market conditions and direction align
    if(IsSpreadOK() && strongMarketMovement && optimalDirection != -1) {
        if(optimalDirection == ORDER_TYPE_BUY && EnableBuyOrders) {
            OpenTrendOrder(ORDER_TYPE_BUY);
        }
        else if(optimalDirection == ORDER_TYPE_SELL && EnableSellOrders) {
            OpenTrendOrder(ORDER_TYPE_SELL);
        }
    }
}
void ManageHedgeCycles() {
    // Skip if not in a hedge cycle
    if(!g_InHedgeCycle) return;
    
    double currentPrice = GetCleanPrice();
    int buyHedgeCount = 0, sellHedgeCount = 0;
    double buyHedgeProfit = 0, sellHedgeProfit = 0;
    bool buyHedgeTPReached = true, sellHedgeTPReached = true;
    
    // First pass: Count positions and calculate profits by type
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") < 0) continue; // Only process hedge positions
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        double profit = PositionGetDouble(POSITION_PROFIT);
        double tp = PositionGetDouble(POSITION_TP);
        
        // Track by position type
        if(posType == POSITION_TYPE_BUY) {
            buyHedgeCount++;
            buyHedgeProfit += profit;
            // Check if TP reached - must be BEYOND the TP level
            if(currentPrice < tp) {
                buyHedgeTPReached = false;
            }
        } else {
            sellHedgeCount++;
            sellHedgeProfit += profit;
            // Check if TP reached - must be BEYOND the TP level
            if(currentPrice > tp) {
                sellHedgeTPReached = false;
            }
        }
    }
    
    // No hedge positions found - reset hedge cycle
    if(buyHedgeCount == 0 && sellHedgeCount == 0) {
        g_InHedgeCycle = false;
        g_ActiveHedgeBuys = 0;
        g_ActiveHedgeSells = 0;
        g_HasActiveHedgeOrder = false;
        return;
    }
    
    // Detailed logging for debugging
    static datetime lastHedgeLog = 0;
    if(TimeCurrent() - lastHedgeLog > 30) { // Log every 30 seconds
     
        lastHedgeLog = TimeCurrent();
    }
    
    // Check buy hedge cycle completion
    if(buyHedgeCount > 0 && buyHedgeProfit > 0 && buyHedgeTPReached) {
     
        // Close all buy hedge positions
        CloseAllHedgePositions(POSITION_TYPE_BUY);
        
        // Reset buy hedge count
        g_ActiveHedgeBuys = 0;
    }
    
    // Check sell hedge cycle completion
    if(sellHedgeCount > 0 && sellHedgeProfit > 0 && sellHedgeTPReached) {
       // Close all sell hedge positions
        CloseAllHedgePositions(POSITION_TYPE_SELL);
        
        // Reset sell hedge count
        g_ActiveHedgeSells = 0;
    }
    
    // Check if entire hedge cycle is complete
    if(g_ActiveHedgeBuys == 0 && g_ActiveHedgeSells == 0) {
        g_InHedgeCycle = false;
        g_HasActiveHedgeOrder = false;
        g_LastHedgeTime = TimeCurrent();
    }
}
void CloseAllHedgePositions(ENUM_POSITION_TYPE posType) {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") >= 0) {
            if(trade.PositionClose(ticket)) {
            } else {
            }
        }
    }
}



// Thêm các khai báo bi?n toàn c?c m?i
input group "===== CHI?N L??C VÙNG GIÁ T?I ?U ====="
input bool EnablePriceZoneStrategy = true;      // B?t chi?n l??c vùng giá t?i ?u
input int MaxPendingOrders = 5;                 // S? l?nh ch? t?i ?a m?i lo?i (buy/sell)
input int PriceZoneValidity = 2;                // Th?i gian hi?u l?c vùng giá (gi?)
input bool CancelPendingOnMarketChange = true;  // H?y l?nh ch? khi th? tr??ng thay ??i 
input double KeyZoneMinDistance = 150;          // Kho?ng cách t?i thi?u gi?a các vùng (points)

// Vùng giá Fibonacci
input double FibLevel1 = 0.382;                 // M?c Fibonacci 1
input double FibLevel2 = 0.618;                 // M?c Fibonacci 2  
input double FibLevel3 = 0.786;                 // M?c Fibonacci 3
input double FibLevel4 = 0.886;                 // M?c Fibonacci 4

// Tham s? phát hi?n vùng giá
input int PriceHistoryPeriods = 300;            // S? n?n xem xét cho tính toán vùng giá
input int SwingStrength = 5;                    // ?? m?nh c?a swing ?? xác ??nh vùng

// K?t h?p ch? báo
input int RSIPeriod = 14;                       // Chu k? RSI
input int RSIOverbought = 70;                   // M?c quá mua RSI
input int RSIOversold = 30;                     // M?c quá bán RSI

// Bi?n toàn c?c m?i
struct PriceZone {
    double price;                               // Giá c?a vùng
    double strength;                            // ?? m?nh vùng (0-100)
    datetime expiryTime;                        // Th?i gian h?t h?n
    bool isSupportZone;                         // True n?u là vùng h? tr?, False n?u là kháng c?
    double entryProbability;                    // Xác su?t vào l?nh t?i vùng (0-100)
    int historicalTouches;                      // S? l?n giá ch?m vùng trong l?ch s?
    ulong pendingOrderTicket;                   // Ticket c?a l?nh ch? t?i vùng
};

PriceZone g_BuyZones[20];                       // M?ng l?u các vùng giá mua
PriceZone g_SellZones[20];                      // M?ng l?u các vùng giá bán
int g_BuyZonesCount = 0;                        // S? vùng giá mua
int g_SellZonesCount = 0;                       // S? vùng giá bán
datetime g_LastZoneCalculation = 0;             // Th?i gian tính toán vùng giá cu?i cùng
bool g_ZoneInitialized = false;                 // ?ã kh?i t?o vùng giá ch?a
double g_EMA_Buffer[];
double g_LastCleanPrice = 0;
int g_MFI_Handle = INVALID_HANDLE;
double g_MFI_Buffer[];

// GLOBALS - Thêm vào đầu file
double g_BoxHigh = 0;
double g_BoxLow = 0;
bool g_InsideBox = false;
datetime g_BoxLastUpdate = 0;
// Thêm globals để lưu box cũ
double g_PreviousBoxHigh = 0;
double g_PreviousBoxLow = 0;
datetime g_BoxBreakoutTime = 0;

bool                 g_IsInBox = true;

// Hàm phát hiện box trên H1
void DetectH1Box() {
    static datetime lastCheck = 0;
    datetime currentTime = TimeCurrent();
    
    // Update mỗi 1 giờ
    if(currentTime - lastCheck < 3600) return;
    lastCheck = currentTime;
    
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    
    if(CopyRates(_Symbol, PERIOD_H1, 0, 24, rates) < 24) return;
      double highest = rates[0].high;
    double lowest = rates[0].low;
    
    double currentPrice = GetCleanPrice();
        double boxRange = 31000* _Point;

    // KIỂM TRA GIÁ QUAY LẠI BOX CŨ
    if(g_PreviousBoxHigh > 0 && g_PreviousBoxLow > 0) {
        // Nếu giá quay lại trong box cũ
        if(currentPrice >= g_PreviousBoxLow && currentPrice <= g_PreviousBoxHigh) {
            double previousRange = (g_PreviousBoxHigh - g_PreviousBoxLow) / _Point;
            
            // Nếu box cũ vẫn hợp lệ (< 3100 points)
            if(previousRange < 31000) {
            // TÁI KÍCH HOẠT BOX CŨ
                g_BoxHigh = g_PreviousBoxHigh;
                g_BoxLow = g_PreviousBoxLow;
                g_BoxLastUpdate = currentTime;
                g_IsInBox = true;
                g_BoxBreakoutTime = 0;
                return;
            }
        } else {
            // Giá vẫn ngoài box cũ
            if(g_BoxBreakoutTime == 0) {
                g_BoxBreakoutTime = currentTime;
            }
            
            // Sau 24h ngoài box → xóa box cũ, tạo mới
            if(currentTime - g_BoxBreakoutTime > 800) {
                g_PreviousBoxHigh = 0;
                g_PreviousBoxLow = 0;
                g_BoxBreakoutTime = 0;
            }
        }
    }
    
    // TẠO BOX MỚI
  
    for(int i = 1; i < 24; i++) {
        if(rates[i].high > highest) highest = rates[i].high;
        if(rates[i].low < lowest) lowest = rates[i].low;
    }
    
   
    // Range hợp lệ cho box (< 3100 points)
    if(boxRange < 31000) {
        // Kiểm tra consolidation
        int barsInRange = 0;
        double boxMiddle = (highest + lowest) / 2;
        double boxHalfSize = (highest - lowest) / 2;
        
        for(int i = 0; i < 24; i++) {
            if(rates[i].close >= (boxMiddle - boxHalfSize) && 
               rates[i].close <= (boxMiddle + boxHalfSize)) {
                barsInRange++;
            }
        }
        
        double consolidationPercent = (double)barsInRange / 24 * 100;
        
        // Yêu cầu ít nhất 60% consolidation
        if(barsInRange >= 14) { // 60% của 24
          // Lưu box cũ trước khi update
            g_PreviousBoxHigh = g_BoxHigh;
            g_PreviousBoxLow = g_BoxLow;
            
            // Set box mới
            g_BoxHigh = highest;
            g_BoxLow = lowest;
            g_BoxLastUpdate = currentTime;
            g_IsInBox = true;
            g_BoxBreakoutTime = 0;
        } else {
            g_IsInBox = false;
        }
    } else {
        // Range quá rộng = trending
        
        // Lưu box hiện tại làm previous
        if(g_BoxHigh > 0 && g_BoxLow > 0) {
            g_PreviousBoxHigh = g_BoxHigh;
            g_PreviousBoxLow = g_BoxLow;
        }
        
        g_BoxHigh = 0;
        g_BoxLow = 0;
        g_IsInBox = false;
    }
}

bool IsInsideBox(double currentPrice) {
    if(g_BoxHigh == 0 || g_BoxLow == 0) return false;
    
    // Cho phép 50 points buffer
    double buffer = 5000 * _Point;
    return (currentPrice >= g_BoxLow - buffer && currentPrice <= g_BoxHigh + buffer);
}


// Hàm sideway trading hoàn chỉnh
void HandleSidewayBoxTrading(double currentPrice) {
    double boxMid = (g_BoxHigh + g_BoxLow) / 2;
    double boxRange = (g_BoxHigh - g_BoxLow) / _Point;
    
    // Tính vị trí trong box (0-100%)
    double positionInBox = 0;
    if(boxRange > 0) {
        positionInBox = ((currentPrice - g_BoxLow) / (g_BoxHigh - g_BoxLow)) * 100;
    }
    
    
    // =============================================================================
    // A. MỞ LỆNH ĐẦU TIÊN (NẾU CHƯA CÓ LỆNH)
    // =============================================================================
    
    if(g_TotalOrders_Buy == 0 && g_TotalOrders_Sell == 0) {
        // Gần box high (>70%) → SELL đầu tiên
        if( EnableSellOrders) {
            if(!ShouldAllowTrade(POSITION_TYPE_SELL)) return;
            
            double lotSize = defaultFixLength;
            double tp = boxMid; // TP ở giữa box
            string comment = "Box Sell #1";
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, currentPrice, 0, 0, comment)) {
                UpdateLastPriceWithVolumeProfile(POSITION_TYPE_SELL, currentPrice);
            }
            return;
        }
        
        // Gần box low (<30%) → BUY đầu tiên
        if(positionInBox < 30 && EnableBuyOrders) {
            if(!ShouldAllowTrade(POSITION_TYPE_BUY)) return;
            
            double lotSize = defaultFixLength;
            double tp = boxMid; // TP ở giữa box
            string comment = "Box Buy #1";
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, currentPrice, 0, 0, comment)) {
                UpdateLastPriceWithVolumeProfile(POSITION_TYPE_BUY, currentPrice);
            }
            return;
        }
    }
    
    // =============================================================================
    // B. DCA CHO SELL POSITIONS (KHI GIÁ TĂNG)
    // =============================================================================
    
    if( EnableSellOrders) {
        // Chỉ DCA khi gần box high (>75%)
        if(positionInBox > 75) {
            if(g_TotalOrders_Sell >= MaxOrders) return;
            // Check distance từ lệnh cuối
            if(g_LastSellPrice > 0) {
                double distance = (currentPrice - g_LastSellPrice) / _Point;
                double requiredDistance = GetAdjustedDCADistanceEnhanced(g_TotalOrders_Sell + 1, MARKET_NORMAL);
                
                if(distance < requiredDistance) return;
            }
            
            // Volume confirmation
            if(!HasStrongVolumeMomentum(POSITION_TYPE_SELL)) return;
            
            // Order flow check
            if(!ShouldAllowTrade(POSITION_TYPE_SELL)) return;
            
            double lotSize = GetNextLotSize(POSITION_TYPE_SELL);
            double tp = CalculateAveragePriceWithTP(POSITION_TYPE_SELL, currentPrice, lotSize);
            string comment = StringFormat("Box Sell DCA #%d", g_TotalOrders_Sell + 1);
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, currentPrice, 0, 0, comment)) {
                UpdateLastPriceWithVolumeProfile(POSITION_TYPE_SELL, currentPrice);
            }
        }
    }
    
    // =============================================================================
    // C. DCA CHO BUY POSITIONS (KHI GIÁ GIẢM)
    // =============================================================================
    
    if(g_TotalOrders_Buy > 0 && EnableBuyOrders) {
        // Chỉ DCA khi gần box low (<25%)
        if(positionInBox < positionInBox*2) {
            if(g_TotalOrders_Buy >= MaxOrders) return;
            // Check distance từ lệnh cuối
            if(g_LastBuyPrice > 0) {
                double distance = (g_LastBuyPrice - currentPrice) / _Point;
                double requiredDistance = GetAdjustedDCADistanceEnhanced(g_TotalOrders_Buy + 1, MARKET_NORMAL);
                
                if(distance < requiredDistance) return;
            }
            
            // Volume confirmation
            if(!HasStrongVolumeMomentum(POSITION_TYPE_BUY)) return;
            
            // Order flow check
            if(!ShouldAllowTrade(POSITION_TYPE_BUY)) return;
            
            double lotSize = GetNextLotSize(POSITION_TYPE_BUY);
            double tp = CalculateAveragePriceWithTP(POSITION_TYPE_BUY, currentPrice, lotSize);
            string comment = StringFormat("Box Buy DCA #%d", g_TotalOrders_Buy + 1);
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, currentPrice, 0, 0, comment)) {
                UpdateLastPriceWithVolumeProfile(POSITION_TYPE_BUY, currentPrice);
            }
        }
    }
    
    // =============================================================================
    // D. ĐÓNG LỆNH KHI GIÁ QUA GIỮA BOX (OPTIONAL)
    // =============================================================================
    
    // Nếu có lệnh SELL và giá xuống về mid → close để chốt lời
    if(g_TotalOrders_Sell > 0 && positionInBox < 55) {
        double avgSellPrice = g_AveragePrice_Sell;
        if(currentPrice < avgSellPrice) {
            double profit = (avgSellPrice - currentPrice) / _Point;
            if(profit<300) { // Min 50 points profit
            }
        }
    }
    
    // Nếu có lệnh BUY và giá lên về mid → close để chốt lời
    if(g_TotalOrders_Buy > 0 && positionInBox > 45) {
        double avgBuyPrice = g_AveragePrice_Buy;
        if(currentPrice > avgBuyPrice) {
            double profit = (currentPrice - avgBuyPrice) / _Point;
            if(profit < -300) {
            }
        }
    }
}

// Helper function - Calculate average TP
double CalculateAveragePriceWithTP(ENUM_POSITION_TYPE posType, double newPrice, double newLot) {
    double totalCost = 0;
    double totalLots = 0;
    
    // Tính avg price hiện tại
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if((ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double lots = PositionGetDouble(POSITION_VOLUME);
        
        totalCost += openPrice * lots;
        totalLots += lots;
    }
    
    // Thêm lệnh mới
    totalCost += newPrice * newLot;
    totalLots += newLot;
    
    double avgPrice = totalCost / totalLots;
    
    // TP = avg + 100 points (hoặc box mid)
    double boxMid = (g_BoxHigh + g_BoxLow) / 2;
    double tp = 0;
    
    if(posType == POSITION_TYPE_BUY) {
        tp = MathMax(avgPrice + (100 * _Point), boxMid);
    } else {
        tp = MathMin(avgPrice - (100 * _Point), boxMid);
    }
    
    return tp;
}

// Helper - Close by type
void ClosePositionsByType(ENUM_POSITION_TYPE posType) {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if((ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE) != posType) continue;
        
        trade.PositionClose(ticket);
    }
}
// Thêm biến global
// OLD SL LOGIC - DISABLED
/*
bool g_SL_Applied_Buy = false;
bool g_SL_Applied_Sell = false;
int g_CombinedSL_Threshold = 3; // Số lệnh tối thiểu để kích hoạt SL

void UpdateDynamicSL_OLD() {
    // Đếm số lệnh hiện tại
    
    // Kiểm tra điều kiện kích hoạt SL
    bool shouldApplySL_Buy = (g_TotalOrders_Buy >= g_CombinedSL_Threshold && !g_SL_Applied_Buy);
    bool shouldApplySL_Sell = (g_TotalOrders_Sell >= g_CombinedSL_Threshold && !g_SL_Applied_Sell);
    
    if(!shouldApplySL_Buy && !shouldApplySL_Sell) {
        return; // Chưa đạt threshold hoặc đã apply rồi
    }
    
    // Tính ATR
    double atr[];
    ArraySetAsSeries(atr, true);
    int atrHandle = iATR(_Symbol, PERIOD_H1, 14);
    
    if(CopyBuffer(atrHandle, 0, 0, 1, atr) < 1) {
        IndicatorRelease(atrHandle);
        return;
    }
    
    double atrPoints = atr[0] / _Point;
    IndicatorRelease(atrHandle);
    
    int updatedBuy = 0;
    int updatedSell = 0;
    
    // Duyệt tất cả lệnh và update
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double currentSL = PositionGetDouble(POSITION_SL);
        double currentTP = PositionGetDouble(POSITION_TP);
        double profit = PositionGetDouble(POSITION_PROFIT);
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        // Chỉ update lệnh chưa có SL
        if(currentSL > 0) continue;
        
        double newSL = 0;
        double currentPrice = (posType == POSITION_TYPE_BUY) ? 
                             SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                             SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        
        if(posType == POSITION_TYPE_BUY && shouldApplySL_Buy) {
            // SL = 3x ATR dưới entry
            newSL = openPrice - (atrPoints * 3.0 * _Point);
            
            // Nếu lời > 0, tighten SL lên breakeven hoặc trailing
            if(profit > 0) {
                double trailingSL = currentPrice - (atrPoints * 1.5 * _Point);
                newSL = MathMax(newSL, trailingSL);
                newSL = MathMax(newSL, openPrice); // Tối thiểu = breakeven
            }
            
            newSL = NormalizeDouble(newSL, _Digits);
            
            if(trade.PositionModify(ticket, newSL, currentTP)) {
                updatedBuy++;
            }
        }
        else if(posType == POSITION_TYPE_SELL && shouldApplySL_Sell) {
            // SL = 3x ATR trên entry
            newSL = openPrice + (atrPoints * 3.0 * _Point);
            
            // Nếu lời > 0, tighten SL
            if(profit > 0) {
                double trailingSL = currentPrice + (atrPoints * 1.5 * _Point);
                newSL = MathMin(newSL, trailingSL);
                newSL = MathMin(newSL, openPrice); // Tối thiểu = breakeven
            }
            
            newSL = NormalizeDouble(newSL, _Digits);
            
            if(trade.PositionModify(ticket, newSL, currentTP)) {
                updatedSell++;
            }
        }
    }
    
    // Đánh dấu đã apply SL
    if(shouldApplySL_Buy && updatedBuy > 0) {
        g_SL_Applied_Buy = true;
    }
    
    if(shouldApplySL_Sell && updatedSell > 0) {
        g_SL_Applied_Sell = true;
    }
}
*/
// END OLD SL LOGIC

//+------------------------------------------------------------------+
//| NEW AI-Based Stop Loss Logic                                     |
//+------------------------------------------------------------------+
// Global variables for AI-based SL
bool g_AI_SL_Active_Buy = false;
bool g_AI_SL_Active_Sell = false;
bool g_AI_BlockDCA_Buy = false;
bool g_AI_BlockDCA_Sell = false;

// Variables để theo dõi số lượng lệnh trước khi cập nhật SL
int g_LastBuyOrderCount = 0;
int g_LastSellOrderCount = 0;
datetime g_LastSLCheckTime = 0;

//+------------------------------------------------------------------+
//| Hàm kiểm tra và đóng toàn bộ lệnh nếu phát hiện có lệnh bị SL   |
//| Được gọi TRƯỚC khi cập nhật SL để tránh tình trạng không đồng nhất|
//+------------------------------------------------------------------+
void CheckAndCloseAllOnSLHit() {
    // Chỉ kiểm tra mỗi 1 giây để tránh kiểm tra quá thường xuyên
    datetime currentTime = TimeCurrent();
    if(currentTime - g_LastSLCheckTime < 1) return;
    g_LastSLCheckTime = currentTime;

    // Đếm số lệnh Buy và Sell hiện tại
    int currentBuyCount = 0;
    int currentSellCount = 0;

    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;

        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        if(posType == POSITION_TYPE_BUY) {
            currentBuyCount++;
        } else {
            currentSellCount++;
        }
    }

    // Kiểm tra xem có lệnh Buy nào bị đóng không (giảm số lượng)
    if(g_LastBuyOrderCount > 0 && currentBuyCount < g_LastBuyOrderCount && currentBuyCount > 0) {

        // Đóng tất cả lệnh Buy còn lại
        int closedCount = 0;
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_BUY) continue;

            if(trade.PositionClose(ticket)) {
                closedCount++;
            } else {
            }
        }

        g_LastBuyOrderCount = 0; // Reset counter
    }

    // Kiểm tra xem có lệnh Sell nào bị đóng không (giảm số lượng)
    if(g_LastSellOrderCount > 0 && currentSellCount < g_LastSellOrderCount && currentSellCount > 0) {

        // Đóng tất cả lệnh Sell còn lại
        int closedCount = 0;
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_SELL) continue;

            if(trade.PositionClose(ticket)) {
                closedCount++;
            } else {
            }
        }

        g_LastSellOrderCount = 0; // Reset counter
    }

    // Cập nhật counters cho lần kiểm tra sau
    g_LastBuyOrderCount = currentBuyCount;
    g_LastSellOrderCount = currentSellCount;
}

//+------------------------------------------------------------------+
//| Tính SL cho lệnh mới khi mở                                      |
//| Returns: SL price, hoặc 0 nếu không set SL                       |
//+------------------------------------------------------------------+
double CalculateAISL(ENUM_ORDER_TYPE orderType, double openPrice) {
    if(!EnableAIBasedSL) return 0;

    double marketRange = CalculateMarketRange();

    // Chỉ set SL nếu market có biến động đủ lớn
    if(marketRange < AI_MarketRangeThreshold) {
        return 0; // Không set SL nếu range thấp
    }

    // Tính SL dựa trên AI_SL_Points
    double slPrice;
    if(orderType == ORDER_TYPE_BUY) {
        slPrice = openPrice - (AI_SL_Points * _Point);
    } else {
        slPrice = openPrice + (AI_SL_Points * _Point);
    }

    return NormalizeDouble(slPrice, _Digits);
}

void AIBasedStopLoss() {
    if(!EnableAIBasedSL) return;

    // QUAN TRỌNG: Kiểm tra và đóng toàn bộ lệnh nếu phát hiện có lệnh bị SL
    // Phải gọi TRƯỚC khi cập nhật SL để tránh tình trạng không đồng nhất
    CheckAndCloseAllOnSLHit();

    // Lấy marketRange từ AI (hoặc traditional calculation)
    double marketRange = CalculateMarketRange();

    // Kiểm tra marketRange có vượt ngưỡng không
    if(marketRange < AI_MarketRangeThreshold) {
        // Market không đủ biến động, không cập nhật SL
        return;
    }

    // Kiểm tra có lệnh đang mở không
    bool hasBuyOrders = (g_TotalOrders_Buy > 0);
    bool hasSellOrders = (g_TotalOrders_Sell > 0);


    // Cập nhật SL cho TẤT CẢ lệnh Buy đang mở dựa trên marketRange
    if(hasBuyOrders) {
        ApplyAIStopLoss(POSITION_TYPE_BUY, marketRange);
    }

    // Cập nhật SL cho TẤT CẢ lệnh Sell đang mở dựa trên marketRange
    if(hasSellOrders) {
        ApplyAIStopLoss(POSITION_TYPE_SELL, marketRange);
    }

    // Reset flags nếu không còn lệnh
    if(g_TotalOrders_Buy == 0) {
        g_AI_SL_Active_Buy = false;
        g_AI_BlockDCA_Buy = false;
    }

    if(g_TotalOrders_Sell == 0) {
        g_AI_SL_Active_Sell = false;
        g_AI_BlockDCA_Sell = false;
    }
}

//+------------------------------------------------------------------+
//| Update AI Block DCA flags based on Market Range & Imbalance      |
//| Chặn DCA khi lệnh đang ngược hướng với imbalance                 |
//+------------------------------------------------------------------+
void UpdateAIBlockDCA() {
    if(!EnableAIBasedSL) {
        return;
    }

    double marketRange = CalculateMarketRange();
    double imbalance = 0;

    if(g_APIAvailable) {
        imbalance = GetAIImbalance();
    }

    // Nếu marketRange không đạt ngưỡng, bỏ block
    if(marketRange < AI_MarketRangeThreshold) {
        g_AI_BlockDCA_Buy = false;
        g_AI_BlockDCA_Sell = false;
        return;
    }

    // Chỉ xét dấu của imbalance
    bool marketBullish = (imbalance > 0);  // Dấu dương
    bool marketBearish = (imbalance < 0);  // Dấu âm

    // Block DCA theo hướng ngược lại với market
    if(marketBearish && AI_BlockDCA_OnWrongDirection) {
        g_AI_BlockDCA_Buy = true;
    } else {
        g_AI_BlockDCA_Buy = false;
    }

    if(marketBullish && AI_BlockDCA_OnWrongDirection) {
        g_AI_BlockDCA_Sell = true;
    } else {
        g_AI_BlockDCA_Sell = false;
    }

    // Reset nếu không còn lệnh
    if(g_TotalOrders_Buy == 0) {
        g_AI_BlockDCA_Buy = false;
    }
    if(g_TotalOrders_Sell == 0) {
        g_AI_BlockDCA_Sell = false;
    }
}

void ApplyAIStopLoss(ENUM_POSITION_TYPE posType, double marketRange) {
    // Tìm lệnh cuối cùng (mới nhất) để làm reference point
    datetime latestTime = 0;
    double latestPrice = 0;

    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;

        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        if(openTime > latestTime) {
            latestTime = openTime;
            latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        }
    }

    if(latestPrice == 0) return;

    // Tính SL dựa trên AI_SL_Points (input parameter cố định)
    double slDistance = AI_SL_Points * _Point;
    double slPrice;

    if(posType == POSITION_TYPE_BUY) {
        slPrice = latestPrice - slDistance;
    } else {
        slPrice = latestPrice + slDistance;
    }

    slPrice = NormalizeDouble(slPrice, _Digits);

    // Đếm số lệnh trước khi bắt đầu cập nhật SL
    int initialOrderCount = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;
        initialOrderCount++;
    }

    // Áp dụng SL cho tất cả lệnh cùng hướng
    int updated = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        if(PositionGetInteger(POSITION_TYPE) != posType) continue;

        double currentSL = PositionGetDouble(POSITION_SL);
        double currentTP = PositionGetDouble(POSITION_TP);

        // Chỉ update nếu SL khác hoặc chưa có SL
        if(MathAbs(currentSL - slPrice) > _Point || currentSL == 0) {
            if(trade.PositionModify(ticket, slPrice, currentTP)) {
                updated++;

                // KIỂM TRA QUAN TRỌNG: Sau khi modify, kiểm tra xem có lệnh nào bị đóng không
                int currentOrderCount = 0;
                for(int j = PositionsTotal() - 1; j >= 0; j--) {
                    ulong checkTicket = PositionGetTicket(j);
                    if(!PositionSelectByTicket(checkTicket)) continue;
                    if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                    if(PositionGetInteger(POSITION_TYPE) != posType) continue;
                    currentOrderCount++;
                }

                // Nếu số lệnh giảm, có nghĩa là có lệnh bị hit SL
                if(currentOrderCount < initialOrderCount) {
        
                    // Đóng tất cả lệnh còn lại cùng hướng
                    int closedCount = 0;
                    for(int k = PositionsTotal() - 1; k >= 0; k--) {
                        ulong closeTicket = PositionGetTicket(k);
                        if(!PositionSelectByTicket(closeTicket)) continue;
                        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                        if(PositionGetInteger(POSITION_TYPE) != posType) continue;

                        if(trade.PositionClose(closeTicket)) {
                            closedCount++;
                        }
                    }


                    // Reset counter và thoát khỏi hàm
                    if(posType == POSITION_TYPE_BUY) {
                        g_LastBuyOrderCount = 0;
                    } else {
                        g_LastSellOrderCount = 0;
                    }
                    return;
                }
            }
        }
    }

}

// Virtual TP/SL for last order
double g_VirtualTP_Buy = 0;
double g_VirtualSL_Buy = 0;
double g_VirtualTP_Sell = 0;
double g_VirtualSL_Sell = 0;
ulong g_LastBuyTicket = 0;
ulong g_LastSellTicket = 0;

void ManageLastOrderTPSL() {
    double currentPrice = GetCleanPrice();

    // Calculate average prices for both Buy and Sell orders
    double totalVolume_Buy = 0;
    double totalVolume_Sell = 0;
    double weightedSum_Buy = 0;
    double weightedSum_Sell = 0;
    double averagePrice_Buy = 0;
    double averagePrice_Sell = 0;

    datetime latestTime_Buy = 0;
    double latestPrice_Buy = 0;
    ulong latestTicket_Buy = 0;

    datetime latestTime_Sell = 0;
    double latestPrice_Sell = 0;
    ulong latestTicket_Sell = 0;

    // Single loop to calculate everything
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;

        double volume = PositionGetDouble(POSITION_VOLUME);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

        if(posType == POSITION_TYPE_BUY) {
            // Calculate weighted average for Buy
            totalVolume_Buy += volume;
            weightedSum_Buy += openPrice * volume;

            // Track latest Buy order
            if(openTime > latestTime_Buy) {
                latestTime_Buy = openTime;
                latestPrice_Buy = openPrice;
                latestTicket_Buy = ticket;
            }
        }
        else if(posType == POSITION_TYPE_SELL) {
            // Calculate weighted average for Sell
            totalVolume_Sell += volume;
            weightedSum_Sell += openPrice * volume;

            // Track latest Sell order
            if(openTime > latestTime_Sell) {
                latestTime_Sell = openTime;
                latestPrice_Sell = openPrice;
                latestTicket_Sell = ticket;
            }
        }
    }

    // Normalize volumes
    totalVolume_Buy = NormalizeDouble(totalVolume_Buy, 2);
    totalVolume_Sell = NormalizeDouble(totalVolume_Sell, 2);

    // Calculate average prices
    if(totalVolume_Buy > 0) {
        averagePrice_Buy = NormalizeDouble(weightedSum_Buy / totalVolume_Buy, _Digits);
    }
    if(totalVolume_Sell > 0) {
        averagePrice_Sell = NormalizeDouble(weightedSum_Sell / totalVolume_Sell, _Digits);
    }

    // Update global average prices
    g_AveragePrice_Buy = averagePrice_Buy;
    g_AveragePrice_Sell = averagePrice_Sell;

    // Buy orders management
    if(g_TotalOrders_Buy > 0 && latestTicket_Buy > 0) {
        if(latestTicket_Buy != g_LastBuyTicket) {
            g_LastBuyTicket = latestTicket_Buy;
            double slDistance = AI_SL_Points * _Point;

            // TP = Average price of all Buy orders + DefaultTP
            // Đảm bảo TP luôn cao hơn average price
            if(averagePrice_Buy > 0) {
                g_VirtualTP_Buy = NormalizeDouble(averagePrice_Buy + DefaultTP * _Point, _Digits);
            } else {
                g_VirtualTP_Buy = 0;
            }

            g_VirtualSL_Buy = EnableAIBasedSL ? NormalizeDouble(latestPrice_Buy - slDistance, _Digits) : 0;
        }
    } else {
        g_VirtualTP_Buy = 0;
        g_VirtualSL_Buy = 0;
        g_LastBuyTicket = 0;
    }

    // Sell orders management
    if(g_TotalOrders_Sell > 0 && latestTicket_Sell > 0) {
        if(latestTicket_Sell != g_LastSellTicket) {
            g_LastSellTicket = latestTicket_Sell;
            double slDistance = AI_SL_Points * _Point;

            // TP = Average price of all Sell orders - DefaultTP
            // Đảm bảo TP luôn thấp hơn average price
            if(averagePrice_Sell > 0) {
                g_VirtualTP_Sell = NormalizeDouble(averagePrice_Sell - DefaultTP * _Point, _Digits);
            } else {
                g_VirtualTP_Sell = 0;
            }

            g_VirtualSL_Sell = EnableAIBasedSL ? NormalizeDouble(latestPrice_Sell + slDistance, _Digits) : 0;
        }
    } else {
        g_VirtualTP_Sell = 0;
        g_VirtualSL_Sell = 0;
        g_LastSellTicket = 0;
    }
}

void CheckLastOrderClosed() {
    double currentPrice = GetCleanPrice();

    // Check Buy TP/SL
    if(g_TotalOrders_Buy > 0 && g_VirtualTP_Buy > 0) {
        bool hitTP = currentPrice >= g_VirtualTP_Buy;
        bool hitSL = (g_VirtualSL_Buy > 0) && (currentPrice <= g_VirtualSL_Buy);

        if(hitTP || hitSL) {
            for(int i = PositionsTotal() - 1; i >= 0; i--) {
                ulong ticket = PositionGetTicket(i);
                if(!PositionSelectByTicket(ticket)) continue;
                if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_BUY) continue;
                trade.PositionClose(ticket);
            }
            g_VirtualTP_Buy = 0;
            g_VirtualSL_Buy = 0;
            g_LastBuyTicket = 0;
        }
    }

    // Check Sell TP/SL
    if(g_TotalOrders_Sell > 0 && g_VirtualTP_Sell > 0) {
        bool hitTP = currentPrice <= g_VirtualTP_Sell;
        bool hitSL = (g_VirtualSL_Sell > 0) && (currentPrice >= g_VirtualSL_Sell);

        if(hitTP || hitSL) {
            for(int i = PositionsTotal() - 1; i >= 0; i--) {
                ulong ticket = PositionGetTicket(i);
                if(!PositionSelectByTicket(ticket)) continue;
                if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_SELL) continue;
                trade.PositionClose(ticket);
            }
            g_VirtualTP_Sell = 0;
            g_VirtualSL_Sell = 0;
            g_LastSellTicket = 0;
        }
    }
}

// Reset flags khi đóng hết lệnh
void OnTradeTransaction(const MqlTradeTransaction& trans,
                       const MqlTradeRequest& request,
                       const MqlTradeResult& result) {
    if(trans.type == TRADE_TRANSACTION_DEAL_ADD) {

        // Reset AI-based SL flags nếu không còn lệnh
        if(g_TotalOrders_Buy == 0) {
            g_AI_SL_Active_Buy = false;
            g_AI_BlockDCA_Buy = false;
        }
        if(g_TotalOrders_Sell == 0) {
            g_AI_SL_Active_Sell = false;
            g_AI_BlockDCA_Sell = false;
        }
    }
}
void OnTick() {
    // =============================================================================
    // 1. KIỂM TRA ĐIỀU KIỆN CƠ BẢN

    // C?p nh?t AI Threshold (t? ??ng ki?m tra interval b?n trong hàm)
    UpdateAIThreshold();

    // =============================================================================
    // Sau khi xác định g_InsideBox
        double currentPrice = GetCleanPrice();

HandleCycleCompletion();

// CHECK: Nếu đang chờ hoàn thành cycle cũ → BLOCK logic mới
if(g_WaitingForCycleCompletion && g_InsideBox<g_CurrentAIThreshold) {
    ActiveTradeType activeType = GetActiveTradeType();
    
    // Nếu có lệnh sideway nhưng đã outside box → Tiếp tục DCA sideway
    if(activeType == TRADE_SIDEWAY && !g_InsideBox) {
        // ModifyOrdersTPEnhanced(currentPrice); // DISABLED

        if(g_TotalOrders_Buy > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_BUY)) {
            ResetTrendModeTracking();
        }
        if(g_TotalOrders_Sell > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_SELL)) {
            ResetTrendModeTracking();
        }

    }

    // Nếu có lệnh breakout nhưng đã inside box → Tiếp tục DCA breakout
    if(activeType == TRADE_BREAKOUT && g_InsideBox>g_CurrentAIThreshold) {
        // ModifyOrdersTPEnhanced(currentPrice); // DISABLED
      if(g_TotalOrders_Buy > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_BUY)) {
            ResetTrendModeTracking();
        }
        if(g_TotalOrders_Sell > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_SELL)) {
            ResetTrendModeTracking();
        }

    }
}
// UpdateDynamicSL(); // OLD - DISABLED
// AIBasedStopLoss(); // DISABLED - Chỉ quản lý lệnh cuối cùng
UpdateAIBlockDCA(); // Cập nhật Block DCA flags dựa trên Range & Imbalance

// NEW: Quản lý TP/SL chỉ cho lệnh cuối cùng
ManageLastOrderTPSL();
CheckLastOrderClosed(); // Đóng tất cả nếu lệnh cuối đóng

// Tiếp tục logic bình thường nếu không đang chờ completion
    if(!IsSpreadOK()) return;
    if(!IsAIConnectionOK()) return;  // Check AI connection if required

    static int tickCount = 0;
    tickCount++;
    if(tickCount >= 10) {
        CalculateVolumeProfile();
        g_AllowTrading = ShouldAllowTradingByVolume();
        tickCount = 0;
    }
    if(!g_AllowTrading) return;
    
    if(IsWeekendTrading()) return;
    if(EnableNewsProtection && IsWithinNewsTime()) return;
    
    // =============================================================================
    // 2. CẬP NHẬT THÔNG TIN CƠ BẢN
    // =============================================================================
    
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
    static int lastDay = -1;
    if(time_struct.day != lastDay) {
        g_DailyTargetHit = false;
        g_DailyOpenPrice = 0;
        lastDay = time_struct.day;
    }
    
    UpdateAnchorPrice();
    CountOrdersAndCalculateAverages();
    CountActiveCycles();
    g_DailyProfit = CalculateDailyProfit();
    
    // =============================================================================
    // 3. PHÁT HIỆN BOX (H1) - ƯU TIÊN CAO NHẤT
    // =============================================================================
    
    DetectH1Box();
    g_InsideBox = CalculateMarketRange();
    // DEBUG: Print the current market range (the value actually used) and whether it came from AI
    {
        double mr = g_InsideBox; // value returned by CalculateMarketRange()
        string source = g_LastMarketRangeWasAI ? "AI" : "TRADITIONAL";
        string mode = mr < g_CurrentAIThreshold ? "SIDEWAY (INSIDE BOX)" : "TREND (OUTSIDE BOX)";
        // Print the used market range and its source (do NOT print the input threshold here)
        string msg = StringFormat("OnTick: UsedMarketRange=%.0f Source=%s Mode=%s Symbol=%s Time=%s", mr, source, mode, _Symbol, TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS));
    }
    
 
    // =============================================================================
    // 4. TRADING LOGIC DỰA TRÊN BOX
    // =============================================================================
// SCALPING PRIORITY 1: AI Imbalance (Cao nhất - mở lệnh khi có tín hiệu AI mạnh)
// Chỉ thử mở nếu không có lệnh trong hướng đó (tránh xung đột)
// SCALPING PRIORITY 1: AI Imbalance (Cao nhất - mở lệnh khi có tín hiệu AI mạnh)
// Chỉ thử mở nếu không có lệnh trong hướng đó (tránh xung đột)
if (g_TotalOrders_Buy == 0 && g_TotalOrders_Sell == 0)
{
    // Thử mở lệnh bằng chiến thuật AI Imbalance
    if (OpenOrderByAIImbalance())
    {
    }
    else 
    {
        // ❌ Chiến thuật AI không mở được lệnh -> thử chiến thuật 2
        RunFlexibleZoneStrategy();
        
        // Kiểm tra xem có lệnh mới được mở không
        if (g_TotalOrders_Buy == 0 && g_TotalOrders_Sell == 0)
        {
HandleSingleDirectionEntry();
        }
    }
}
           HandleParallelDCA(currentPrice);


// ModifyOrdersTPEnhanced(currentPrice); // DISABLED
  // A. INSIDE BOX → SIDEWAY TRADING
    double marketRange = CalculateMarketRange();
   if(marketRange < g_CurrentAIThreshold && g_TotalOrders_Buy == 0 && g_TotalOrders_Sell == 0) {
    // Narrow range checks (bổ sung cho sideway)
  HandleRegularDCA();
    OrderFlowStrength flowStrength = AnalyzeOrderFlowAdvanced();
    if(flowStrength == FLOW_STRONG_SELL && g_TotalOrders_Buy > 0) return;

    // Execute sideway trading
    // ModifyOrdersTPEnhanced(currentPrice); // DISABLED
    
    if(g_TotalOrders_Buy > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_BUY)) {
        ResetTrendModeTracking();
    }
    if(g_TotalOrders_Sell > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_SELL)) {
        ResetTrendModeTracking();
    }
    
    HandleCycleCompletion();
    
    if(g_TotalOrders_Buy == 0) canOpenNewTrade_Buy = true;
    if(g_TotalOrders_Sell == 0) canOpenNewTrade_Sell = true;
    return;
}
    
    // B. OUTSIDE BOX → SINGLE DIRECTION (TREND)
    
    g_DailyAllowedDirection = AnalyzeDailyMomentum();
    
    
    if(g_DailyAllowedDirection != DAILY_BOTH) {
        // Block nếu có lệnh ngược chiều
       
         // A. INSIDE BOX → SIDEWAY TRADING
       // A. INSIDE BOX → SIDEWAY TRADING
    double marketRange = CalculateMarketRange();
   
        
 
      




        // ModifyOrdersTPEnhanced(currentPrice); // DISABLED

        if(g_TotalOrders_Buy > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_BUY)) {
            ResetTrendModeTracking();
        }
        if(g_TotalOrders_Sell > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_SELL)) {
            ResetTrendModeTracking();
        }

        HandleCycleCompletion();
        
        if(g_TotalOrders_Buy == 0) canOpenNewTrade_Buy = true;
        if(g_TotalOrders_Sell == 0) canOpenNewTrade_Sell = true;
        return;
    }
    
    // =============================================================================
    // 5. FILTERS & SAFETY (NẾU KHÔNG CÓ BOX DIRECTION RÕ RÀNG)
    // =============================================================================
    
    
    g_AllowedDirection = GetMFIDirection();
    if(g_AllowedDirection == DIR_BUY_ONLY && g_TotalOrders_Sell > 0) return;
    if(g_AllowedDirection == DIR_SELL_ONLY && g_TotalOrders_Buy > 0) return;
    
    OrderFlowStrength flowStrength = AnalyzeOrderFlowAdvanced();
    if(flowStrength == FLOW_STRONG_SELL && g_TotalOrders_Buy > 0) return;
    if(flowStrength == FLOW_STRONG_BUY && g_TotalOrders_Sell > 0) return;
    
    DetectNarrowRange();
    if(g_InNarrowRange) {
        if(!ShouldTradeInNarrowRange(currentPrice)) return;
        if(g_TotalOrders_Buy > 0 && !HasStrongMoneyFlow(POSITION_TYPE_BUY)) return;
        if(g_TotalOrders_Sell > 0 && !HasStrongMoneyFlow(POSITION_TYPE_SELL)) return;
    }
    
    ResetAfterFullClose();
    if(IsInCooldownPeriod()) return;
    
    // =============================================================================
    // 6. DAILY PROFIT & LIMITS
    // =============================================================================
    bool g_DailyProfitActionExecuted = true;
    double g_DailyProfitResetTime =0;
    if(EnableDailyProfitLimit && g_DailyProfit >= DailyProfitTarget) {
        if(!g_DailyProfitActionExecuted) {
            g_DailyProfitActionExecuted = true;
            g_DailyProfitResetTime = TimeCurrent() + 60;
        }
        
        if(TimeCurrent() < g_DailyProfitResetTime) return;
        
        if(TimeCurrent() >= g_DailyProfitResetTime) {
            g_DailyProfit = 0;
            g_DailyProfitActionExecuted = false;
            g_DailyProfitResetTime = 0;
        }
    }
    
    if(!EnforcePeriodOrderLimits()) return;
    if(!CanOpenMoreOrdersInPeriod()) return;
    if(!HasEnoughTimeForNewOrder()) return;
    
    // =============================================================================
    // 7. RECOVERY MODE
    // =============================================================================
    
    if(g_InRecoveryMode) {
        ManageRecoveryMode();
        if(CheckAndCloseOnRecoveryTarget()) {
            g_HasResumedTrading = false;
            return;
        }
    }
    
    // =============================================================================
    // 8. NORMAL TRADING LOGIC (FALLBACK)
    // =============================================================================
    
    bool skipRegularDCA = false;
    

    
  
    
  
    
    
    // =============================================================================
    // 9. TP MANAGEMENT - DISABLED (quản lý ở ManageLastOrderTPSL)
    // =============================================================================

    // ModifyOrdersTPEnhanced(currentPrice); // DISABLED

    if(g_TotalOrders_Buy > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_BUY)) {
        ResetTrendModeTracking();
    }
    if(g_TotalOrders_Sell > 0 && CheckAnyTPReached(currentPrice, POSITION_TYPE_SELL)) {
        ResetTrendModeTracking();
    }
    
    HandleCycleCompletion();
  
    
    if(g_TotalOrders_Buy == 0) canOpenNewTrade_Buy = true;
    if(g_TotalOrders_Sell == 0) canOpenNewTrade_Sell = true;
    
    HandleMonthEndClosing();
    HandleWeekendClosing();
}

bool DetectNarrowRange() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_H1, 0, 24, rates) < 24) return false;
    
    // Tính range của 24 bars
    double highest = rates[0].high;
    double lowest = rates[0].low;
    
    for(int i = 1; i < 24; i++) {
        if(rates[i].high > highest) highest = rates[i].high;
        if(rates[i].low < lowest) lowest = rates[i].low;
    }
    
    double range = (highest - lowest) / _Point;
    
    // Nếu range < 1000 points
    if(range < 1000) {
        if(!g_InNarrowRange) {
            g_InNarrowRange = true;
            g_RangeHigh = highest;
            g_RangeLow = lowest;
            g_RangeStartTime = TimeCurrent();
            g_RangeBarCount = 0;
        } else {
            g_RangeBarCount++;
        }
        return true;
    }
    
    g_InNarrowRange = false;
    return false;
}

bool ShouldTradeInNarrowRange(double currentPrice) {
    if(!g_InNarrowRange) return true;
    
    // Chỉ trade khi giá gần biên range (20% từ high/low)
    double rangeSize = g_RangeHigh - g_RangeLow;
    double upperZone = g_RangeHigh - (rangeSize * 0.2);
    double lowerZone = g_RangeLow + (rangeSize * 0.2);
    
    // Check volume spike - yêu cầu volume > 1.3x average
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M15, 0, 20, rates) < 20) return false;
    
    long avgVol = 0;
    for(int i = 1; i < 20; i++) avgVol += rates[i].tick_volume;
    avgVol = avgVol / 19;
    
    if(rates[0].tick_volume < avgVol * 1.3) return false;
    
    // Chỉ trade ở biên range + có volume
    return (currentPrice <= lowerZone || currentPrice >= upperZone);
}
// Range tracking globals
bool g_InNarrowRange = false;
double g_RangeHigh = 0;
double g_RangeLow = 0;
datetime g_RangeStartTime = 0;
int g_RangeBarCount = 0;

// Hàm tính tâm giá từ nến
double CalculateCenterPriceFromCandle(const MqlRates &candle) {
    // Sử dụng (High + Low) / 2 làm tâm giá
    double centerPrice = (candle.high + candle.low) / 2.0;
    return NormalizeDouble(centerPrice, _Digits);
}

// Sửa lại hàm CalculateCenterPrice để sử dụng timeframe input
double CalculateCenterPrice() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    // Cập nhật dynamic timeframe
g_DynamicTimeframe = GetOptimalTimeframe();
    // Lấy nến từ timeframe đã chọn
    if(CopyRates(_Symbol, g_DynamicTimeframe , 1, 1, rates) != 1) {
        return 0;
    }
    
    return CalculateCenterPriceFromCandle(rates[0]);
}



// Sửa hàm CheckFirstOrderDistance để sử dụng tâm giá từ timeframe
bool CheckFirstOrderDistance(double currentPrice, double centerPrice) {
    // Lấy nến từ timeframe để tính tâm giá chính xác
    MqlRates rates[];
    // Cập nhật dynamic timeframe
g_DynamicTimeframe = GetOptimalTimeframe();
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, g_DynamicTimeframe , 1, 1, rates) == 1) {
        centerPrice = CalculateCenterPriceFromCandle(rates[0]);
    }
    
    double distanceFromCenter = MathAbs(currentPrice - centerPrice) / _Point;
    double requiredDistance = GetPeriodFirstEntryDistance();
    
    return (distanceFromCenter >= requiredDistance);
}


// Thêm enum và globals
enum DailyDirection {
    DAILY_BOTH,       // Cho phép cả 2
    DAILY_BUY_ONLY,   // Chỉ Buy
    DAILY_SELL_ONLY   // Chỉ Sell
};

DailyDirection g_DailyAllowedDirection = DAILY_BOTH;
datetime g_LastDailyCheck = 0;




// Hàm 2: Phát hi?n các m?c swing (??nh/?áy)
void IdentifySwingLevels(MqlRates &ratesH1[], MqlRates &ratesH4[]) {
    // Phát hi?n Swing Highs trên H4
        datetime currentTime = TimeCurrent();

    for(int i = SwingStrength; i < ArraySize(ratesH4) - SwingStrength; i++) {
        bool isSwingHigh = true;
        bool isSwingLow = true;
        
        // Ki?m tra Swing High
        for(int j = 1; j <= SwingStrength; j++) {
            if(ratesH4[i].high <= ratesH4[i-j].high || ratesH4[i].high <= ratesH4[i+j].high) {
                isSwingHigh = false;
                break;
            }
        }
        
        // Ki?m tra Swing Low
        for(int j = 1; j <= SwingStrength; j++) {
            if(ratesH4[i].low >= ratesH4[i-j].low || ratesH4[i].low >= ratesH4[i+j].low) {
                isSwingLow = false;
                break;
            }
        }
        
        if(isSwingHigh && g_SellZonesCount < ArraySize(g_SellZones)) {
            // Thêm vùng kháng c? m?i (cho bán)
            g_SellZones[g_SellZonesCount].price = ratesH4[i].high;
            g_SellZones[g_SellZonesCount].strength = 70; // ?? m?nh ban ??u
            g_SellZones[g_SellZonesCount].expiryTime = currentTime + PriceZoneValidity * 3600;
            g_SellZones[g_SellZonesCount].isSupportZone = false;
            g_SellZones[g_SellZonesCount].historicalTouches = CountHistoricalTouches(ratesH4[i].high, false);
            g_SellZones[g_SellZonesCount].pendingOrderTicket = 0;
            g_SellZonesCount++;
        }
        
        if(isSwingLow && g_BuyZonesCount < ArraySize(g_BuyZones)) {
            // Thêm vùng h? tr? m?i (cho mua)
            g_BuyZones[g_BuyZonesCount].price = ratesH4[i].low;
            g_BuyZones[g_BuyZonesCount].strength = 70; // ?? m?nh ban ??u
            g_BuyZones[g_BuyZonesCount].expiryTime = currentTime + PriceZoneValidity * 3600;
            g_BuyZones[g_BuyZonesCount].isSupportZone = true;
            g_BuyZones[g_BuyZonesCount].historicalTouches = CountHistoricalTouches(ratesH4[i].low, true);
            g_BuyZones[g_BuyZonesCount].pendingOrderTicket = 0;
            g_BuyZonesCount++;
        }
    }
}

// Hàm 3: Tính toán m?c Fibonacci và thêm vào vùng giá
void CalculateFibonacciZones(MqlRates &ratesH4[], MqlRates &ratesD1[]) {
    // Tìm swing high/low trong d? li?u D1 cho Fibonacci
    
    
      double swingHigh = 0;
    double swingLow = DBL_MAX;
    
    // Tìm giá cao nh?t và th?p nh?t th? công
    for(int i = 0; i < ArraySize(ratesD1); i++) {
        if(ratesD1[i].high > swingHigh) swingHigh = ratesD1[i].high;
        if(ratesD1[i].low < swingLow) swingLow = ratesD1[i].low;
    }
    double range = swingHigh - swingLow;
    
    // Tính các m?c Fibonacci t? swing high ??n swing low
    double fibLevel1Price = swingLow + range * FibLevel1;
    double fibLevel2Price = swingLow + range * FibLevel2;
    double fibLevel3Price = swingLow + range * FibLevel3;
    double fibLevel4Price = swingLow + range * FibLevel4;
    
    // Thêm các m?c Fibonacci vào vùng h? tr? (Buy Zones)
    if(g_BuyZonesCount < ArraySize(g_BuyZones)) {
        g_BuyZones[g_BuyZonesCount].price = fibLevel1Price;
        g_BuyZones[g_BuyZonesCount].strength = 75;
        g_BuyZones[g_BuyZonesCount].expiryTime = TimeCurrent() + PriceZoneValidity * 3600;
        g_BuyZones[g_BuyZonesCount].isSupportZone = true;
        g_BuyZones[g_BuyZonesCount].historicalTouches = CountHistoricalTouches(fibLevel1Price, true);
        g_BuyZonesCount++;
    }
    
    if(g_BuyZonesCount < ArraySize(g_BuyZones)) {
        g_BuyZones[g_BuyZonesCount].price = fibLevel2Price;
        g_BuyZones[g_BuyZonesCount].strength = 85;
        g_BuyZones[g_BuyZonesCount].expiryTime = TimeCurrent() + PriceZoneValidity * 3600;
        g_BuyZones[g_BuyZonesCount].isSupportZone = true;
        g_BuyZones[g_BuyZonesCount].historicalTouches = CountHistoricalTouches(fibLevel2Price, true);
        g_BuyZonesCount++;
    }
    
    // Thêm các m?c Fibonacci vào vùng kháng c? (Sell Zones)
    if(g_SellZonesCount < ArraySize(g_SellZones)) {
        g_SellZones[g_SellZonesCount].price = fibLevel3Price;
        g_SellZones[g_SellZonesCount].strength = 80;
        g_SellZones[g_SellZonesCount].expiryTime = TimeCurrent() + PriceZoneValidity * 3600;
        g_SellZones[g_SellZonesCount].isSupportZone = false;
        g_SellZones[g_SellZonesCount].historicalTouches = CountHistoricalTouches(fibLevel3Price, false);
        g_SellZonesCount++;
    }
    
    if(g_SellZonesCount < ArraySize(g_SellZones)) {
        g_SellZones[g_SellZonesCount].price = fibLevel4Price;
        g_SellZones[g_SellZonesCount].strength = 75;
        g_SellZones[g_SellZonesCount].expiryTime = TimeCurrent() + PriceZoneValidity * 3600;
        g_SellZones[g_SellZonesCount].isSupportZone = false;
        g_SellZones[g_SellZonesCount].historicalTouches = CountHistoricalTouches(fibLevel4Price, false);
        g_SellZonesCount++;
    }
}

// Hàm 4: ?ánh giá ?? m?nh c?a t?ng vùng giá
void EvaluateZoneStrength() {
    // L?y d? li?u RSI
    double rsiValues[];
    int rsiHandle = iRSI(_Symbol, PERIOD_H1, RSIPeriod, PRICE_CLOSE);
    if(rsiHandle == INVALID_HANDLE) {
        return;
    }
    
    ArraySetAsSeries(rsiValues, true);
    if(CopyBuffer(rsiHandle, 0, 0, 3, rsiValues) < 3) {
        IndicatorRelease(rsiHandle);
        return;
    }
    
    double currentRSI = rsiValues[0];
    IndicatorRelease(rsiHandle);
    
    // L?y ch? báo trend hi?n t?i
    int trendDirection = AnalyzeMarketDirection();
    
    // ?ánh giá vùng Buy (h? tr?)
    for(int i = 0; i < g_BuyZonesCount; i++) {
        // 1. ?i?u ch?nh ?? m?nh d?a trên s? l?n ch?m l?ch s?
        g_BuyZones[i].strength += g_BuyZones[i].historicalTouches * 5;
        
        // 2. ?i?u ch?nh d?a trên RSI (quá bán -> mua m?nh h?n)
        if(currentRSI <= RSIOversold) {
            g_BuyZones[i].strength += (RSIOversold - currentRSI) * 0.5;
        }
        
        // 3. ?i?u ch?nh d?a trên h??ng th? tr??ng
        if(trendDirection < 0) { // Xu h??ng gi?m -> mua ? h? tr? t?t h?n
            g_BuyZones[i].strength += MathAbs(trendDirection) * 0.2;
        }
        
        // 4. Tính toán xác su?t vào l?nh (0-100)
        g_BuyZones[i].entryProbability = MathMin(100, g_BuyZones[i].strength);
        
        // Gi?i h?n ?? m?nh t?i ?a
        g_BuyZones[i].strength = MathMin(100, g_BuyZones[i].strength);
    }
    
    // ?ánh giá vùng Sell (kháng c?)
    for(int i = 0; i < g_SellZonesCount; i++) {
        // 1. ?i?u ch?nh ?? m?nh d?a trên s? l?n ch?m l?ch s?
        g_SellZones[i].strength += g_SellZones[i].historicalTouches * 5;
        
        // 2. ?i?u ch?nh d?a trên RSI (quá mua -> bán m?nh h?n)
        if(currentRSI >= RSIOverbought) {
            g_SellZones[i].strength += (currentRSI - RSIOverbought) * 0.5;
        }
        
        // 3. ?i?u ch?nh d?a trên h??ng th? tr??ng
        if(trendDirection > 0) { // Xu h??ng t?ng -> bán ? kháng c? t?t h?n
            g_SellZones[i].strength += trendDirection * 0.2;
        }
        
        // 4. Tính toán xác su?t vào l?nh (0-100)
        g_SellZones[i].entryProbability = MathMin(100, g_SellZones[i].strength);
        
        // Gi?i h?n ?? m?nh t?i ?a
        g_SellZones[i].strength = MathMin(100, g_SellZones[i].strength);
    }
}

// Hàm 5: L?c vùng giá d?a trên kho?ng cách
void FilterZonesByDistance() {
    if(g_BuyZonesCount <= 1 || g_SellZonesCount <= 1) return;
    
    // Danh sách t?m ?? l?u các vùng giá sau khi l?c
    PriceZone tempBuyZones[20];
    PriceZone tempSellZones[20];
    int tempBuyCount = 0;
    int tempSellCount = 0;
    
    // L?c Buy Zones
    for(int i = 0; i < g_BuyZonesCount; i++) {
        bool tooClose = false;
        for(int j = 0; j < tempBuyCount; j++) {
            if(MathAbs(g_BuyZones[i].price - tempBuyZones[j].price) / _Point < KeyZoneMinDistance) {
                tooClose = true;
                // Gi? l?i vùng có ?? m?nh cao h?n
                if(g_BuyZones[i].strength > tempBuyZones[j].strength) {
                    tempBuyZones[j] = g_BuyZones[i];
                }
                break;
            }
        }
        
        if(!tooClose && tempBuyCount < ArraySize(tempBuyZones)) {
            tempBuyZones[tempBuyCount] = g_BuyZones[i];
            tempBuyCount++;
        }
    }
    
    // L?c Sell Zones
    for(int i = 0; i < g_SellZonesCount; i++) {
        bool tooClose = false;
        for(int j = 0; j < tempSellCount; j++) {
            if(MathAbs(g_SellZones[i].price - tempSellZones[j].price) / _Point < KeyZoneMinDistance) {
                tooClose = true;
                // Gi? l?i vùng có ?? m?nh cao h?n
                if(g_SellZones[i].strength > tempSellZones[j].strength) {
                    tempSellZones[j] = g_SellZones[i];
                }
                break;
            }
        }
        
        if(!tooClose && tempSellCount < ArraySize(tempSellZones)) {
            tempSellZones[tempSellCount] = g_SellZones[i];
            tempSellCount++;
        }
    }
    
    // C?p nh?t m?ng vùng giá chính
    for(int i = 0; i < tempBuyCount; i++) {
        g_BuyZones[i] = tempBuyZones[i];
    }
    g_BuyZonesCount = tempBuyCount;
    
    for(int i = 0; i < tempSellCount; i++) {
        g_SellZones[i] = tempSellZones[i];
    }
    g_SellZonesCount = tempSellCount;
}

// Hàm 6: S?p x?p vùng giá theo ?? m?nh (gi?m d?n)
void SortZonesByStrength() {
    // S?p x?p Buy Zones
    for(int i = 0; i < g_BuyZonesCount - 1; i++) {
        for(int j = i + 1; j < g_BuyZonesCount; j++) {
            if(g_BuyZones[i].strength < g_BuyZones[j].strength) {
                PriceZone temp = g_BuyZones[i];
                g_BuyZones[i] = g_BuyZones[j];
                g_BuyZones[j] = temp;
            }
        }
    }
    
    // S?p x?p Sell Zones
    for(int i = 0; i < g_SellZonesCount - 1; i++) {
        for(int j = i + 1; j < g_SellZonesCount; j++) {
            if(g_SellZones[i].strength < g_SellZones[j].strength) {
                PriceZone temp = g_SellZones[i];
                g_SellZones[i] = g_SellZones[j];
                g_SellZones[j] = temp;
            }
        }
    }
}

// Hàm 7: ??m s? l?n giá ch?m vùng trong l?ch s?
int CountHistoricalTouches(double zonePrice, bool isSupportZone) {
    int touchCount = 0;
    
    // L?y d? li?u l?ch s?
    MqlRates ratesH1[];
    ArraySetAsSeries(ratesH1, true);
    if(CopyRates(_Symbol, PERIOD_H1, 0, PriceHistoryPeriods, ratesH1) < PriceHistoryPeriods) {
        return 0;
    }
    
    // Biên dung sai (20 points)
    double tolerance = 20 * _Point;
    
    for(int i = 0; i < ArraySize(ratesH1) - 1; i++) {
        if(isSupportZone) {
            // ??m ch?m vùng h? tr? (giá xu?ng ?? g?n r?i b?t lên)
            if(MathAbs(ratesH1[i].low - zonePrice) <= tolerance && 
               ratesH1[i].close > ratesH1[i].open && 
               ratesH1[i+1].close > ratesH1[i+1].open) {
                touchCount++;
                i++; // B? qua n?n ti?p theo ?? tránh ??m trùng
            }
        } else {
            // ??m ch?m vùng kháng c? (giá lên ?? g?n r?i quay ??u)
            if(MathAbs(ratesH1[i].high - zonePrice) <= tolerance && 
               ratesH1[i].close < ratesH1[i].open && 
               ratesH1[i+1].close < ratesH1[i+1].open) {
                touchCount++;
                i++; // B? qua n?n ti?p theo ?? tránh ??m trùng
            }
        }
    }
    
    return touchCount;
}




// Hàm 10: In thông tin vùng giá ?ã xác ??nh
void LogIdentifiedZones() {
    for(int i = 0; i < g_BuyZonesCount; i++) {
    
    }
    
    for(int i = 0; i < g_SellZonesCount; i++) {
  
    }
}

// Hàm 11: ?? h?a hi?n th? vùng giá
void DrawPriceZones() {
    // Xóa các vùng giá c?
    ObjectsDeleteAll(0, "BuyZone");
    ObjectsDeleteAll(0, "SellZone");
    
    // V? vùng giá mua
    for(int i = 0; i < g_BuyZonesCount; i++) {
        string zoneName = "BuyZone" + IntegerToString(i);
        ObjectCreate(0, zoneName, OBJ_HLINE, 0, 0, g_BuyZones[i].price);
        ObjectSetInteger(0, zoneName, OBJPROP_COLOR, clrGreen);
        ObjectSetInteger(0, zoneName, OBJPROP_STYLE, STYLE_SOLID);
        ObjectSetInteger(0, zoneName, OBJPROP_WIDTH, 2);
        ObjectSetString(0, zoneName, OBJPROP_TOOLTIP, "Buy Zone: " + DoubleToString(g_BuyZones[i].price, _Digits) + 
                                                     ", Strength: " + DoubleToString(g_BuyZones[i].strength, 1));
    }
    
    // V? vùng giá bán
    for(int i = 0; i < g_SellZonesCount; i++) {
        string zoneName = "SellZone" + IntegerToString(i);
        ObjectCreate(0, zoneName, OBJ_HLINE, 0, 0, g_SellZones[i].price);
        ObjectSetInteger(0, zoneName, OBJPROP_COLOR, clrRed);
        ObjectSetInteger(0, zoneName, OBJPROP_STYLE, STYLE_SOLID);
        ObjectSetInteger(0, zoneName, OBJPROP_WIDTH, 2);
        ObjectSetString(0, zoneName, OBJPROP_TOOLTIP, "Sell Zone: " + DoubleToString(g_SellZones[i].price, _Digits) + 
                                                     ", Strength: " + DoubleToString(g_SellZones[i].strength, 1));
    }
}

// Thêm hàm m?i vào OnInit
void InitializePriceZoneStrategy() {
    if(!EnablePriceZoneStrategy) return;
    
    g_ZoneInitialized = false;
    CalculateOptimalPriceZones();
}

// Thêm các bi?n m?i ?? theo dõi các l?nh ?ã kích ho?t
struct ActivatedOrder {
    int cycleId;                  // ID chu k? c?a l?nh
    double entryPrice;            // Giá vào l?nh ban ??u
    ENUM_POSITION_TYPE orderType; // Lo?i l?nh (BUY/SELL)
    datetime activationTime;      // Th?i gian l?nh ???c kích ho?t
    int orderCount;               // S? l?nh DCA ?ã m?
    ulong lastTicket;             // Ticket c?a l?nh g?n nh?t
    double lastOpenPrice;         // Giá m? c?a l?nh g?n nh?t
};

// M?ng ch?a các l?nh ?ã kích ho?t
ActivatedOrder g_ActivatedBuyOrders[10];  // T?i ?a 10 chu k? mua
ActivatedOrder g_ActivatedSellOrders[10]; // T?i ?a 10 chu k? bán
int g_ActivatedBuyCount = 0;
int g_ActivatedSellCount = 0;

// Thêm bi?n ?? theo dõi chu k? Zone
int g_NextZoneCycleId = 1;

// Thêm tham s? m?i
input bool UseZoneNameInComment = true;      // Thêm tên vùng vào comment l?nh
input bool EnableZoneDCA = true;             // B?t DCA cho l?nh vùng giá  
input int MaxZoneDCAOrders = 5;              // S? l?nh DCA t?i ?a cho m?i chu k? vùng
void CheckActivatedZoneOrders() {
    datetime currentTime = TimeCurrent();
    
    // Step 1: Check for new positions that match zone pattern but aren't tracked yet
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Zone") < 0) continue; // Only process Zone orders
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        int cycleId = ExtractZoneCycleId(comment);
        if(cycleId <= 0) continue;
        
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        
        // Check if this cycle is already tracked
        bool isTracked = false;
        
        if(posType == POSITION_TYPE_BUY) {
            for(int j = 0; j < g_ActivatedBuyCount; j++) {
                if(g_ActivatedBuyOrders[j].cycleId == cycleId) {
                    isTracked = true;
                    break;
                }
            }
            
            // If not tracked, add it
            if(!isTracked && g_ActivatedBuyCount < ArraySize(g_ActivatedBuyOrders)) {
                g_ActivatedBuyOrders[g_ActivatedBuyCount].cycleId = cycleId;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].entryPrice = openPrice;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].orderType = POSITION_TYPE_BUY;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].activationTime = currentTime;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].orderCount = 1; // Start with 1
                g_ActivatedBuyOrders[g_ActivatedBuyCount].lastTicket = ticket;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].lastOpenPrice = openPrice;
                g_ActivatedBuyCount++;
                
           
            }
        } else { // POSITION_TYPE_SELL
            for(int j = 0; j < g_ActivatedSellCount; j++) {
                if(g_ActivatedSellOrders[j].cycleId == cycleId) {
                    isTracked = true;
                    break;
                }
            }
            
            if(!isTracked && g_ActivatedSellCount < ArraySize(g_ActivatedSellOrders)) {
                g_ActivatedSellOrders[g_ActivatedSellCount].cycleId = cycleId;
                g_ActivatedSellOrders[g_ActivatedSellCount].entryPrice = openPrice;
                g_ActivatedSellOrders[g_ActivatedSellCount].orderType = POSITION_TYPE_SELL;
                g_ActivatedSellOrders[g_ActivatedSellCount].activationTime = currentTime;
                g_ActivatedSellOrders[g_ActivatedSellCount].orderCount = 1; // Start with 1
                g_ActivatedSellOrders[g_ActivatedSellCount].lastTicket = ticket;
                g_ActivatedSellOrders[g_ActivatedSellCount].lastOpenPrice = openPrice;
                g_ActivatedSellCount++;
                
       
            }
        }
    }
    
    // Step 2: Check pending orders in Buy Zones that have been activated
    for(int i = 0; i < g_BuyZonesCount; i++) {
        if(g_BuyZones[i].pendingOrderTicket > 0) {
            // Check if the pending order still exists
            if(!OrderSelect(g_BuyZones[i].pendingOrderTicket)) {
                // Order no longer exists - check history to see if it was filled
                HistorySelect(currentTime - 86400, currentTime); // Last 24 hours
                
                for(int j = HistoryOrdersTotal() - 1; j >= 0; j--) {
                    ulong historyTicket = HistoryOrderGetTicket(j);
                    if(historyTicket == g_BuyZones[i].pendingOrderTicket) {
                        ENUM_ORDER_STATE orderState = (ENUM_ORDER_STATE)HistoryOrderGetInteger(historyTicket, ORDER_STATE);
                        
                        // If order was filled
                        if(orderState == ORDER_STATE_FILLED) {
                            double dealPrice = HistoryOrderGetDouble(historyTicket, ORDER_PRICE_OPEN);
                            string comment = HistoryOrderGetString(historyTicket, ORDER_COMMENT);
                            int cycleId = ExtractZoneCycleId(comment);
                            
                            // Check if we're already tracking this cycle
                            bool alreadyTracked = false;
                            for(int k = 0; k < g_ActivatedBuyCount; k++) {
                                if(g_ActivatedBuyOrders[k].cycleId == cycleId) {
                                    alreadyTracked = true;
                                    break;
                                }
                            }
                            
                            // If not tracked, find the position and add it
                            if(!alreadyTracked && g_ActivatedBuyCount < ArraySize(g_ActivatedBuyOrders)) {
                                // Find the corresponding position
                                for(int k = PositionsTotal() - 1; k >= 0; k--) {
                                    ulong posTicket = PositionGetTicket(k);
                                    if(!PositionSelectByTicket(posTicket)) continue;
                                    if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                                    if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_BUY) continue;
                                    
                                    string posComment = PositionGetString(POSITION_COMMENT);
                                    if(StringFind(posComment, "Zone " + IntegerToString(cycleId)) >= 0) {
                                        // Add to tracking list
                                        g_ActivatedBuyOrders[g_ActivatedBuyCount].cycleId = cycleId;
                                        g_ActivatedBuyOrders[g_ActivatedBuyCount].entryPrice = dealPrice;
                                        g_ActivatedBuyOrders[g_ActivatedBuyCount].orderType = POSITION_TYPE_BUY;
                                        g_ActivatedBuyOrders[g_ActivatedBuyCount].activationTime = currentTime;
                                        g_ActivatedBuyOrders[g_ActivatedBuyCount].orderCount = 1;
                                        g_ActivatedBuyOrders[g_ActivatedBuyCount].lastTicket = posTicket;
                                        g_ActivatedBuyOrders[g_ActivatedBuyCount].lastOpenPrice = dealPrice;
                                        g_ActivatedBuyCount++;
                               
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
                
                // Reset pending order ticket
                g_BuyZones[i].pendingOrderTicket = 0;
            }
        }
    }
    
    // Step 3: Check pending orders in Sell Zones that have been activated
    for(int i = 0; i < g_SellZonesCount; i++) {
        if(g_SellZones[i].pendingOrderTicket > 0) {
            // Check if the pending order still exists
            if(!OrderSelect(g_SellZones[i].pendingOrderTicket)) {
                // Order no longer exists - check history to see if it was filled
                HistorySelect(currentTime - 86400, currentTime); // Last 24 hours
                
                for(int j = HistoryOrdersTotal() - 1; j >= 0; j--) {
                    ulong historyTicket = HistoryOrderGetTicket(j);
                    if(historyTicket == g_SellZones[i].pendingOrderTicket) {
                        ENUM_ORDER_STATE orderState = (ENUM_ORDER_STATE)HistoryOrderGetInteger(historyTicket, ORDER_STATE);
                        
                        // If order was filled
                        if(orderState == ORDER_STATE_FILLED) {
                            double dealPrice = HistoryOrderGetDouble(historyTicket, ORDER_PRICE_OPEN);
                            string comment = HistoryOrderGetString(historyTicket, ORDER_COMMENT);
                            int cycleId = ExtractZoneCycleId(comment);
                            
                            // Check if we're already tracking this cycle
                            bool alreadyTracked = false;
                            for(int k = 0; k < g_ActivatedSellCount; k++) {
                                if(g_ActivatedSellOrders[k].cycleId == cycleId) {
                                    alreadyTracked = true;
                                    break;
                                }
                            }
                            
                            // If not tracked, find the position and add it
                            if(!alreadyTracked && g_ActivatedSellCount < ArraySize(g_ActivatedSellOrders)) {
                                // Find the corresponding position
                                for(int k = PositionsTotal() - 1; k >= 0; k--) {
                                    ulong posTicket = PositionGetTicket(k);
                                    if(!PositionSelectByTicket(posTicket)) continue;
                                    if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
                                    if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_SELL) continue;
                                    
                                    string posComment = PositionGetString(POSITION_COMMENT);
                                    if(StringFind(posComment, "Zone " + IntegerToString(cycleId)) >= 0) {
                                        // Add to tracking list
                                        g_ActivatedSellOrders[g_ActivatedSellCount].cycleId = cycleId;
                                        g_ActivatedSellOrders[g_ActivatedSellCount].entryPrice = dealPrice;
                                        g_ActivatedSellOrders[g_ActivatedSellCount].orderType = POSITION_TYPE_SELL;
                                        g_ActivatedSellOrders[g_ActivatedSellCount].activationTime = currentTime;
                                        g_ActivatedSellOrders[g_ActivatedSellCount].orderCount = 1;
                                        g_ActivatedSellOrders[g_ActivatedSellCount].lastTicket = posTicket;
                                        g_ActivatedSellOrders[g_ActivatedSellCount].lastOpenPrice = dealPrice;
                                        g_ActivatedSellCount++;
                                        
                                 
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
                
                // Reset pending order ticket
                g_SellZones[i].pendingOrderTicket = 0;
            }
        }
    }
    
    // Step 4: Update existing cycles - count positions and update order count
    for(int i = 0; i < g_ActivatedBuyCount; i++) {
        int cycleOrderCount = 0;
        double latestPrice = 0;
        datetime latestTime = 0;
        ulong latestTicket = 0;
        
        for(int j = PositionsTotal() - 1; j >= 0; j--) {
            ulong ticket = PositionGetTicket(j);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_BUY) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Zone " + IntegerToString(g_ActivatedBuyOrders[i].cycleId)) >= 0) {
                cycleOrderCount++;
                
                datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
                if(openTime > latestTime) {
                    latestTime = openTime;
                    latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                    latestTicket = ticket;
                }
            }
        }
        
        // Update cycle information
        if(cycleOrderCount > 0) {
            if(cycleOrderCount != g_ActivatedBuyOrders[i].orderCount) {
         
                
                g_ActivatedBuyOrders[i].orderCount = cycleOrderCount;
            }
            
            // Update latest order info if needed
            if(latestTime > 0) {
                g_ActivatedBuyOrders[i].lastTicket = latestTicket;
                g_ActivatedBuyOrders[i].lastOpenPrice = latestPrice;
            }
        }
    }
    
    // Do the same for Sell cycles
    for(int i = 0; i < g_ActivatedSellCount; i++) {
        int cycleOrderCount = 0;
        double latestPrice = 0;
        datetime latestTime = 0;
        ulong latestTicket = 0;
        
        for(int j = PositionsTotal() - 1; j >= 0; j--) {
            ulong ticket = PositionGetTicket(j);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            if(PositionGetInteger(POSITION_TYPE) != POSITION_TYPE_SELL) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Zone " + IntegerToString(g_ActivatedSellOrders[i].cycleId)) >= 0) {
                cycleOrderCount++;
                
                datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
                if(openTime > latestTime) {
                    latestTime = openTime;
                    latestPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                    latestTicket = ticket;
                }
            }
        }
        
        // Update cycle information
        if(cycleOrderCount > 0) {
            if(cycleOrderCount != g_ActivatedSellOrders[i].orderCount) {
             
                
                g_ActivatedSellOrders[i].orderCount = cycleOrderCount;
            }
            
            // Update latest order info if needed
            if(latestTime > 0) {
                g_ActivatedSellOrders[i].lastTicket = latestTicket;
                g_ActivatedSellOrders[i].lastOpenPrice = latestPrice;
            }
        }
    }
    
    // Optional - Print debug information about active cycles
  
        
        for(int i = 0; i < g_ActivatedBuyCount; i++) {
       
        }
        
        for(int i = 0; i < g_ActivatedSellCount; i++) {
        
        }
        
    
}
// 1. First fix the issue with Sell Zones not working
void CalculateOptimalPriceZones() {
    CalculateWeeklyAveragePrice();
    
    // Reset zones
    g_BuyZonesCount = 0;
    g_SellZonesCount = 0;
    
    double currentPrice = GetCleanPrice();
    
    // Get market volatility metrics to adjust zone distances
    double marketRange = CalculateMarketRange();
    double atr = CalculateATR(PERIOD_H1, 14) / _Point;
    
    // Adjust base distance according to current market volatility
    // Use smaller distances in lower volatility, larger in higher volatility
    double baseDistance = MathMax(20, MathMin(100, atr * 0.1));
    
    // Calculate zone distances dynamically
    double distance1 = MathMax(10, baseDistance);
    double distance2 = MathMax(30, baseDistance * 2);
    double distance3 = MathMax(50, baseDistance * 3);
    
    
    // REVERSED as requested: Buy zones ABOVE current price
    AddBuyZone(currentPrice + (distance1 * _Point), 85, "Near Resistance 1");
    AddBuyZone(currentPrice + (distance2 * _Point), 80, "Near Resistance 2");
    AddBuyZone(currentPrice + (distance3 * _Point), 75, "Near Resistance 3");
    
    // REVERSED as requested: Sell zones BELOW current price
    AddSellZone(currentPrice - (distance1 * _Point), 85, "Near Support 1");
    AddSellZone(currentPrice - (distance2 * _Point), 80, "Near Support 2");
    AddSellZone(currentPrice - (distance3 * _Point), 75, "Near Support 3");
    
    LogIdentifiedZones();
}



// Add these global variables
double g_WeeklyAveragePrice = 0;
datetime g_LastWeeklyAvgCalculation = 0;
// Sửa lại hàm ManageZoneDCA đơn giản và hiệu quả
void ManageZoneDCA() {
    if(!EnableZoneDCA) return;
    
    double currentPrice = GetCleanPrice();
    
    // Kiểm tra và xử lý DCA cho zone orders Buy
    HandleZoneBuyDCA(currentPrice);
    
    // Kiểm tra và xử lý DCA cho zone orders Sell  
    HandleZoneSellDCA(currentPrice);
}

// Hàm tính lot size cho DCA zone
double CalculateZoneDCALotSize(int orderNumber) {
    // Sử dụng cùng logic như GetNextLotSize nhưng cho zone
    double lotSize = defaultFixLength;
    
    // Áp dụng cấp số nhân như logic thường
    for(int i = 2; i <= orderNumber; i++) {
        if(i >= FirstMultiplyOrder && i < SecondMultiplyOrder) {
            lotSize *= FirstMultiplier;
        }
        else if(i >= SecondMultiplyOrder && i < ThirdMultiplyOrder) {
            lotSize *= SecondMultiplier;
        }
        else if(i >= ThirdMultiplyOrder && i < FourthMultiplyOrder) {
            lotSize *= ThirdMultiplier;
        }
        else if(i >= FourthMultiplyOrder && i < FifthMultiplyOrder) {
            lotSize *= FourthMultiplier;
        }
        else if(i >= FifthMultiplyOrder && i < SixthMultiplyOrder) {
            lotSize *= FifthMultiplier;
        }
        else if(i >= SixthMultiplyOrder) {
            lotSize *= SixthMultiplier;
        }
    }
    
    return NormalizeDouble(lotSize, 2);
}

// Calculate weekly average price
void CalculateWeeklyAveragePrice() {
    // Only recalculate once per day
    datetime currentTime = TimeCurrent();
    MqlDateTime current_struct, last_struct;
    TimeToStruct(currentTime, current_struct);
    
    if(g_LastWeeklyAvgCalculation > 0) {
        TimeToStruct(g_LastWeeklyAvgCalculation, last_struct);
        if(current_struct.day == last_struct.day && 
           current_struct.mon == last_struct.mon && 
           current_struct.year == last_struct.year) {
            return;
        }
    }
    
    // Get the last 5 daily candles
    MqlRates ratesD1[];
    ArraySetAsSeries(ratesD1, true);
    if(CopyRates(_Symbol, PERIOD_D1, 0, 5, ratesD1) < 5) {
        return;
    }
    
    // Calculate simple average of typical prices
    double sum = 0;
    for(int i = 0; i < 5; i++) {
        double typicalPrice = (ratesD1[i].high + ratesD1[i].low + ratesD1[i].close) / 3;
        sum += typicalPrice;
    }
    
    g_WeeklyAveragePrice = sum / 5;
    g_LastWeeklyAvgCalculation = currentTime;
    
}


// Function to add a buy zone
void AddBuyZone(double price, double strength, string description) {
    if(g_BuyZonesCount >= ArraySize(g_BuyZones)) return; // Ensure array isn't full
    
    // Add new zone
    g_BuyZones[g_BuyZonesCount].price = price;
    g_BuyZones[g_BuyZonesCount].strength = strength;
    g_BuyZones[g_BuyZonesCount].expiryTime = TimeCurrent() + PriceZoneValidity * 3600;
    g_BuyZones[g_BuyZonesCount].isSupportZone = true;
    g_BuyZones[g_BuyZonesCount].entryProbability = strength; // Default to same as strength
    g_BuyZones[g_BuyZonesCount].historicalTouches = CountHistoricalTouches(price, true);
    g_BuyZones[g_BuyZonesCount].pendingOrderTicket = 0;
    
    
    g_BuyZonesCount++;
}

// Function to add a sell zone
void AddSellZone(double price, double strength, string description) {
    if(g_SellZonesCount >= ArraySize(g_SellZones)) return; // Ensure array isn't full
    
    // Add new zone
    g_SellZones[g_SellZonesCount].price = price;
    g_SellZones[g_SellZonesCount].strength = strength;
    g_SellZones[g_SellZonesCount].expiryTime = TimeCurrent() + PriceZoneValidity * 3600;
    g_SellZones[g_SellZonesCount].isSupportZone = false;
    g_SellZones[g_SellZonesCount].entryProbability = strength; // Default to same as strength
    g_SellZones[g_SellZonesCount].historicalTouches = CountHistoricalTouches(price, false);
    g_SellZones[g_SellZonesCount].pendingOrderTicket = 0;
    
    
    g_SellZonesCount++;
}

// 5. Improved ExtractZoneCycleId function

int ExtractZoneCycleId(string comment) {
    int startPos = StringFind(comment, "Zone ");
    if(startPos < 0) return 0;
    
    startPos += 5; // Length of "Zone "
    
    // Find where the zone ID ends - look for both space and || patterns
    int endPos1 = StringFind(comment, " ", startPos);
    int endPos2 = StringFind(comment, "||", startPos);
    
    int endPos = -1;
    if(endPos1 >= 0 && endPos2 >= 0) {
        // Both patterns found - use the closer one
        endPos = MathMin(endPos1, endPos2);
    }
    else if(endPos1 >= 0) {
        endPos = endPos1;
    }
    else if(endPos2 >= 0) {
        endPos = endPos2;
    }
    else {
        // If neither found, use the end of the string
        endPos = StringLen(comment);
    }
    
    if(endPos <= startPos) return 0;
    
    string cycleStr = StringSubstr(comment, startPos, endPos - startPos);
    cycleStr = StringTrimRight(cycleStr);
    cycleStr = StringTrimLeft(cycleStr);
    
    return (int)StringToInteger(cycleStr);
}

void UpdateActivatedOrdersList() {
    // First identify all potential zone cycles
    int allZoneCycles[50] = {0}; // Store all cycle IDs found
    int foundCycles = 0;
    
    // Scan all positions to find Zone cycles
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Zone") < 0) continue;
        
        int cycleId = ExtractZoneCycleId(comment);
        if(cycleId <= 0) continue;
        
        // Check if we already found this cycle
        bool alreadyFound = false;
        for(int j = 0; j < foundCycles; j++) {
            if(allZoneCycles[j] == cycleId) {
                alreadyFound = true;
                break;
            }
        }
        
        // Add to list if new
        if(!alreadyFound && foundCycles < ArraySize(allZoneCycles)) {
            allZoneCycles[foundCycles] = cycleId;
            foundCycles++;
        }
    }
    
    // Reset activated order lists
    g_ActivatedBuyCount = 0;
    g_ActivatedSellCount = 0;
    
    // Rebuild activated lists from scratch
    for(int i = 0; i < foundCycles; i++) {
        int cycleId = allZoneCycles[i];
        ENUM_POSITION_TYPE posType = POSITION_TYPE_BUY; // Default
        double entryPrice = 0;
        datetime activationTime = 0;
        int orderCount = 0;
        ulong lastTicket = 0;
        double lastOpenPrice = 0;
        
        // Count orders and find details for this cycle
        for(int j = PositionsTotal() - 1; j >= 0; j--) {
            ulong ticket = PositionGetTicket(j);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Zone " + IntegerToString(cycleId)) < 0) continue;
            
            orderCount++;
            posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            
            // Track earliest position (likely first entry)
            if(activationTime == 0 || openTime < activationTime) {
                activationTime = openTime;
                entryPrice = openPrice;
            }
            
            // Track latest position
            if(openTime > activationTime) {
                lastTicket = ticket;
                lastOpenPrice = openPrice;
            }
        }
        
        if(orderCount > 0) {
            // Add to appropriate list
            if(posType == POSITION_TYPE_BUY && g_ActivatedBuyCount < ArraySize(g_ActivatedBuyOrders)) {
                g_ActivatedBuyOrders[g_ActivatedBuyCount].cycleId = cycleId;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].entryPrice = entryPrice;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].orderType = POSITION_TYPE_BUY;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].activationTime = activationTime;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].orderCount = orderCount;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].lastTicket = lastTicket > 0 ? lastTicket : 0;
                g_ActivatedBuyOrders[g_ActivatedBuyCount].lastOpenPrice = lastOpenPrice > 0 ? lastOpenPrice : entryPrice;
                g_ActivatedBuyCount++;
            }
            else if(posType == POSITION_TYPE_SELL && g_ActivatedSellCount < ArraySize(g_ActivatedSellOrders)) {
                g_ActivatedSellOrders[g_ActivatedSellCount].cycleId = cycleId;
                g_ActivatedSellOrders[g_ActivatedSellCount].entryPrice = entryPrice;
                g_ActivatedSellOrders[g_ActivatedSellCount].orderType = POSITION_TYPE_SELL;
                g_ActivatedSellOrders[g_ActivatedSellCount].activationTime = activationTime;
                g_ActivatedSellOrders[g_ActivatedSellCount].orderCount = orderCount;
                g_ActivatedSellOrders[g_ActivatedSellCount].lastTicket = lastTicket > 0 ? lastTicket : 0;
                g_ActivatedSellOrders[g_ActivatedSellCount].lastOpenPrice = lastOpenPrice > 0 ? lastOpenPrice : entryPrice;
                g_ActivatedSellCount++;
            }
        }
    }
    

}
// Add these new input parameters in your input groups section
input group "===== ZONE STOP ORDER SETTINGS ====="
input double ZoneStopDistance = 150;           // Distance for stop orders from current price (points)
input int MaxZoneOrderPairs = 3;               // Maximum number of zone order pairs
input double ZoneOrderLifetimeHours = 2;          // Lifetime for zone stop orders (hours)
input bool EnableSimultaneousZoneOrders = true; // Allow placing both buy and sell stop orders

// Add these global variables
datetime g_LastZoneOrderPlacement = 0;          // Track when zone orders were last placed
const int ZONE_ORDER_PLACEMENT_COOLDOWN = 300;  // Cooldown between placements (5 minutes)
int g_CurrentZoneOrderCount = 0;                // Track number of active zone order pairs
// Sửa hàm PlacePendingOrdersAtZones để áp dụng logic tâm giá
void PlacePendingOrdersAtZones() {
    if(!IsSpreadOK() || !CanOpenMoreOrdersInPeriod()) return;
    
    datetime currentTime = TimeCurrent();
    if(currentTime - g_LastZoneOrderPlacement < ZONE_ORDER_PLACEMENT_COOLDOWN) {
        return;
    }
    
    // Lấy giá hiện tại và tâm giá từ timeframe
    double currentPrice = GetCleanPrice();
    double centerPrice = CalculateCenterPrice(); // Từ timeframe đã chọn
    
    if(centerPrice == 0) return;
    
    // Tính khoảng cách từ giá hiện tại đến tâm giá
    double distanceFromCenter = MathAbs(currentPrice - centerPrice) / _Point;
    double requiredDistance = GetPeriodFirstEntryDistance(); // Sử dụng khoảng cách entry theo period
    
    // Chỉ đặt lệnh zone khi đủ khoảng cách từ tâm giá
    if(distanceFromCenter < requiredDistance) {
        return;
    }
    
    // Xóa lệnh cũ trước khi đặt mới
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            trade.OrderDelete(ticket);
        }
    }
    
    // Kiểm tra có lệnh zone đang active không
    bool hasActiveL1BuyPositions = false;
    bool hasActiveL1SellPositions = false;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(posType == POSITION_TYPE_BUY) hasActiveL1BuyPositions = true;
            if(posType == POSITION_TYPE_SELL) hasActiveL1SellPositions = true;
        }
    }
    
    // Logic đặt lệnh dựa trên tâm giá
    bool shouldPlaceBuy = false;
    bool shouldPlaceSell = false;
    
    // Chỉ đặt lệnh theo hướng phù hợp với tâm giá
    if(currentPrice < centerPrice && EnableBuyOrders && !hasActiveL1BuyPositions) {
        // Giá dưới tâm giá -> có thể đặt lệnh BUY
        shouldPlaceBuy = true;
    }
    
    if(currentPrice > centerPrice && EnableSellOrders && !hasActiveL1SellPositions) {
        // Giá trên tâm giá -> có thể đặt lệnh SELL  
        shouldPlaceSell = true;
    }
    
    // Đặt lệnh zone với khoảng cách từ tâm giá
    if(shouldPlaceBuy) {
        double buyStopPrice = NormalizeDouble(centerPrice + ZoneStopDistance * _Point, _Digits);
        PlaceZoneStopOrder(ORDER_TYPE_BUY_STOP, buyStopPrice, "Zone Buy");
    }
    
    if(shouldPlaceSell) {
        double sellStopPrice = NormalizeDouble(centerPrice - ZoneStopDistance * _Point, _Digits);
        PlaceZoneStopOrder(ORDER_TYPE_SELL_STOP, sellStopPrice, "Zone Sell");
    }
    
    g_LastZoneOrderPlacement = currentTime;
}


// Hàm helper để đặt lệnh zone stop




// Hàm xóa tất cả pending orders zone
void CancelAllZonePendingOrders() {
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            trade.OrderDelete(ticket);
        }
    }
}// Sửa logic đặt zone orders để luôn cách giá hiện tại đúng khoảng ZoneStopDistance




// Thêm vào phần global variables
ENUM_TIMEFRAMES g_LastUsedTimeframe = PERIOD_CURRENT;
bool g_TimeframeChanged = false;
datetime g_LastZoneCandleTime = 0;
double g_LastZoneCenterPrice = 0;
// Sửa ManagePriceZoneStrategy để không check distance từ centerPrice


// Hàm kiểm tra có position zone active không
bool HasActiveZonePositions(ENUM_POSITION_TYPE posType) {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            ENUM_POSITION_TYPE orderType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(orderType == posType) {
                return true;
            }
        }
    }
    return false;
}


void PlaceZoneOrdersIfNeeded(double currentPrice, double centerPrice) {
    datetime currentTime = TimeCurrent();
    
    // SỬA: Tăng cooldown để tránh đặt lệnh liên tục
    if(currentTime - g_LastZoneOrderPlacement < ZONE_ORDER_PLACEMENT_COOLDOWN) {
        return;
    }
    
    // Kiểm tra hướng chuyển động giá
    bool priceMovingUp = IsPriceMovingUp();
    bool priceMovingDown = IsPriceMovingDown();
    
    // Kiểm tra pending orders đã có chưa
    bool hasBuyZonePending = HasZonePendingOrders(ORDER_TYPE_BUY_STOP);
    bool hasSellZonePending = HasZonePendingOrders(ORDER_TYPE_SELL_STOP);
    
    // Kiểm tra position active
    bool hasActiveBuyZone = HasActiveZonePositions(POSITION_TYPE_BUY);
    bool hasActiveSellZone = HasActiveZonePositions(POSITION_TYPE_SELL);
    
    // Logic đặt lệnh - CHỈ đặt khi thực sự cần
    bool shouldPlaceBuy = false;
    bool shouldPlaceSell = false;
    
    if(EnableSimultaneousZoneOrders) {
        // Cho phép đặt cả 2 loại nếu enabled
        if(!hasBuyZonePending && !hasActiveBuyZone && EnableBuyOrders) {
            shouldPlaceBuy = true;
        }
        if(!hasSellZonePending && !hasActiveSellZone && EnableSellOrders) {
            shouldPlaceSell = true;
        }
    } else {
        // Đặt lệnh BUY nếu: giá đi lên và chưa có lệnh/position buy zone
        if(priceMovingUp && !hasBuyZonePending && !hasActiveBuyZone && EnableBuyOrders) {
            shouldPlaceBuy = true;
        }
        
        // Đặt lệnh SELL nếu: giá đi xuống và chưa có lệnh/position sell zone  
        if(priceMovingDown && !hasSellZonePending && !hasActiveSellZone && EnableSellOrders) {
            shouldPlaceSell = true;
        }
    }
    
    // SỬA: Đặt lệnh zone dựa trên giá hiện tại với khoảng cách cố định
    if(shouldPlaceBuy) {
        double buyZonePrice = NormalizeDouble(currentPrice + ZoneStopDistance * _Point, _Digits);
        if(PlaceZoneStopOrder(ORDER_TYPE_BUY_STOP, buyZonePrice, "Zone Buy")) {
            g_LastZoneOrderPlacement = currentTime; // CHỈ update nếu đặt lệnh thành công
        }
    }
    
    if(shouldPlaceSell) {
        double sellZonePrice = NormalizeDouble(currentPrice - ZoneStopDistance * _Point, _Digits);
        if(PlaceZoneStopOrder(ORDER_TYPE_SELL_STOP, sellZonePrice, "Zone Sell")) {
            g_LastZoneOrderPlacement = currentTime; // CHỈ update nếu đặt lệnh thành công
        }
    }
}

// Sửa ForceUpdateZoneOrdersForTimeframeChange
void ForceUpdateZoneOrdersForTimeframeChange(double newCenterPrice) {
    // Xóa tất cả pending orders zone cũ
    CancelAllZonePendingOrders();
    
    double currentPrice = GetCleanPrice();
    
    // Chỉ check có active positions không, không cần check distance từ centerPrice
    bool hasActiveBuyZone = HasActiveZonePositions(POSITION_TYPE_BUY);
    bool hasActiveSellZone = HasActiveZonePositions(POSITION_TYPE_SELL);
    
    // FIXED: Tính vị trí zone dựa trên giá hiện tại + ZoneStopDistance
    double buyZonePrice = NormalizeDouble(currentPrice + ZoneStopDistance * _Point, _Digits);
    double sellZonePrice = NormalizeDouble(currentPrice - ZoneStopDistance * _Point, _Digits);
    // Cập nhật dynamic timeframe
g_DynamicTimeframe = GetOptimalTimeframe();
    // Đặt lệnh zone với khoảng cách cố định từ giá hiện tại
    if(!hasActiveBuyZone && EnableBuyOrders) {
        PlaceZoneStopOrder(ORDER_TYPE_BUY_STOP, buyZonePrice, 
            StringFormat("Zone Buy TF:%s", EnumToString(g_DynamicTimeframe )));
    }
    
    if(!hasActiveSellZone && EnableSellOrders) {
        PlaceZoneStopOrder(ORDER_TYPE_SELL_STOP, sellZonePrice, 
            StringFormat("Zone Sell TF:%s", EnumToString(g_DynamicTimeframe )));
    }
    
    g_LastZoneOrderPlacement = TimeCurrent();
}

// Sửa UpdateZoneOrdersForNewCandle
void UpdateZoneOrdersForNewCandle(double newCenterPrice) {
    // Xóa tất cả pending orders zone cũ
    CancelAllZonePendingOrders();
    
    double currentPrice = GetCleanPrice();
    
    // Chỉ đặt lại nếu không có position zone active
    bool hasActiveBuyZone = HasActiveZonePositions(POSITION_TYPE_BUY);
    bool hasActiveSellZone = HasActiveZonePositions(POSITION_TYPE_SELL);
    
    // FIXED: Đặt zone orders cách giá hiện tại đúng ZoneStopDistance
    if(!hasActiveBuyZone && EnableBuyOrders) {
        double buyZonePrice = NormalizeDouble(currentPrice + ZoneStopDistance * _Point, _Digits);
        PlaceZoneStopOrder(ORDER_TYPE_BUY_STOP, buyZonePrice, "Zone Buy Updated");
    }
    
    if(!hasActiveSellZone && EnableSellOrders) {
        double sellZonePrice = NormalizeDouble(currentPrice - ZoneStopDistance * _Point, _Digits);
        PlaceZoneStopOrder(ORDER_TYPE_SELL_STOP, sellZonePrice, "Zone Sell Updated");
    }
}

// Sửa ManagePriceZoneStrategy để không check distance từ centerPrice
void ManagePriceZoneStrategy() {
    if(!EnablePriceZoneStrategy) return;
    
    // Hủy lệnh zone hết hạn trước
    CancelExpiredZoneOrders();
    
    // Kiểm tra market range
    double marketRange = CalculateMarketRange();
    if(marketRange < g_CurrentAIThreshold) {
        CancelAllZonePendingOrders();
        return;
    }
    // Cập nhật dynamic timeframe
g_DynamicTimeframe = GetOptimalTimeframe();
    // Lấy tâm giá từ timeframe hiện tại (chỉ để track thay đổi)
    double currentCenterPrice = CalculateCenterPriceFromTimeframe();
    if(currentCenterPrice == 0) return;
    
    // Kiểm tra nến mới của timeframe
    datetime currentCandleTime = iTime(_Symbol, g_DynamicTimeframe , 1);
    
    // Nếu timeframe thay đổi → force update ngay lập tức
    if(g_TimeframeChanged) {
        ForceUpdateZoneOrdersForTimeframeChange(currentCenterPrice);
        g_TimeframeChanged = false;
        return;
    }
    
    // Nếu có nến mới → cập nhật zone orders
    bool shouldUpdateZones = false;
    
    if(g_LastZoneCandleTime != currentCandleTime) {
        shouldUpdateZones = true;
        g_LastZoneCandleTime = currentCandleTime;
    }
    
    g_LastZoneCenterPrice = currentCenterPrice;
    
    // Cập nhật zone orders
    if(shouldUpdateZones) {

    }
    
    // Logic đặt lệnh zone mới với cooldown
    datetime currentTime = TimeCurrent();
    if(currentTime - g_LastZoneOrderPlacement < ZONE_ORDER_PLACEMENT_COOLDOWN) {
        return;
    }
    
    // REMOVED: Không check distance từ centerPrice nữa
    PlaceZoneOrdersIfNeeded(SymbolInfoDouble(_Symbol, SYMBOL_BID), currentCenterPrice);
}

// Thêm hàm hủy lệnh zone hết hạn
void CancelExpiredZoneOrders() {
    datetime currentTime = TimeCurrent();
    
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            datetime orderTime = (datetime)OrderGetInteger(ORDER_TIME_SETUP);
            
            // Hủy nếu đã quá thời gian lifetime
            if(currentTime - orderTime >= ZoneOrderLifetimeHours * 3600) {
                trade.OrderDelete(ticket);
            }
        }
    }
}
// Hàm kiểm tra có pending zone orders không
bool HasZonePendingOrders(ENUM_ORDER_TYPE orderType) {
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            ENUM_ORDER_TYPE pendingType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            if(pendingType == orderType) {
                return true;
            }
        }
    }
    return false;
}
// Hàm lấy tâm giá từ timeframe đã chọn
double CalculateCenterPriceFromTimeframe() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    // Cập nhật dynamic timeframe
g_DynamicTimeframe = GetOptimalTimeframe();
    // Lấy nến từ timeframe đã chọn (g_DynamicTimeframe )
    if(CopyRates(_Symbol, g_DynamicTimeframe , 1, 1, rates) != 1) {
        return 0;
    }
    
    // Tính tâm giá từ nến: (High + Low) / 2
    double centerPrice = (rates[0].high + rates[0].low) / 2.0;
    
    return NormalizeDouble(centerPrice, _Digits);
}

// Hàm kiểm tra giá có đang đi lên không
bool IsPriceMovingUp() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    // Cập nhật dynamic timeframe
g_DynamicTimeframe = GetOptimalTimeframe();
    // Lấy 3 nến gần nhất từ timeframe
    if(CopyRates(_Symbol, g_DynamicTimeframe , 0, 3, rates) != 3) {
        return false;
    }
    
    // So sánh close của nến hiện tại với nến trước
    return (rates[0].close > rates[1].close && rates[1].close > rates[2].close);
}

// Hàm kiểm tra giá có đang đi xuống không  
bool IsPriceMovingDown() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    
    // Lấy 3 nến gần nhất từ timeframe
    if(CopyRates(_Symbol, g_DynamicTimeframe , 0, 3, rates) != 3) {
        return false;
    }
    
    // So sánh close của nến hiện tại với nến trước
    return (rates[0].close < rates[1].close && rates[1].close < rates[2].close);
}

// Hàm kiểm tra có lệnh zone active theo loại không
bool HasActiveZoneOrders(ENUM_POSITION_TYPE posType) {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            ENUM_POSITION_TYPE orderType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(orderType == posType) {
                return true;
            }
        }
    }
    
    // Kiểm tra cả pending orders
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            if((orderType == ORDER_TYPE_BUY_STOP && posType == POSITION_TYPE_BUY) ||
               (orderType == ORDER_TYPE_SELL_STOP && posType == POSITION_TYPE_SELL)) {
                return true;
            }
        }
    }
    
    return false;
}

// Sửa hàm PlaceZoneStopOrder
bool PlaceZoneStopOrder(ENUM_ORDER_TYPE orderType, double price, string comment) {
    double lotSize = defaultFixLength;
    datetime expiration = TimeCurrent() + (int)(ZoneOrderLifetimeHours * 3600);
    
    // TP disabled - using virtual TP/SL system
    // double takeProfit = 0;
    // if(orderType == ORDER_TYPE_BUY_STOP) {
    //     takeProfit = NormalizeDouble(price + GetPeriodTP() * _Point, _Digits);
    // } else {
    //     takeProfit = NormalizeDouble(price - GetPeriodTP() * _Point, _Digits);
    // }
    
    // Kiểm tra giá hợp lệ
    double currentPrice = GetCleanPrice();
    bool validPrice = false;
    
    if(orderType == ORDER_TYPE_BUY_STOP && price > currentPrice) {
        validPrice = true;
    } else if(orderType == ORDER_TYPE_SELL_STOP && price < currentPrice) {
        validPrice = true;
    }
    
    if(!validPrice) {
        return false;
    }
    
    return trade.OrderOpen(_Symbol, orderType, lotSize, 0, price, 0, 0, 
                          ORDER_TIME_SPECIFIED, expiration, comment);
}

input int MaxActiveZoneOrders = 20;            // Maximum number of active zone orders (total)
input bool MaintainZoneOrderBalance = true;    // Maintain equal number of buy/sell stop orders
input double ZoneOrderLifetimeMinutes = 30;       // Lifetime for zone stop orders (minutes)


datetime g_LastOrderCheckTime = 0;             // Track when we last checked order counts
const int ORDER_CHECK_INTERVAL = 5;            // Check orders every 5 seconds
int g_ActiveBuyStops = 0;                      // Track active buy stops
int g_ActiveSellStops = 0;                     // Track active sell stops

// New function to clean up pending zone orders when market range is below threshold
void CleanupPendingZoneOrders() {
    static datetime lastCleanupCheck = 0;
    if(TimeCurrent() - lastCleanupCheck < 300) return; // Check every 5 minutes
    lastCleanupCheck = TimeCurrent();
    
    int cancelCount = 0;
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        if(StringFind(comment, "Zone") >= 0) {
            if(trade.OrderDelete(ticket)) {
                cancelCount++;
            }
        }
    }
    
    if(cancelCount > 0) {
    }
    
    // Also reset zone tracking variables
    for(int i = 0; i < g_BuyZonesCount; i++) {
        g_BuyZones[i].pendingOrderTicket = 0;
    }
    
    for(int i = 0; i < g_SellZonesCount; i++) {
        g_SellZones[i].pendingOrderTicket = 0;
    }
}

// Hàm c?p nh?t TP cho t?t c? l?nh trong m?t chu k?
int g_CurrentRecoveryCycleId = 0;  // Track recovery cycle ID// Function to properly handle hedge cycle completion
void HandleHedgeCycleCompletion() {
    if(!g_InHedgeCycle) return;
    
    double currentPrice = GetCleanPrice();
    double totalProfit = 0;
    bool allTPsReached = true;
    int hedgePositions = 0;
    
    // First calculate total profit and check if all TPs are actually reached
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        if(StringFind(comment, "Hedge") < 0) continue; // Only process hedge positions
        
        hedgePositions++;
        totalProfit += PositionGetDouble(POSITION_PROFIT);
        
        // Check if this position's TP is ACTUALLY reached (not just approaching)
        double tp = PositionGetDouble(POSITION_TP);
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        // Only consider TP reached when price has moved BEYOND the TP level
        bool tpReached = false;
        if(posType == POSITION_TYPE_BUY) {
            tpReached = (currentPrice >= tp);
        } else {
            tpReached = (currentPrice <= tp);
        }
        
        // If any hedge position's TP is not yet reached, we don't complete the cycle
        if(!tpReached) {
            allTPsReached = false;
        }
    }
    
    // Only close hedge cycle if profitable AND all TPs are actually reached
    if(hedgePositions > 0 && totalProfit > 0 && allTPsReached) {
 
        // Close all hedge positions
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Hedge") >= 0) {
                if(trade.PositionClose(ticket)) {
                } else {
                }
            }
        }
        
        // Reset hedge tracking variables
        g_InHedgeCycle = false;
        g_ActiveHedgeBuys = 0;
        g_ActiveHedgeSells = 0;
        g_HasActiveHedgeOrder = false;
        g_LastHedgeTime = TimeCurrent();
        
    }
}
// Hàm tính toán drawdown hi?n t?i
double CalculateCurrentDrawdown() {
    double drawdown = 0;
    
    // Duy?t qua t?t c? các v? th? ?ang m?
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        double profit = PositionGetDouble(POSITION_PROFIT);
        if(profit < 0) {
            drawdown += MathAbs(profit); // Ch? tính các v? th? ?ang l?
        }
    }
    
    return drawdown;
}
bool CheckAndUpdateDrawdownStatus() {
    // Khai báo bi?n t?nh ?? theo dõi s? l?nh ???c phép m? sau khi ??t gi?i h?n
    static int g_AllowedOrdersAfterLimit = 10;
    
    // Ki?m tra có ph?i ngày m?i không
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
    // L?y thông tin ngày tr??c ?ó
    MqlDateTime prev_struct;
    TimeToStruct(g_LastDrawdownReset, prev_struct);
    
    // Reset vào ??u ngày m?i
    if(g_LastDrawdownReset == 0 || time_struct.day != prev_struct.day) {
        // Reset các bi?n theo dõi drawdown
        g_MaxDrawdownInDay = 0;
        g_DailyDrawdownLimitReached = false;
        g_LastDrawdownReset = TimeCurrent();
        g_AllowedOrdersAfterLimit = 10; // Reset s? l?nh ???c phép m?
        
    
    }
    
    if(!EnableDailyDrawdownLimit) {
        return true; // Cho phép m? chu k? m?i n?u tính n?ng b? t?t
    }
    
    // Tính toán drawdown hi?n t?i
    double currentDrawdown = CalculateCurrentDrawdown();
    
    // C?p nh?t m?c drawdown t?i ?a n?u t?ng
    if(currentDrawdown > g_MaxDrawdownInDay) {
        g_MaxDrawdownInDay = currentDrawdown;
        
        // In thông báo khi drawdown t?ng ?áng k? (m?i 100 ??n v?)
        static double lastLoggedDrawdown = 0;
        if(currentDrawdown - lastLoggedDrawdown > 100 || currentDrawdown >= MaxDailyDrawdown) {
            lastLoggedDrawdown = currentDrawdown;
       
        }
    }
    
    // Ki?m tra n?u ?ã ??t gi?i h?n drawdown
    if(currentDrawdown >= MaxDailyDrawdown) {
        // ?ánh d?u ?ã ??t gi?i h?n
        g_DailyDrawdownLimitReached = true;
        
        // Ki?m tra các chu k? hi?n có
        bool hasExistingCycle = false;
        for(int i = PositionsTotal() - 1; i >= 0; i--) {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            
            // N?u không ph?i l?nh ??u tiên, t?c là chu k? ?ang m?
            if(StringFind(comment, "L1") < 0) {
                hasExistingCycle = true;
                break;
            }
        }
        
        // N?u có l?nh thu?c chu k? hi?n t?i, cho phép DCA
        if(hasExistingCycle) {
            static datetime lastActiveWarning = 0;
            if(TimeCurrent() - lastActiveWarning > 300) {
              
                lastActiveWarning = TimeCurrent();
            }
            return true; // Cho phép DCA
        }
        // N?u còn l?nh ???c phép m?, cho phép m? thêm l?nh m?i
        else if(g_AllowedOrdersAfterLimit > 0) {
            g_AllowedOrdersAfterLimit--;
            
     
            
            return true; // Cho phép m? l?nh m?i
        }
        else {
            static datetime lastWarning = 0;
            if(TimeCurrent() - lastWarning > 300) {
           
                lastWarning = TimeCurrent();
            }
            return false; // Không cho phép m? l?nh m?i
        }
    }
    
    return true; // Cho phép m? chu k? m?i n?u ch?a ??t gi?i h?n drawdown
}
// =============================================================================
// FLEXIBLE ZONE STRATEGY TOGGLE SYSTEM
// =============================================================================

// Thêm input parameters
input group "===== ZONE TOGGLE STRATEGY ====="
input double ZoneActivationRange = 100;        // Market range để kích hoạt zone (points)
input double ZoneDeactivationDistance = 150;   // Khoảng cách giá để tắt zone và mở DCA (points)
input int ZoneToNormalCooldown = 300;          // Cooldown khi chuyển từ zone sang normal (giây)
input int NormalToZoneCooldown = 180;          // Cooldown khi chuyển từ normal sang zone (giây)
input bool AllowMixedMode = true;              // Cho phép zone và DCA chạy song song
input double PriceMovementThreshold = 80;     // Ngưỡng di chuyển giá để chuyển mode (points)

// Enum cho strategy modes (phải khai báo trước)
enum ENUM_STRATEGY_MODE {
    MODE_NORMAL,    // DCA thông thường
    MODE_ZONE,      // Zone orders
    MODE_MIXED      // Cả hai
};

// Biến trạng thái global
bool g_ZoneModeActive = false;                 // Zone mode có đang active không
bool g_RegularDCAActive = false;               // Regular DCA có đang active không  
datetime g_LastModeSwitch = 0;                 // Thời gian chuyển mode lần cuối
double g_ModeActivationPrice = 0;              // Giá khi kích hoạt mode hiện tại
double g_LastZoneCheckPrice = 0;               // Giá check zone lần cuối
ENUM_STRATEGY_MODE g_CurrentMode = MODE_NORMAL; // Mode hiện tại

// Hàm chính quản lý chuyển đổi strategy
void ManageFlexibleZoneStrategy() {
    if(!EnablePriceZoneStrategy) {
        // Nếu tắt zone strategy, chỉ chạy DCA thông thường
        g_CurrentMode = MODE_NORMAL;
        g_ZoneModeActive = false;
        g_RegularDCAActive = true;
        return;
    }
    
    double currentPrice = GetCleanPrice();
    double marketRange = CalculateMarketRange();
    datetime currentTime = TimeCurrent();
    
    // Tính khoảng cách di chuyển giá từ lần activation cuối
    double priceMovement = 0;
    if(g_ModeActivationPrice > 0) {
        priceMovement = MathAbs(currentPrice - g_ModeActivationPrice) / _Point;
    }
    
    // Logic chuyển đổi mode
    switch(g_CurrentMode) {
        case MODE_NORMAL:
            HandleNormalToZoneTransition(marketRange, currentPrice, currentTime);
            break;
            
        case MODE_ZONE:
            HandleZoneToNormalTransition(priceMovement, currentPrice, currentTime);
            break;
            
        case MODE_MIXED:
            HandleMixedModeLogic(marketRange, priceMovement, currentPrice, currentTime);
            break;
    }
    
    // Cập nhật giá check cuối
    g_LastZoneCheckPrice = currentPrice;
}
void HandleNormalToZoneTransition(double marketRange, double currentPrice, datetime currentTime) {
    // Check cooldown
    if(currentTime - g_LastModeSwitch < NormalToZoneCooldown) return;
    
    // Check range threshold
    if(marketRange < ZoneActivationRange) return;
    
    // Multi-indicator confirmation
    double adx[], atr_curr[], atr_prev[];
    bool isSideway = false;
    
    // ADX check
    if(CopyBuffer(g_ADX_Handle, 0, 0, 1, adx) >= 1) {
        isSideway = (adx[0] < 20);
    }
    
    // ATR confirmation - ATR không tăng mạnh
    int atrHandle = iATR(_Symbol, PERIOD_H1, 14);
    if(CopyBuffer(atrHandle, 0, 0, 1, atr_curr) >= 1 && 
       CopyBuffer(atrHandle, 0, 1, 1, atr_prev) >= 1) {
        double atrChange = (atr_curr[0] - atr_prev[0]) / atr_prev[0];
        if(atrChange > 0.15) isSideway = false; // ATR tăng >15% = trending
    }
    
    // MFI check - không extreme
    double mfi[];
    bool mfiNeutral = true;
    if(CopyBuffer(g_MFI_Handle, 0, 0, 1, mfi) >= 1) {
        mfiNeutral = (mfi[0] > 30 && mfi[0] < 70);
    }
    
    // Final decision
    bool allowMixed = (isSideway && mfiNeutral);
    
    g_CurrentMode = allowMixed ? MODE_MIXED : MODE_ZONE;
    g_ZoneModeActive = true;
    g_RegularDCAActive = allowMixed;
    g_LastModeSwitch = currentTime;
    g_ModeActivationPrice = currentPrice;
    

    if(!allowMixed) {
        CancelRegularDCAPendingOrders();
    }
    
    ActivateZoneStrategy();
}// Hàm tính dynamic threshold dựa order flow
double GetDynamicZoneThreshold() {
    double baseThreshold = 1500.0; // Base points
    
    // A/D strength
    double ad[];
    if(CopyBuffer(g_AD_Handle, 0, 0, 2, ad) >= 2) {
        double adChange = MathAbs(ad[0] - ad[1]);
        double adAvg = (MathAbs(ad[0]) + MathAbs(ad[1])) / 2;
        if(adAvg > 0) {
            double adStrength = adChange / adAvg;
            if(adStrength > 0.05) baseThreshold *= 0.7; // Flow mạnh = giảm threshold
        }
    }
    
    // Force Index
    double force[];
    if(CopyBuffer(g_Force_Handle, 0, 0, 1, force) >= 1) {
        if(MathAbs(force[0]) > 1000) baseThreshold *= 0.8;
    }
    
    // MFI extreme
    double mfi[];
    if(CopyBuffer(g_MFI_Handle, 0, 0, 1, mfi) >= 1) {
        if(mfi[0] < 30 || mfi[0] > 70) baseThreshold *= 0.75;
    }
    
    return MathMax(baseThreshold, 800); // Min 800 points
}
// Hàm tính volume profile score
double GetVolumeProfileScore() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M15, 0, 100, rates) < 100) return 0;
    
    double currentPrice = GetCleanPrice();
    
    // Phân chia giá thành 20 vùng
    double highest = rates[0].high;
    double lowest = rates[0].low;
    for(int i = 1; i < 100; i++) {
        if(rates[i].high > highest) highest = rates[i].high;
        if(rates[i].low < lowest) lowest = rates[i].low;
    }
    
    double priceRange = highest - lowest;
    double binSize = priceRange / 20;
    double volumeBins[20];
    ArrayInitialize(volumeBins, 0);
    
    // Tính volume cho mỗi vùng giá
    for(int i = 0; i < 100; i++) {
        int binIndex = (int)((rates[i].close - lowest) / binSize);
        if(binIndex >= 20) binIndex = 19;
        if(binIndex < 0) binIndex = 0;
        volumeBins[binIndex] += rates[i].tick_volume;
    }
    
    // Tìm POC (Point of Control) - vùng volume cao nhất
    int pocIndex = 0;
    long maxVol = 0;
    for(int i = 0; i < 20; i++) {
        if(volumeBins[i] > maxVol) {
            maxVol = volumeBins[i];
            pocIndex = i;
        }
    }
    
    // Tính khoảng cách giá hiện tại đến POC
    double pocPrice = lowest + (pocIndex * binSize);
    double distanceToPOC = MathAbs(currentPrice - pocPrice) / _Point;
    
    // Score cao = xa POC = nên kích hoạt zone
    return distanceToPOC;
}

// Hàm check conflict
bool HasZoneDCAConflict() {
    bool hasZoneBuy = false, hasZoneSell = false;
    bool hasMerlinBuy = false, hasMerlinSell = false;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        if(StringFind(comment, "Zone") >= 0) {
            if(type == POSITION_TYPE_BUY) hasZoneBuy = true;
            else hasZoneSell = true;
        }
        else if(StringFind(comment, "Merlin") >= 0 || StringFind(comment, "DCA") >= 0) {
            if(type == POSITION_TYPE_BUY) hasMerlinBuy = true;
            else hasMerlinSell = true;
        }
    }
    
    return (hasZoneBuy && hasMerlinBuy) || (hasZoneSell && hasMerlinSell);
}

void CleanupConflictingOrders() {
    bool hasConflict = false;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        string comment = PositionGetString(POSITION_COMMENT);
        
        if(StringFind(comment, "Merlin") >= 0 || StringFind(comment, "Zone") >= 0) {
            hasConflict = true;
            break;
        }
    }
    
    if(hasConflict) {
    }
    return;

}
// Thêm globals
datetime g_LastCycleCloseTime = 0;
int g_CooldownAfterClose = 300; // 5 phút

// Hàm reset state sau khi đóng hết
void ResetAfterFullClose() {
    if(PositionsTotal() == 0) {
        static bool wasReset = false;
        
        if(!wasReset) {
            g_LastCycleCloseTime = TimeCurrent();
            g_CurrentMode = MODE_NORMAL;
            g_ZoneModeActive = false;
            g_RegularDCAActive = true;
            canOpenNewTrade_Buy = false; // Block ngay
            canOpenNewTrade_Sell = false;
            wasReset = true;
        }
    } else {
            static bool wasReset = false;

        wasReset = false;
    }
}

// Hàm check cooldown
bool IsInCooldownPeriod() {
    if(g_LastCycleCloseTime == 0) return false;
    return (TimeCurrent() - g_LastCycleCloseTime < g_CooldownAfterClose);
}

int g_ADX_Handle = INVALID_HANDLE;
double g_ADX_Buffer[];
// Xử lý chuyển từ Zone sang Normal
void HandleZoneToNormalTransition(double priceMovement, double currentPrice, datetime currentTime) {
    // Kiểm tra cooldown
    if(currentTime - g_LastModeSwitch < ZoneToNormalCooldown) {
        return;
    }
      // Dynamic threshold từ order flow
    double dynamicThreshold = GetDynamicZoneThreshold();
    
double volumeScore = GetVolumeProfileScore();
    
    // Kích hoạt zone nếu: xa POC (>500 points) HOẶC market range lớn
    bool shouldActivate = (volumeScore > 500 &&  dynamicThreshold);
    
    if(!shouldActivate) return;    // Điều kiện tắt zone: giá di chuyển đủ khoảng cách
    bool shouldDeactivateZone = false;
    
    // Cách 1: Kiểm tra khoảng cách di chuyển từ activation price
    if(priceMovement >= ZoneDeactivationDistance) {
        shouldDeactivateZone = true;
    }
    
    // Cách 2: Kiểm tra market range giảm xuống dưới ngưỡng
    double marketRange = CalculateMarketRange();
    if(marketRange < ZoneActivationRange * 0.7) { // 70% ngưỡng kích hoạt
        shouldDeactivateZone = true;
    }
    
    if(shouldDeactivateZone) {
        // Chuyển về normal mode
        g_CurrentMode = MODE_NORMAL;
        g_ZoneModeActive = false;
        g_RegularDCAActive = true;
        g_LastModeSwitch = currentTime;
        g_ModeActivationPrice = currentPrice;
        
        // Hủy zone orders pending
        CancelAllZonePendingOrders();
        
        // Kích hoạt lại DCA thông thường
    }
}

// Xử lý mixed mode
void HandleMixedModeLogic(double marketRange, double priceMovement, double currentPrice, datetime currentTime) {
    // Trong mixed mode, cả zone và DCA đều active
    
    // Tắt zone nếu điều kiện không còn phù hợp
    if(priceMovement >= ZoneDeactivationDistance || marketRange < ZoneActivationRange * 0.6) {
        g_CurrentMode = MODE_NORMAL;
        g_ZoneModeActive = false;
        g_RegularDCAActive = true;
        g_LastModeSwitch = currentTime;
        g_ModeActivationPrice = currentPrice;
        
        CancelAllZonePendingOrders();
    }
}

// Kích hoạt zone strategy
void ActivateZoneStrategy() {
    // Tính toán và đặt zone orders mới
    CalculateOptimalPriceZones();
    
    // Đặt pending orders cho zones
    double currentPrice = GetCleanPrice();
    PlaceInitialZoneOrders(currentPrice);
}

// Kích hoạt lại DCA thông thường
void ReactivateRegularDCA() {
    // Reset các biến trạng thái DCA
    g_WaitingForNewEntry = false;
    
    // Kiểm tra và mở lệnh DCA mới nếu cần
    double currentPrice = GetCleanPrice();
    
    // Logic mở lệnh DCA thông thường dựa trên center price
    CheckAndOpenRegularDCAOrders(currentPrice);
}


// Đặt zone orders ban đầu
void PlaceInitialZoneOrders(double currentPrice) {
    // Đặt buy stop orders phía trên giá hiện tại
    if(EnableBuyOrders && !HasActiveZonePositions(POSITION_TYPE_BUY)) {
        double buyZonePrice = NormalizeDouble(currentPrice + ZoneStopDistance * _Point, _Digits);
        PlaceZoneStopOrder(ORDER_TYPE_BUY_STOP, buyZonePrice, "Zone Buy Initial");
    }
    
    // Đặt sell stop orders phía dưới giá hiện tại  
    if(EnableSellOrders && !HasActiveZonePositions(POSITION_TYPE_SELL)) {
        double sellZonePrice = NormalizeDouble(currentPrice - ZoneStopDistance * _Point, _Digits);
        PlaceZoneStopOrder(ORDER_TYPE_SELL_STOP, sellZonePrice, "Zone Sell Initial");
    }
}



// Kiểm tra có thể mở lệnh DCA mới không
bool CanOpenNewDCAOrder(ENUM_POSITION_TYPE posType, double currentPrice) {
    // Kiểm tra period limits
    if(!EnforcePeriodOrderLimits()) return false;
    
    // Kiểm tra khoảng cách với lệnh cuối
    double lastPrice = GetLatestOrderPrice(posType, false, false);
    if(lastPrice > 0) {
        double distance = MathAbs(currentPrice - lastPrice) / _Point;
        double requiredDistance = GetStandardDCADistance(
            (posType == POSITION_TYPE_BUY) ? g_TotalOrders_Buy + 1 : g_TotalOrders_Sell + 1
        );
        
        if(distance < requiredDistance) return false;
    }
    
    // Kiểm tra minimum distance
    return CheckMinimumDistanceBetweenOrders(currentPrice, posType);
}

// Hủy pending orders DCA thông thường
void CancelRegularDCAPendingOrders() {
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        
        string comment = OrderGetString(ORDER_COMMENT);
        // Hủy orders không phải zone
        if(StringFind(comment, "Zone") < 0) {
            trade.OrderDelete(ticket);
        }
    }
}

bool RunFlexibleZoneStrategy() {
                double currentpirce = GetCleanPrice();

    switch(g_CurrentMode) {
       case MODE_NORMAL:
       ManageFlexibleZoneStrategy();
            break;
            
            
        case MODE_ZONE:
            if(g_ZoneModeActive) {
                bool canTradeBuyZone = true;
                bool canTradeSellZone = true;
                
                if(g_InNarrowRange) {
                    if(g_TotalOrders_Buy > 0) canTradeBuyZone = HasStrongMoneyFlow(POSITION_TYPE_BUY);
                    if(g_TotalOrders_Sell > 0) canTradeSellZone = HasStrongMoneyFlow(POSITION_TYPE_SELL);
                }
                
                if(canTradeBuyZone || canTradeSellZone) {
           ManagePriceZoneStrategy();
ManageZoneDCA();
              
                }
            }
            break;
            
        case MODE_MIXED: {
            bool allowDCA = true;
            bool allowZone = true;
            
            if(g_InNarrowRange) {
                if(g_TotalOrders_Buy > 0 && !HasStrongMoneyFlow(POSITION_TYPE_BUY)) {
                    allowDCA = false;
                    allowZone = false;
                }
                if(g_TotalOrders_Sell > 0 && !HasStrongMoneyFlow(POSITION_TYPE_SELL)) {
                    allowDCA = false;
                    allowZone = false;
                }
            }
            
            if(g_RegularDCAActive && allowDCA) {
            }
            if(g_ZoneModeActive && allowZone) {
            }
            
 

          break;
        }
    }
    return false;
}
// FIX: LOGIC TÂM GIÁ CHO DCA THÔNG THƯỜNG
// Thêm input mới cho regular DCA timeframe
input group "===== REGULAR DCA TIMEFRAME SETTINGS ====="
input ENUM_TIMEFRAMES RegularDCATimeframe = PERIOD_H1;  // Timeframe riêng cho DCA thường
input int CandlesToAnalyze = 50;                        // Số nến phân tích để tính center price

// Thêm biến global để track nến mới cho regular DCA
datetime g_LastRegularDCACandleTime = 0;
double g_LastRegularDCACenterPrice = 0;

// Hàm tính center price cho regular DCA từ timeframe riêng
double CalculateRegularDCACenterPrice() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    
    int copied = CopyRates(_Symbol, RegularDCATimeframe, 1, CandlesToAnalyze, rates);
    if(copied < CandlesToAnalyze) return 0;
    
    double totalHL = 0;
    for(int i = 0; i < CandlesToAnalyze; i++) {
        totalHL += (rates[i].high + rates[i].low) / 2;
    }
    
    return NormalizeDouble(totalHL / CandlesToAnalyze, _Digits);
}

// Hàm kiểm tra nến mới cho regular DCA
bool IsNewRegularDCACandle() {
    datetime currentCandleTime = iTime(_Symbol, RegularDCATimeframe, 1);
    if(g_LastRegularDCACandleTime != currentCandleTime) {
        g_LastRegularDCACandleTime = currentCandleTime;
        return true;
    }
    return false;
}
// Hàm check volume momentum
bool HasStrongVolumeMomentum(ENUM_POSITION_TYPE posType) {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M5, 0, 10, rates) < 10) return false;
    
    // Tính average volume
    long avgVolume = 0;
    for(int i = 1; i < 10; i++) {
        avgVolume += rates[i].tick_volume;
    }
    avgVolume = avgVolume / 9;
    
    // Current volume phải > 1.5x average
    if(rates[0].tick_volume < avgVolume * 1.5) return false;
    
    // Volume phải tăng dần (3 bars gần nhất)
    bool volumeIncreasing = (rates[0].tick_volume > rates[1].tick_volume && 
                             rates[1].tick_volume > rates[2].tick_volume);
    
    if(!volumeIncreasing) return false;
    
    // Check price movement phù hợp với position type
    bool priceMovingRight = false;
    if(posType == POSITION_TYPE_BUY) {
        // Buy: giá đang giảm với volume cao = good entry
        priceMovingRight = (rates[0].close < rates[2].close);
    } else {
        // Sell: giá đang tăng với volume cao = good entry
        priceMovingRight = (rates[0].close > rates[2].close);
    }
    
    return priceMovingRight;
}
// Hàm chọn timeframe động dựa trên market range
ENUM_TIMEFRAMES GetDynamicTimeframe(double marketRange) {
    
    // Biến động rất mạnh → M5
    if(marketRange > 50009) {
        return PERIOD_H4;
    }
    // Biến động mạnh → M15
    else if(marketRange > 11000) {
        return PERIOD_M15;
    }
    // Biến động trung bình → M30
    else if(marketRange > 20000) {
        return PERIOD_M30;
    }
    // Biến động thấp → H1
    else if(marketRange > 30000) {
        return PERIOD_H1;
    }
    // Biến động rất thấp → H4
    else {
        return PERIOD_M5;
    }
}

// Hàm tính center price động
double CalculateDynamicCenterPrice(ENUM_TIMEFRAMES timeframe) {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    
    int bars = 20; // Dùng 20 bars
    if(CopyRates(_Symbol, timeframe, 0, bars, rates) < bars) {
        return 0;
    }
    
    // Tính trung bình high và low
    double highest = rates[0].high;
    double lowest = rates[0].low;
    
    for(int i = 1; i < bars; i++) {
        if(rates[i].high > highest) highest = rates[i].high;
        if(rates[i].low < lowest) lowest = rates[i].low;
    }
    
    double centerPrice = (highest + lowest) / 2;
  
    return centerPrice;
}
// Thêm globals
static datetime g_LastBuyOrderTime = 0;
static datetime g_LastSellOrderTime = 0;

void HandleRegularDCA() {
    if(!IsSpreadOK()) return;

    // AI-Based DCA Block Check
    if(g_AI_BlockDCA_Buy || g_AI_BlockDCA_Sell) {
        return;
    }

    double currentPrice = GetCleanPrice();
    double marketRange = CalculateMarketRange();
    ENUM_TIMEFRAMES dynamicTF = GetDynamicTimeframe(marketRange);
    double centerPrice = CalculateDynamicCenterPrice(dynamicTF);
    
    if(centerPrice == 0) return;
    
    double distanceFromCenter = MathAbs(currentPrice - centerPrice) / _Point;
    if(distanceFromCenter < 200) return;
  if (g_TotalOrders_Buy == 0 && g_TotalOrders_Sell == 0)
{  
    // BUY LOGIC
    if(currentPrice < centerPrice && EnableBuyOrders) {
        if(g_TotalOrders_Buy >= 20) return;
        
        // CRITICAL: Cooldown 30 giây giữa orders
        if(TimeCurrent() - g_LastBuyOrderTime < 30) {
            return;
        }
        
        bool canOpenBuy = false;
        
        if(g_TotalOrders_Buy == 0) {
            canOpenBuy = true;
        }
        else if(g_LastBuyPrice > 0) {
            double distance = (g_LastBuyPrice - currentPrice) / _Point;
            double required = GetStandardDCADistance(g_TotalOrders_Buy + 1, false);
            
            
            // STRICT: Price phải thấp hơn VÀ đủ distance
            if(currentPrice < g_LastBuyPrice && distance >= required) {
                canOpenBuy = true;
            } else {
                return;
            }
        }
        
        if(canOpenBuy) {
            double lotSize = GetNextLotSize(POSITION_TYPE_BUY);
            double tp = centerPrice + (100 * _Point);
            string comment = StringFormat("Regular Buy #%d", g_TotalOrders_Buy + 1);
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, currentPrice, 0, 0, comment)) {
                // CẬP NHẬT NGAY LẬP TỨC
                g_LastBuyPrice = currentPrice;
                g_LastBuyOrderTime = TimeCurrent();
                UpdateLastPriceWithVolumeProfile(POSITION_TYPE_BUY, currentPrice);
                UpdatePeriodOrderCount();
            }
        }
    }
    
    // SELL LOGIC
    if(currentPrice > centerPrice && EnableSellOrders) {
        if(g_TotalOrders_Sell >= 20) return;
        
        if(TimeCurrent() - g_LastSellOrderTime < 30) {
            return;
        }
        
        bool canOpenSell = false;
        
        if(g_TotalOrders_Sell == 0) {
            canOpenSell = true;
        }
        else if(g_LastSellPrice > 0) {
            double distance = (currentPrice - g_LastSellPrice) / _Point;
            double required = GetStandardDCADistance(g_TotalOrders_Sell + 1, false);
            
            
            if(currentPrice > g_LastSellPrice && distance >= required) {
                canOpenSell = true;
            } else {
                return;
            }
        }
        
        if(canOpenSell) {
            double lotSize = GetNextLotSize(POSITION_TYPE_SELL);
            double tp = centerPrice - (100 * _Point);
            string comment = StringFormat("Regular Sell #%d", g_TotalOrders_Sell + 1);
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, currentPrice, 0, 0, comment)) {
                g_LastSellPrice = currentPrice;
                g_LastSellOrderTime = TimeCurrent();
                UpdateLastPriceWithVolumeProfile(POSITION_TYPE_SELL, currentPrice);
                UpdatePeriodOrderCount();
            }
        }
    }
    }
}

// Thêm globals
double g_LastBuyPrice = 0;
double g_LastSellPrice = 0;

// Hàm cập nhật last price với volume profile
void UpdateLastPriceWithVolumeProfile(ENUM_POSITION_TYPE posType, double newPrice) {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M5, 0, 20, rates) < 20) {
        // Fallback: update trực tiếp
        if(posType == POSITION_TYPE_BUY) g_LastBuyPrice = newPrice;
        else g_LastSellPrice = newPrice;
        return;
    }
    
    // Tính volume ở vùng giá mới
    long volumeAtNewPrice = 0;
    for(int i = 0; i < 20; i++) {
        double priceRange = MathAbs(newPrice - rates[i].close) / _Point;
        if(priceRange < 50) { // Trong vùng 50 points
            volumeAtNewPrice += rates[i].tick_volume;
        }
    }
    
    // So sánh với last price hiện tại
    double currentLastPrice = (posType == POSITION_TYPE_BUY) ? g_LastBuyPrice : g_LastSellPrice;
    
    if(currentLastPrice > 0) {
        long volumeAtLastPrice = 0;
        for(int i = 0; i < 20; i++) {
            double priceRange = MathAbs(currentLastPrice - rates[i].close) / _Point;
            if(priceRange < 50) {
                volumeAtLastPrice += rates[i].tick_volume;
            }
        }
        
        // Chỉ update nếu vùng mới có volume cao hơn HOẶC là giá mới nhất
        if(volumeAtNewPrice >= volumeAtLastPrice) {
            if(posType == POSITION_TYPE_BUY) g_LastBuyPrice = newPrice;
            else g_LastSellPrice = newPrice;
        }
    } else {
        // Lần đầu
        if(posType == POSITION_TYPE_BUY) g_LastBuyPrice = newPrice;
        else g_LastSellPrice = newPrice;
    }
}


// Sửa hàm CheckAndOpenRegularDCAOrders để sử dụng center price riêng
void CheckAndOpenRegularDCAOrders(double currentPrice) {
    double centerPrice = CalculateRegularDCACenterPrice();
    if(centerPrice == 0) return;
    
    double distanceFromCenter = MathAbs(currentPrice - centerPrice) / _Point;
    double requiredDistance = GetPeriodFirstEntryDistance();
    
    if(distanceFromCenter >= requiredDistance) {
        // Kiểm tra điều kiện mở lệnh buy
        if(EnableBuyOrders && currentPrice < centerPrice) {
            double latestBuyPrice = GetLatestOrderPrice(POSITION_TYPE_BUY);
            if(latestBuyPrice == 0 || (currentPrice - latestBuyPrice) / _Point >= GetAdjustedDCADistanceEnhanced(g_TotalOrders_Buy)) {
                OpenRegularDCAOrder(currentPrice, POSITION_TYPE_BUY);
            }
        }
        
        // Kiểm tra điều kiện mở lệnh sell
        if(EnableSellOrders && currentPrice > centerPrice) {
            double latestSellPrice = GetLatestOrderPrice(POSITION_TYPE_SELL);
            if(latestSellPrice == 0 || (latestSellPrice - currentPrice) / _Point >= GetAdjustedDCADistanceEnhanced(g_TotalOrders_Sell)) {
                OpenRegularDCAOrder(currentPrice, POSITION_TYPE_SELL);
            }
        }
    }
}

// Hàm cập nhật số đếm lệnh
void UpdateOrderCounters(ENUM_POSITION_TYPE posType) {
    if(posType == POSITION_TYPE_BUY) {
        g_TotalOrders_Buy++;
    } else {
        g_TotalOrders_Sell++;
    }
}

// Hàm mở lệnh DCA thường với logic center price riêng
void OpenRegularDCAOrder(double currentPrice, ENUM_POSITION_TYPE posType) {
    // Check AI Block
    if(posType == POSITION_TYPE_BUY && g_AI_BlockDCA_Buy) {
        return;
    }
    if(posType == POSITION_TYPE_SELL && g_AI_BlockDCA_Sell) {
        return;
    }

    double centerPrice = CalculateRegularDCACenterPrice();
    if(centerPrice == 0) return;

    // Kiểm tra điều kiện center price
    bool validDirection = false;
    if(posType == POSITION_TYPE_BUY && currentPrice < centerPrice) {
        validDirection = true;
    } else if(posType == POSITION_TYPE_SELL && currentPrice > centerPrice) {
        validDirection = true;
    }

    if(!validDirection) return;
    
    // Logic mở lệnh như cũ
    double volume = GetNextLotSize(posType);
    string comment = posType == POSITION_TYPE_BUY ? BuyComment : SellComment;
    
    ENUM_ORDER_TYPE orderType = (posType == POSITION_TYPE_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
    
    if(trade.PositionOpen(_Symbol, orderType, volume, currentPrice, 0, 0, comment)) {
        UpdateOrderCounters(posType);
        g_LastOrderTime = TimeCurrent();
    }
}
double g_LastOrderTime = 0;

// Sửa hàm HandleBuyDCA để sử dụng timeframe riêng

// Sửa logic mở lệnh đầu tiên trong OnTick()
void CheckAndOpenFirstOrders(double currentPrice) {
    // Chỉ kiểm tra khi chưa có lệnh nào
    if(g_TotalOrders_Buy > 0 || g_TotalOrders_Sell > 0) return;
    
    double centerPrice = CalculateCenterPrice();
    if(centerPrice == 0) return;
    
    double distanceFromCenter = MathAbs(currentPrice - centerPrice) / _Point;
    double requiredDistance = GetPeriodFirstEntryDistance();
    
    // Chỉ mở khi đủ khoảng cách từ tâm giá
    if(distanceFromCenter < requiredDistance) return;
    
    // Mở Buy nếu giá < tâm giá
    if(currentPrice < centerPrice && EnableBuyOrders) {
        double volume = defaultFixLength;
        // double takeProfit = CalculateOrderTP( // DISABLEDORDER_TYPE_BUY, currentPrice, 1);
        string comment = StringFormat("%s #1", BuyComment);
        
        if(trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, volume, currentPrice, 0, 0, comment)) {
            UpdatePeriodOrderCount();
        }
    }
    // Mở Sell nếu giá > tâm giá
    else if(currentPrice > centerPrice && EnableSellOrders) {
        double volume = defaultFixLength;
        // double takeProfit = CalculateOrderTP( // DISABLEDORDER_TYPE_SELL, currentPrice, 1);
        string comment = StringFormat("%s #1", SellComment);
        
        if(trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, volume, currentPrice, 0, 0, comment)) {
            UpdatePeriodOrderCount();
        }
    }
}
// Thay thế logic cũ trong OnTick()


/*
CÁCH SỬ DỤNG:
Trong OnTick(), thay thế:

// Cũ:
if(g_TotalOrders_Buy > 0 && g_TotalOrders_Buy < MaxOrders) {
    HandleBuyDCA(currentPrice);
}
if(g_TotalOrders_Sell > 0 && g_TotalOrders_Sell < MaxOrders) {
    HandleSellDCA(currentPrice);
}

// Mới:
HandleRegularDCA();
*/

// USAGE: Thay thế trong OnTick()
/*
// Thay thế:
if(EnablePriceZoneStrategy) {
    ManagePriceZoneStrategy();
    ManageZoneDCA();
}

// Bằng:
RunFlexibleZoneStrategy();
*/


// Volume Profile Settings
input int VolumeProfileBars = 500;           // Số nến để tính volume profile
input double HighVolumeThreshold = 1.5;      // Ngưỡng HVN (1.5x volume trung bình)
input double LowVolumeThreshold = 0.5;       // Ngưỡng LVN (0.5x volume trug bình)
input bool TradeInLowVolume = true;          // true: trade ở LVN, false: trade ở HVN

// Volume Profile Data
struct VolumeNode {
    double price;
    double volume;
};
VolumeNode g_VolumeProfile[];
double g_POC = 0;                            // Point of Control
double g_VAH = 0;                            // Value Area High
double g_VAL = 0;                            // Value Area Low
bool g_AllowTrading = true;
// Thêm input parameter này vào nhóm input ??u tiên
input group "===== QU?N LÝ DRAWDOWN HÀNG NGÀY ====="
input bool EnableDailyDrawdownLimit = true;    // B?t/t?t gi?i h?n drawdown hàng ngày
input double MaxDailyDrawdown = 1000;          // Drawdown t?i ?a trong ngày (USD)

// Thêm các bi?n toàn c?c này
double g_MaxDrawdownInDay = 0;                 // M?c drawdown t?i ?a ?ã ??t ???c trong ngày
bool g_DailyDrawdownLimitReached = false;     // C? báo ?ã ??t gi?i h?n drCalculateCenterPriceawdown

void CalculateVolumeProfile() {
    int pricelevels = 100;
    ArrayResize(g_VolumeProfile, pricelevels);
    
    // Tìm high/low trong period
    double highest = iHigh(_Symbol, PERIOD_CURRENT, iHighest(_Symbol, PERIOD_CURRENT, MODE_HIGH, VolumeProfileBars, 0));
    double lowest = iLow(_Symbol, PERIOD_CURRENT, iLowest(_Symbol, PERIOD_CURRENT, MODE_LOW, VolumeProfileBars, 0));
    double priceStep = (highest - lowest) / pricelevels;
    
    if(priceStep <= 0) return;
    
    // Khởi tạo price levels
    for(int i = 0; i < pricelevels; i++) {
        g_VolumeProfile[i].price = lowest + (i * priceStep);
        g_VolumeProfile[i].volume = 0;
    }
    
    // Tính volume cho mỗi price level
    for(int bar = 0; bar < VolumeProfileBars; bar++) {
        double high = iHigh(_Symbol, PERIOD_CURRENT, bar);
        double low = iLow(_Symbol, PERIOD_CURRENT, bar);
        long volume = iVolume(_Symbol, PERIOD_CURRENT, bar);
        
        // Phân bổ volume vào các price level
        for(int i = 0; i < pricelevels; i++) {
            if(g_VolumeProfile[i].price >= low && g_VolumeProfile[i].price <= high) {
                g_VolumeProfile[i].volume += volume;
            }
        }
    }
    
    // Tìm POC (price level có volume cao nhất)
    double maxVolume = 0;
    int pocIndex = 0;
    for(int i = 0; i < pricelevels; i++) {
        if(g_VolumeProfile[i].volume > maxVolume) {
            maxVolume = g_VolumeProfile[i].volume;
            pocIndex = i;
        }
    }
    g_POC = g_VolumeProfile[pocIndex].price;
    
    // Tính tổng volume
    double totalVolume = 0;
    for(int i = 0; i < pricelevels; i++) {
        totalVolume += g_VolumeProfile[i].volume;
    }
    
    // Tìm Value Area (70% volume xung quanh POC)
    double valueAreaVolume = totalVolume * 0.7;
    double currentVolume = g_VolumeProfile[pocIndex].volume;
    int upperIndex = pocIndex;
    int lowerIndex = pocIndex;
    
    while(currentVolume < valueAreaVolume && (upperIndex < pricelevels - 1 || lowerIndex > 0)) {
        double upperVol = (upperIndex < pricelevels - 1) ? g_VolumeProfile[upperIndex + 1].volume : 0;
        double lowerVol = (lowerIndex > 0) ? g_VolumeProfile[lowerIndex - 1].volume : 0;
        
        if(upperVol > lowerVol && upperIndex < pricelevels - 1) {
            upperIndex++;
            currentVolume += upperVol;
        } else if(lowerIndex > 0) {
            lowerIndex--;
            currentVolume += lowerVol;
        } else {
            break;
        }
    }
    
    g_VAH = g_VolumeProfile[upperIndex].price;
    g_VAL = g_VolumeProfile[lowerIndex].price;
}
// Hàm mở lệnh theo single direction

// Helper functions
bool IsSwingLow(int shift) {
    if(shift < 2) return false;
    
    double low0 = iLow(_Symbol, PERIOD_M5, shift);
    double low1 = iLow(_Symbol, PERIOD_M5, shift - 1);
    double low2 = iLow(_Symbol, PERIOD_M5, shift + 1);
    
    return (low0 < low1 && low0 < low2);
}

bool IsSwingHigh(int shift) {
    if(shift < 2) return false;
    
    double high0 = iHigh(_Symbol, PERIOD_M5, shift);
    double high1 = iHigh(_Symbol, PERIOD_M5, shift - 1);
    double high2 = iHigh(_Symbol, PERIOD_M5, shift + 1);
    
    return (high0 > high1 && high0 > high2);
}

bool IsBullishReversal() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M5, 0, 3, rates) < 3) return false;
    
    // Hammer or bullish engulfing
    bool hammer = (rates[0].close > rates[0].open && 
                   (rates[0].close - rates[0].open) > (rates[0].high - rates[0].low) * 0.6);
    
    bool engulfing = (rates[0].close > rates[0].open && 
                     rates[1].close < rates[1].open &&
                     rates[0].close > rates[1].open &&
                     rates[0].open < rates[1].close);
    
    return (hammer || engulfing);
}

bool IsBearishReversal() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M5, 0, 3, rates) < 3) return false;
    
    // Shooting star or bearish engulfing
    bool shootingStar = (rates[0].close < rates[0].open && 
                        (rates[0].open - rates[0].close) > (rates[0].high - rates[0].low) * 0.6);
    
    bool engulfing = (rates[0].close < rates[0].open && 
                     rates[1].close > rates[1].open &&
                     rates[0].close < rates[1].open &&
                     rates[0].open > rates[1].close);
    
    return (shootingStar || engulfing);
}

double GetMomentumScore(ENUM_POSITION_TYPE posType) {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M5, 0, 10, rates) < 10) return 0;
    
    int bullishBars = 0;
    for(int i = 0; i < 5; i++) {
        if(rates[i].close > rates[i].open) bullishBars++;
    }
    
    double score = (double)bullishBars / 5.0;
    
    if(posType == POSITION_TYPE_SELL) score = 1.0 - score;
    
    return score;
}

double GetSingleDirectionDCADistance(int orderNumber, ENUM_POSITION_TYPE posType) {
    return GetStandardDCADistance(orderNumber + 1, true); // true = breakout mode
}

void HandleSingleDirectionEntry() {
    if(g_DailyAllowedDirection == DAILY_BOTH) return;
    
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // ===========================================================================
    // BUY ONLY
    // ===========================================================================
    if(g_DailyAllowedDirection == DAILY_BUY_ONLY) {
        bool canOpenBuy = false;
        string entryReason = "";
        
        if(g_TotalOrders_Buy == 0) {
            // Lệnh đầu: chờ setup tốt
            if(IsSwingLow(1)) {
                canOpenBuy = true;
                entryReason = "Swing Low";
            }
            else if(IsBullishReversal()) {
                canOpenBuy = true;
                entryReason = "Bullish Reversal";
            }
            else {
                // Nếu không có signal, cho phép mở ở điều kiện đơn giản
                double momentum = GetMomentumScore(POSITION_TYPE_BUY);
                if(momentum > 0.6) {
                    canOpenBuy = true;
                    entryReason = "Strong Momentum";
                }
            }
        }
        else if(g_TotalOrders_Buy < MaxOrders && g_LastBuyPrice > 0) {
            double distance = (g_LastBuyPrice - currentPrice) / _Point;
            
            // Sử dụng standard DCA distance với market adjustment
            double requiredDistance = GetSingleDirectionDCADistance(g_TotalOrders_Buy, POSITION_TYPE_BUY);
            
            
            // Priority 1: Swing low (optimal)
            if(IsSwingLow(1) && distance >= requiredDistance * 0.8) {
                canOpenBuy = true;
                entryReason = "Swing Low";
            }
            // Priority 2: Reversal pattern
            else if(IsBullishReversal() && distance >= requiredDistance * 0.85) {
                canOpenBuy = true;
                entryReason = "Bullish Reversal";
            }
            // Priority 3: Distance + momentum
            else if(distance >= requiredDistance) {
                double momentum = GetMomentumScore(POSITION_TYPE_BUY);
                if(momentum > 0.5) {
                    canOpenBuy = true;
                    entryReason = StringFormat("Distance+Momentum(%.2f)", momentum);
                }
            }
        }
        
        if(canOpenBuy) {
            // Volume confirmation
            MqlRates rates[];
            ArraySetAsSeries(rates, true);
            if(CopyRates(_Symbol, PERIOD_M1, 0, 5, rates) >= 5) {
                long avgVol = 0;
                for(int i = 1; i < 5; i++) avgVol += rates[i].tick_volume;
                avgVol = avgVol / 4;
                
                if(rates[0].tick_volume < avgVol * 0.6) {
                    return;
                }
            }
            
            double lotSize = GetNextLotSize(POSITION_TYPE_BUY);
            // double tp = CalculateOrderTP( // DISABLEDORDER_TYPE_BUY, currentPrice, g_TotalOrders_Buy + 1);
            string comment = StringFormat("SB#%d-%s", g_TotalOrders_Buy + 1, entryReason);
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, currentPrice, 0, 0, comment)) {
                g_LastBuyPrice = currentPrice;
                UpdatePeriodOrderCount();
            } else {
            }
        }
    }
    
    // ===========================================================================
    // SELL ONLY
    // ===========================================================================
    else if(g_DailyAllowedDirection == DAILY_SELL_ONLY) {
        bool canOpenSell = false;
        string entryReason = "";
        
        if(g_TotalOrders_Sell == 0) {
            if(IsSwingHigh(1)) {
                canOpenSell = true;
                entryReason = "Swing High";
            }
            else if(IsBearishReversal()) {
                canOpenSell = true;
                entryReason = "Bearish Reversal";
            }
            else {
                double momentum = GetMomentumScore(POSITION_TYPE_SELL);
                if(momentum > 0.6) {
                    canOpenSell = true;
                    entryReason = "Strong Momentum";
                }
            }
        }
        else if(g_TotalOrders_Sell < MaxOrders && g_LastSellPrice > 0) {
            double distance = (currentPrice - g_LastSellPrice) / _Point;
            double requiredDistance = GetSingleDirectionDCADistance(g_TotalOrders_Sell, POSITION_TYPE_SELL);
            
            
            if(IsSwingHigh(1) && distance >= requiredDistance * 0.8) {
                canOpenSell = true;
                entryReason = "Swing High";
            }
            else if(IsBearishReversal() && distance >= requiredDistance * 0.85) {
                canOpenSell = true;
                entryReason = "Bearish Reversal";
            }
            else if(distance >= requiredDistance) {
                double momentum = GetMomentumScore(POSITION_TYPE_SELL);
                if(momentum > 0.5) {
                    canOpenSell = true;
                    entryReason = StringFormat("Distance+Momentum(%.2f)", momentum);
                }
            }
        }
        
        if(canOpenSell) {
            MqlRates rates[];
            ArraySetAsSeries(rates, true);
            if(CopyRates(_Symbol, PERIOD_M1, 0, 5, rates) >= 5) {
                long avgVol = 0;
                for(int i = 1; i < 5; i++) avgVol += rates[i].tick_volume;
                avgVol = avgVol / 4;
                
                if(rates[0].tick_volume < avgVol * 0.6) {
                    return;
                }
            }
            
            double lotSize = GetNextLotSize(POSITION_TYPE_SELL);
            // double tp = CalculateOrderTP( // DISABLEDORDER_TYPE_SELL, currentPrice, g_TotalOrders_Sell + 1);
            string comment = StringFormat("SS#%d-%s", g_TotalOrders_Sell + 1, entryReason);
            
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, currentPrice, 0, 0, comment)) {
                g_LastSellPrice = currentPrice;
                UpdatePeriodOrderCount();
            } else {
            }
        }
    }
}

void HandleSingleDirectionEntry2() {
    if(g_DailyAllowedDirection == DAILY_BOTH) return;
    
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double marketRange = CalculateMarketRange();
    
    // OVERRIDE DIRECTION nếu giá quá xa (chốt lời counter-trend)
    if(marketRange > 0) {
        double priceFromAnchor = (currentPrice - g_AnchorPrice) / _Point;
        double rangeMultiplier = MathAbs(priceFromAnchor) / marketRange;
        
        
        if(priceFromAnchor > marketRange * 3) {
            g_DailyAllowedDirection = DAILY_SELL_ONLY;
        }
        else if(priceFromAnchor < -marketRange * 3) {
            g_DailyAllowedDirection = DAILY_BUY_ONLY;
        }
    }
    
    // BUY ONLY
    if(g_DailyAllowedDirection == DAILY_BUY_ONLY) {
        bool canOpenBuy = false;
        string entryReason = "";
        
        if(g_TotalOrders_Buy == 0) {
            if(IsSwingLow(1)) {
                canOpenBuy = true;
                entryReason = "Swing Low";
            }
            else if(IsBullishReversal()) {
                canOpenBuy = true;
                entryReason = "Bullish Reversal";
            }
            else {
                double momentum = GetMomentumScore(POSITION_TYPE_BUY);
                if(momentum > 0.6) {
                    canOpenBuy = true;
                    entryReason = "Strong Momentum";
                }
            }
        }
        else if(g_TotalOrders_Buy < MaxOrders && g_LastBuyPrice > 0) {
            double distance = (g_LastBuyPrice - currentPrice) / _Point;
            double requiredDistance = GetSingleDirectionDCADistance(g_TotalOrders_Buy, POSITION_TYPE_BUY);
            
            
            if(IsSwingLow(1) && distance >= requiredDistance * 0.8) {
                canOpenBuy = true;
                entryReason = "Swing Low";
            }
            else if(IsBullishReversal() && distance >= requiredDistance * 0.85) {
                canOpenBuy = true;
                entryReason = "Bullish Reversal";
            }
            else if(distance >= requiredDistance) {
                double momentum = GetMomentumScore(POSITION_TYPE_BUY);
                if(momentum > 0.5) {
                    canOpenBuy = true;
                    entryReason = StringFormat("Distance+Momentum(%.2f)", momentum);
                }
            }
        }
        
        if(canOpenBuy) {
            MqlRates rates[];
            ArraySetAsSeries(rates, true);
            if(CopyRates(_Symbol, PERIOD_M1, 0, 5, rates) >= 5) {
                long avgVol = 0;
                for(int i = 1; i < 5; i++) avgVol += rates[i].tick_volume;
                avgVol = avgVol / 4;
                
                if(rates[0].tick_volume < avgVol * 0.6) {
                    return;
                }
            }
            
            double lotSize = GetNextLotSize(POSITION_TYPE_SELL);
            // double tp = CalculateOrderTP( // DISABLEDORDER_TYPE_SELL, currentPrice, g_TotalOrders_Buy + 1);
            string comment = StringFormat("SB#%d-%s", g_TotalOrders_Buy + 1, entryReason);
            
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, currentPrice, 0, 0, comment)) {
                g_LastBuyPrice = currentPrice;
                UpdatePeriodOrderCount();
            } else {
            }
        }
    }
    
    // SELL ONLY
    else if(g_DailyAllowedDirection == DAILY_SELL_ONLY) {
        bool canOpenSell = false;
        string entryReason = "";
        
        if(g_TotalOrders_Sell == 0) {
            if(IsSwingHigh(1)) {
                canOpenSell = true;
                entryReason = "Swing High";
            }
            else if(IsBearishReversal()) {
                canOpenSell = true;
                entryReason = "Bearish Reversal";
            }
            else {
                double momentum = GetMomentumScore(POSITION_TYPE_SELL);
                if(momentum > 0.6) {
                    canOpenSell = true;
                    entryReason = "Strong Momentum";
                }
            }
        }
        else if(g_TotalOrders_Sell < MaxOrders && g_LastSellPrice > 0) {
            double distance = (currentPrice - g_LastSellPrice) / _Point;
            double requiredDistance = GetSingleDirectionDCADistance(g_TotalOrders_Sell, POSITION_TYPE_SELL);
            
            
            if(IsSwingHigh(1) && distance >= requiredDistance * 0.8) {
                canOpenSell = true;
                entryReason = "Swing High";
            }
            else if(IsBearishReversal() && distance >= requiredDistance * 0.85) {
                canOpenSell = true;
                entryReason = "Bearish Reversal";
            }
            else if(distance >= requiredDistance) {
                double momentum = GetMomentumScore(POSITION_TYPE_SELL);
                if(momentum > 0.5) {
                    canOpenSell = true;
                    entryReason = StringFormat("Distance+Momentum(%.2f)", momentum);
                }
            }
        }
        
        if(canOpenSell) {
            MqlRates rates[];
            ArraySetAsSeries(rates, true);
            if(CopyRates(_Symbol, PERIOD_M1, 0, 5, rates) >= 5) {
                long avgVol = 0;
                for(int i = 1; i < 5; i++) avgVol += rates[i].tick_volume;
                avgVol = avgVol / 4;
                
                if(rates[0].tick_volume < avgVol * 0.6) {
                    return;
                }
            }
            
            double lotSize = GetNextLotSize(POSITION_TYPE_BUY);
            // double tp = CalculateOrderTP( // DISABLEDORDER_TYPE_BUY, currentPrice, g_TotalOrders_Sell + 1);
            string comment = StringFormat("SS#%d-%s", g_TotalOrders_Sell + 1, entryReason);
            
            
            if(trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, currentPrice, 0, 0, comment)) {
                g_LastSellPrice = currentPrice;
                UpdatePeriodOrderCount();
            } else {
            }
        }
    }
}


// Hàm mở lệnh theo nhịp giá
// Hàm tính khoảng cách DCA cho Single Direction (sử dụng standard + market adjustment)

// Phát hiện biến động mạnh realtime (không chờ bar close)
bool IsStrongPriceMovement(ENUM_POSITION_TYPE posType) {
    MqlTick tick;
    if(!SymbolInfoTick(_Symbol, tick)) return false;
    
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M1, 0, 3, rates) < 3) return false;
    
    double currentPrice = tick.bid;
    double priceChange = 0;
    
    if(posType == POSITION_TYPE_BUY) {
        // Giá đang tăng mạnh từ recent low
        double recentLow = MathMin(rates[0].low, rates[1].low);
        priceChange = (currentPrice - recentLow) / _Point;
        
        // Tăng >15 points trong vài giây
        if(priceChange > 15 && tick.time > rates[0].time) {
            return true;
        }
    }
    else {
        // Giá đang giảm mạnh từ recent high
        double recentHigh = MathMax(rates[0].high, rates[1].high);
        priceChange = (recentHigh - currentPrice) / _Point;
        
        if(priceChange > 15 && tick.time > rates[0].time) {
            return true;
        }
    }
    
    return false;
}

// Phát hiện tick volume spike realtime
bool IsTickVolumeSpike() {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M1, 0, 10, rates) < 10) return false;
    
    // Average volume của 9 bars trước
    long avgVol = 0;
    for(int i = 1; i < 10; i++) {
        avgVol += rates[i].tick_volume;
    }
    avgVol = avgVol / 9;
    
    // Current bar volume đang tăng mạnh
    long currentVol = rates[0].tick_volume;
    
    if(currentVol > avgVol * 2.0) {
        return true;
    }
    
    return false;
}

// Tính tốc độ thay đổi giá (velocity)
double GetPriceVelocity(ENUM_POSITION_TYPE posType) {
    MqlTick ticks[];
    static datetime lastCheck = 0;
    static double lastPrice = 0;
    
    datetime currentTime = TimeCurrent();
    double currentPrice = GetCleanPrice();
    
    if(lastCheck == 0) {
        lastCheck = currentTime;
        lastPrice = currentPrice;
        return 0;
    }
    
    int timeDiff = (int)(currentTime - lastCheck);
    if(timeDiff < 1) return 0; // Chưa đủ data
    
    double priceChange = (currentPrice - lastPrice) / _Point;
    double velocity = priceChange / timeDiff; // Points per second
    
    lastCheck = currentTime;
    lastPrice = currentPrice;
    
    if(posType == POSITION_TYPE_BUY) {
        return (velocity > 0) ? velocity : 0;
    } else {
        return (velocity < 0) ? MathAbs(velocity) : 0;
    }
}

// Kiểm tra breakout realtime
bool IsBreakout(ENUM_POSITION_TYPE posType) {
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    if(CopyRates(_Symbol, PERIOD_M1, 0, 20, rates) < 20) return false;
    
    double currentPrice = GetCleanPrice();
    
    if(posType == POSITION_TYPE_BUY) {
        // Tìm resistance gần nhất (20 bars)
        double resistance = rates[1].high;
        for(int i = 2; i < 20; i++) {
            if(rates[i].high > resistance) resistance = rates[i].high;
        }
        
        // Breakout nếu vượt resistance
        if(currentPrice > resistance) {
            return true;
        }
    }
    else {
        // Tìm support gần nhất
        double support = rates[1].low;
        for(int i = 2; i < 20; i++) {
            if(rates[i].low < support) support = rates[i].low;
        }
        
        // Breakdown
        if(currentPrice < support) {
            return true;
        }
    }
    
    return false;
}

// 1. Kiểm tra AnalyzeDailyMomentum có hoạt động
DailyDirection AnalyzeDailyMomentum() {
    static datetime lastCheck = 0;
    
    if(TimeCurrent() - lastCheck < 300) {
        return g_DailyAllowedDirection;
    }
    lastCheck = TimeCurrent();
    
    MqlDateTime time_struct;
    TimeToStruct(TimeCurrent(), time_struct);
    
    if(time_struct.hour == 0 || g_DailyOpenPrice == 0) {
        g_DailyOpenPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    }
    
    double currentPrice = GetCleanPrice();
    double dailyChangePoints = (currentPrice - g_DailyOpenPrice) / _Point;
    
    
    // GIẢM THRESHOLD để dễ trigger
    if(dailyChangePoints > 200) { // Từ 300 xuống 200
        return DAILY_BUY_ONLY;
    }
    
    if(dailyChangePoints < -200) { // Từ -300 xuống -200
        return DAILY_SELL_ONLY;
    }
    
    return DAILY_BOTH;
}
// Hàm DCA cho Buy (dùng chung cho cả Sideway và Breakout)
void HandleBuyDCA(double currentPrice, string orderPrefix = "Buy") {
    if(g_TotalOrders_Buy >= 20) {
        return;
    }
    
    if(!EnableBuyOrders) return;
    
    // FIRST ORDER
    if(g_TotalOrders_Buy == 0) {
        if(!canOpenNewTrade_Buy) {
            return;
        }
        
        // Check volume zone cho sideway
        if(orderPrefix == "Box Buy" && IsHighVolumeZone(currentPrice, POSITION_TYPE_BUY)) {
            return;
        }
        
        double lotSize = GetNextLotSize(POSITION_TYPE_BUY);
        double tp = currentPrice + (1000 * _Point);
        string comment = StringFormat("%s #1", orderPrefix);
        
        
        if(trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, currentPrice, 0, 0, comment)) {
            UpdateLastPriceWithVolumeProfile(POSITION_TYPE_BUY, currentPrice);
            canOpenNewTrade_Buy = false;
        } else {
        }
    }
    // DCA ORDERS
    else if(g_LastBuyPrice > 0) {
        double distance = (g_LastBuyPrice - currentPrice) / _Point;
        double requiredDistance = GetAdjustedDCADistanceEnhanced(g_TotalOrders_Buy + 1, MARKET_NORMAL);
        
  
        // Price phải GIẢM
        if(currentPrice >= g_LastBuyPrice) {
            return;
        }
        
        if(distance < requiredDistance) {
            return;
        }
        
        // Volume checks
        if(orderPrefix == "Box Buy" && IsHighVolumeZone(currentPrice, POSITION_TYPE_BUY)) {
            return;
        }
        
        if(!HasStrongVolumeMomentum(POSITION_TYPE_BUY)) {
            return;
        }
        
        // Order flow check
        OrderFlowStrength flow = AnalyzeOrderFlowAdvanced();
        if(flow == FLOW_STRONG_SELL) {
            return;
        }
        
        double lotSize = GetNextLotSize(POSITION_TYPE_BUY);
        double tp = currentPrice + (1000 * _Point);
        string comment = StringFormat("%s #%d", orderPrefix, g_TotalOrders_Buy + 1);
        
        
        if(trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, lotSize, currentPrice, 0, 0, comment)) {
            UpdateLastPriceWithVolumeProfile(POSITION_TYPE_BUY, currentPrice);
        } else {
        }
    }
}

// Hàm DCA cho Sell (dùng chung cho cả Sideway và Breakout)
void HandleSellDCA(double currentPrice, string orderPrefix = "Sell") {
    if(g_TotalOrders_Sell >= 20) {
        return;
    }
    
    if(!EnableSellOrders) return;
    
    // FIRST ORDER
    if(g_TotalOrders_Sell == 0) {
        if(!canOpenNewTrade_Sell) {
            return;
        }
        
        // Check volume zone cho sideway
        if(orderPrefix == "Box Sell" && IsHighVolumeZone(currentPrice, POSITION_TYPE_SELL)) {
            return;
        }
        
        double lotSize = GetNextLotSize(POSITION_TYPE_SELL);
        double tp = currentPrice - (1000 * _Point);
        string comment = StringFormat("%s #1", orderPrefix);
        
        
        if(trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, currentPrice, 0, 0, comment)) {
            UpdateLastPriceWithVolumeProfile(POSITION_TYPE_SELL, currentPrice);
            canOpenNewTrade_Sell = false;
        } else {
        }
    }
    // DCA ORDERS
    else if(g_LastSellPrice > 0) {
        double distance = (currentPrice - g_LastSellPrice) / _Point;
        double requiredDistance = GetAdjustedDCADistanceEnhanced(g_TotalOrders_Sell + 1, MARKET_NORMAL);
        
     
        // Price phải TĂNG
        if(currentPrice <= g_LastSellPrice) {
            return;
        }
        
        if(distance < requiredDistance) {
            return;
        }
        
        // Volume checks
        if(orderPrefix == "Box Sell" && IsHighVolumeZone(currentPrice, POSITION_TYPE_SELL)) {
            return;
        }
        
        if(!HasStrongVolumeMomentum(POSITION_TYPE_SELL)) {
            return;
        }
        
        // Order flow check
        OrderFlowStrength flow = AnalyzeOrderFlowAdvanced();
        if(flow == FLOW_STRONG_BUY) {
            return;
        }
        
        double lotSize = GetNextLotSize(POSITION_TYPE_SELL);
        double tp = currentPrice - (1000 * _Point);
        string comment = StringFormat("%s #%d", orderPrefix, g_TotalOrders_Sell + 1);
        
        
        if(trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, lotSize, currentPrice, 0, 0, comment)) {
            UpdateLastPriceWithVolumeProfile(POSITION_TYPE_SELL, currentPrice);
        } else {
        }
    }
}
// Cập nhật HandleSingleDirectionEntry

bool ShouldAllowTradingByVolume() {
    double currentPrice = GetCleanPrice();
    
    // Tính average volume
    double avgVolume = 0;
    int count = 0;
    for(int i = 0; i < ArraySize(g_VolumeProfile); i++) {
        if(g_VolumeProfile[i].volume > 0) {
            avgVolume += g_VolumeProfile[i].volume;
            count++;
        }
    }
    if(count > 0) avgVolume /= count;
    
    // Tìm volume tại giá hiện tại
    double currentVolume = 0;
    double minDist = DBL_MAX;
    for(int i = 0; i < ArraySize(g_VolumeProfile); i++) {
        double dist = MathAbs(g_VolumeProfile[i].price - currentPrice);
        if(dist < minDist) {
            minDist = dist;
            currentVolume = g_VolumeProfile[i].volume;
        }
    }
    
    bool isHighVolume = (currentVolume >= avgVolume * HighVolumeThreshold);
    bool isLowVolume = (currentVolume <= avgVolume * LowVolumeThreshold);
    
    // Logic: Trade ở LVN (giá di chuyển nhanh) hoặc tránh HVN (tích lũy)
    if(TradeInLowVolume) {
        return isLowVolume || (!isHighVolume && currentPrice < g_VAL) || (!isHighVolume && currentPrice > g_VAH);
    } else {
        return isHighVolume || (currentPrice >= g_VAL && currentPrice <= g_VAH);
    }
}
datetime g_LastDrawdownReset = 0;              // Th?i gian reset drawdown g?n nh?t